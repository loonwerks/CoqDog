Enable Upload FolderDisable Upload Folder
Folder uploaded and extracted successfully!
Include requirement chainDon't include requirement chain
User: Given the context Require Import ConcreteEvidence AutoApp Auto Helpers_CvmSemantics Term_Defs Anno_Term_Defs Cvm_St Cvm_Impl Defs StructTactics OptMonad_Coq IO_Stubs Evidence_Bundlers Axioms_Io External_Facts. (* Cvm_Monad *)

Require Import List.
Import ListNotations.

Require Import Lia Coq.Program.Tactics.


Definition peel_bs (ls:RawEv) : Opt (BS * RawEv) :=
  match ls with
  | bs :: ls' => ret (bs, ls')
  | _ => failm
  end.

Lemma firstn_long: forall (e:list BS) x,
    length e >= x ->
    length (firstn x e) = x.
Proof.
  intros.
  eapply firstn_length_le.
  lia.
Defined.

Lemma skipn_long: forall (e:list BS) x y,
    length e = x + y ->
    length (skipn x e) = y.
Proof.
  intros.
  assert (length (skipn x e) = length e - x).
  { eapply skipn_length. }
  lia.
Defined.

Lemma peel_fact': forall e x y H,
    length e = S x ->
    peel_bs e = Some (y, H) ->
    length H = x.
Proof.
  intros.
  destruct e;
    ff; eauto.
Defined.

Lemma peel_fact: forall e x y H et,
    length e = S x ->
    peel_bs e = Some (y, H) ->
    et_size et = x ->
    wf_ec (evc H et).
Proof.
  intros.
  econstructor.
  eapply peel_fact'; eauto.
  lia.
Defined.

Fixpoint encodeEv (e:EvidenceC) : RawEv :=
  match e with
  | mtc => []
  | nnc _ bs => [bs]
  | ggc _ _ bs e' => bs :: (encodeEv e')
  | hhc _ _ bs _ => [bs]
  | eec _ _ bs _ => [bs]
  | kkc _ _ _ => []
  | kpc _ _ e' => encodeEv e'
  | ssc e1 e2 => (encodeEv e1) ++ (encodeEv e2)
  end.

Fixpoint reconstruct_ev' (ls:RawEv) (et:Evidence) : Opt EvidenceC :=
  match et with
  | mt => 
    match ls with
    | [] => Some mtc
    | _ => None
    end
  | uu p fwd ps et' =>
    match fwd with
    | EXTD => 
      '(bs, ls') <- peel_bs ls ;;
      x <- reconstruct_ev' ls' et' ;;
      Some (ggc p ps bs x)
    | COMP =>
      '(bs, ls') <- peel_bs ls ;;
      match ls' with
      | [] => Some (hhc p ps bs et')
      | _ => None
      end
    | ENCR =>
      '(bs, ls') <- peel_bs ls ;;
      match ls' with
      | [] => Some (eec p ps bs et')
      | _ => None
      end
    | KILL =>
      match ls with
      | [] => Some (kkc p ps et')
      | _ => None
      end
    | KEEP =>
      x <- reconstruct_ev' ls et' ;;
      Some (kpc p ps x)
    end
  | nn i =>
    '(bs, ls') <- peel_bs ls ;;
     match ls' with
    | [] => Some (nnc i bs)
    | _ => None
    end 
  | ss et1 et2 =>
    e1 <- reconstruct_ev' (firstn (et_size et1) ls) et1 ;;
    e2 <- reconstruct_ev' (skipn (et_size et1) ls) et2 ;;
    Some (ssc e1 e2)
  end.

Definition reconstruct_ev (e:EvC) : Opt EvidenceC :=
  match e with
  | evc ls et => reconstruct_ev' ls et
  end.

Inductive reconstruct_evP: EvC -> EvidenceC -> Prop :=
| reconstruct_evC: forall e ee,
    Some ee = reconstruct_ev e ->
    reconstruct_evP e ee.


Lemma inv_recon_mt: forall ls et,
    reconstruct_evP (evc ls et) mtc ->
    (et = mt) (* \/ (exists p ps et', et = uu p KILL ps et')
    \/ (exists p ps et', et = uu p KEEP ps et')) *) .
Proof.
  intros.
  invc H.
  destruct et;
    repeat ff;
    try (unfold OptMonad_Coq.bind in *);
         repeat ff;
         try solve_by_inversion.
                    
         -
           eauto.
           (*
         -
           right.
           right.
           eauto. *)
                                   
Defined.

Ltac do_inv_recon_mt :=
  match goal with
  | [H: reconstruct_evP (evc _ ?et) mtc

     |- _] =>
    assert_new_proof_by (et = mt (* \/ (exists p ps et', et = uu p KILL ps et') \/ (exists p ps et', et = uu p KEEP ps et') *) ) ltac:(eapply inv_recon_mt; apply H)
  end;
  (* door; *)
  subst.

Lemma inv_recon_mt': forall ls e,
    reconstruct_evP (evc ls mt) e ->
    e = mtc.
Proof.
  intros.
  invc H.
  repeat ff; try solve_by_inversion; eauto.
Defined.

Ltac do_inv_recon_mt' :=
  match goal with
  | [H: reconstruct_evP (evc _ mt) ?e

     |- _] =>
    assert_new_proof_by (e = mtc) ltac:(eapply inv_recon_mt'; apply H)
  end;
  subst.


Lemma inv_recon_nn: forall ls et n n0,
    reconstruct_evP (evc ls et) (nnc n n0) ->
    ((et = nn n /\ ls = [n0]) (* \/ (exists p ps et', et = uu p KEEP ps et') *) ).
Proof.
  intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; destruct ls; try solve_by_inversion.

                               (*
                               -
                                 eauto.
                               -
                                 eauto. *)
                                 
                                 
Defined.

Ltac do_inv_recon_nn :=
  match goal with
  | [H: reconstruct_evP (evc ?ls ?et) (nnc ?n ?nval)

     |- _] =>
    assert_new_proof_by (et = nn n /\ ls = [nval] (* \/ (exists p ps et', et = uu p KEEP ps et') *) ) ltac:(eapply inv_recon_nn; apply H)
  end;
  destruct_conjs;
  subst.

Lemma inv_recon_gg: forall p ps ls et n ec,
    reconstruct_evP (evc ls et) (ggc p ps n ec) ->
    (exists ls' et', et = uu p EXTD ps et' /\
                ls = n :: ls') (* \/ (exists p ps et', et = uu p KEEP ps et') *) .
Proof.
  intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; try solve_by_inversion.
                               -
                                 (*
                                 left. *)
                                 repeat eexists.
                                 destruct ls; ff.
                                 (*
                               -
                                 right.
                                 eauto. *)
                                 
Defined.

Ltac do_inv_recon_gg :=
  match goal with
  | [H: reconstruct_evP (evc ?ls ?et) (ggc ?p ?ps ?n _)

     |- _] =>
    assert_new_proof_by ((exists ls' et', et = uu p EXTD ps et' /\
                                    ls = n :: ls') (* \/ (exists p ps et', et = uu p KEEP ps et') *) )
                        ltac:(eapply inv_recon_gg; apply H)
  end;
  destruct_conjs;
  subst.

Lemma inv_recon_hh: forall p ps ls et n et',
    reconstruct_evP (evc ls et) (hhc p ps n et') ->
    ((et = uu p COMP ps et' ) /\ ls = [n]) (* \/ (exists p ps et', et = uu p KEEP ps et') *) .
Proof.
  intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; destruct ls; try solve_by_inversion.
                               (*
                               -
                                 right. eauto.
                               -
                                 right. eauto. *)
                                 
                                 
Defined.

Ltac do_inv_recon_hh :=
  match goal with
  | [H: reconstruct_evP (evc ?ls ?et) (hhc ?p ?ps ?hval ?et')

     |- _] =>
    assert_new_proof_by ((et = uu p COMP ps et' /\ ls = [hval]) (* \/ (exists p ps et', et = uu p KEEP ps et') *) )
                        ltac:(eapply inv_recon_hh; apply H)
  end;
  destruct_conjs;
  subst.

Lemma inv_recon_ee: forall p ps ls et (*et'*) n ec',
    reconstruct_evP (evc ls et) (eec p ps n (*et'*) ec') ->
    (* (exists et', et = uu p ENCR ps et' ) /\ ls = [n]. *)
    (exists et', et = uu p ENCR ps et' /\ ls = [n]) (* \/ (exists p ps et', et = uu p KEEP ps et') *) .
Proof.
  intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; destruct ls; try solve_by_inversion.
                               -
                                 (*
                                 left. *)
                               repeat eexists.
                               ff.
                               (*
                               -
                                 right. eauto.
                               -
                                 right. eauto. *)
                                 
                                 
                               
Defined.

Ltac do_inv_recon_ee :=
  match goal with
  | [H: reconstruct_evP (evc ?ls ?et) (eec ?p ?ps ?hval (*_*) _)

     |- _] =>
    assert_new_proof_by ( (exists et', et = uu p ENCR ps et' /\ ls = [hval]) (* \/ (exists p ps et', et = uu p KEEP ps et') *) )
                        ltac:(eapply inv_recon_ee; apply H)
  end;
  destruct_conjs;
  subst.

(*
Lemma inv_recon_kk: forall p ps ls et et',
    reconstruct_evP (evc ls et) (kkc p ps et') ->
    (et = uu p KILL ps et' ) /\ ls = [].
Proof.
  intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff; destruct ls; try solve_by_inversion.
Defined.

Ltac do_inv_recon_kk :=
  match goal with
  | [H: reconstruct_evP (evc ?ls ?et) (kkc ?p ?ps ?et')

     |- _] =>
    assert_new_proof_by (et = uu p KILL ps et' /\ ls = [])
                        ltac:(eapply inv_recon_kk; apply H)
  end;
  destruct_conjs;
  subst.
*)

Lemma inv_recon_ss: forall ls et ec1 ec2,
    reconstruct_evP (evc ls et) (ssc ec1 ec2) ->
    (exists et1 et2, et = ss et1 et2) (* \/ (exists p ps et', et = uu p KEEP ps et') *) .
Proof.
  intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; try solve_by_inversion.
                               -
                                 (*
                                 right. *)  eauto.
                                            (* 
                               -
                               left. eauto.
                                             *)
                                            
Defined.

Ltac do_inv_recon_ss :=
  match goal with
  | [H: reconstruct_evP (evc _ ?et) (ssc _ _)

     |- _] =>
    assert_new_proof_by ((exists et1 et2, et = ss et1 et2) (* \/ (exists p ps et', et = uu p KEEP ps et') *) )
                        ltac:(eapply inv_recon_ss; apply H)
  end;
  destruct_conjs;
  subst.


Ltac do_inv_recon :=
  try do_inv_recon_mt;
  try do_inv_recon_mt';
  try do_inv_recon_nn;
  try do_inv_recon_gg;
  try do_inv_recon_hh;
  try do_inv_recon_ee;
  (* try do_inv_recon_kk; *)
  try do_inv_recon_ss.

Lemma recon_inv_gg: forall sig ls p ps et e,
    reconstruct_evP
      (evc (sig :: ls) (uu p EXTD ps et))
      (ggc p ps sig e) ->
    reconstruct_evP (evc ls et) e.
Proof.
  intros.
  invc H.
  repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff;
  econstructor.
  symmetry.
  tauto.
Defined.

Ltac do_recon_inv_gg :=
  match goal with
  | [H: reconstruct_evP
          (evc (_ :: ?ls) (uu _ _ _ ?et))
          (ggc _ _ _ ?e)
     |- _] =>
    assert_new_proof_by (reconstruct_evP (evc ls et) e) ltac:(eapply recon_inv_gg; apply H)
  end.

Lemma recon_inv_ss: forall ls H1 H2 ec1 ec2,
    reconstruct_evP (evc ls (ss H1 H2)) (ssc ec1 ec2) ->
    reconstruct_evP (evc (firstn (et_size H1) ls) H1) ec1 /\
    reconstruct_evP (evc (skipn (et_size H1) ls) H2)  ec2.
Proof.
  intros.
  invc H.
  repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff;
  split;
    econstructor;
    try 
      symmetry; eassumption.
Qed.

Ltac do_recon_inv_ss :=
  match goal with
  | [H: reconstruct_evP
          (evc ?ls (ss ?H1 ?H2))
          (ssc ?ec1 ?ec2) _
     |- _] =>
    assert_new_proof_by
      (reconstruct_evP (evc (firstn (et_size H1) ls) H1) ec1 /\
       reconstruct_evP (evc (skipn (et_size H1) ls) H2)  ec2)
      ltac:(eapply recon_inv_ss; apply H)
  end; destruct_conjs.

Ltac do_recon_inv :=
  try do_recon_inv_gg;
  try do_recon_inv_ss.


Lemma wrap_reconP: forall ec e,
    reconstruct_ev ec = Some e ->
    reconstruct_evP ec e.
Proof.
  intros.
  econstructor.
  congruence.
Defined.

Lemma fold_recev: forall e0 e1,
    reconstruct_ev' e0 e1 = reconstruct_ev (evc e0 e1).
Proof.
  ff.
  tauto.
Defined.

Ltac do_wrap_reconP :=
  repeat
  match goal with
  | [H: reconstruct_ev ?ec = Some ?e
     |- _] =>
    apply wrap_reconP in H
  end.

Ltac do_rewrap_reconP :=
  match goal with
  | [H: reconstruct_evP (evc _ (?cc _)) _
     |- _] =>
    invc H;
    repeat ff;
    try rewrite fold_recev in *;
    do_wrap_reconP
  end.


(*
TODO: try this again after appraisal lemmas settled 
*)

Lemma etfun_reconstruct: forall e e0 e1,
    reconstruct_evP (evc e0 e1) e ->
    e1 = et_fun e (* \/ (exists p ps et', e1 = uu p KEEP ps et' /\ et' = et_fun e) *) .
Proof.
  intros.
  generalizeEverythingElse e1.

  (*
  induction e1; intros e e0 H;
    do_inv_recon;
    ff.
  -
    invc H.
    repeat ff;
      try (unfold OptMonad_Coq.bind in * );
           repeat ff.
  -
    invc H;
      ff;
      try (unfold OptMonad_Coq.bind in * );
      destruct f;    try (unfold OptMonad_Coq.bind in * );
      try (ff; tauto).
    +
      ff.
      assert (e1 = et_fun e2).
      eapply IHe1.
      econstructor; eauto.
      subst.
      tauto.
    +
      ff.
      
      
      
      
      
      eauto.
      tauto.
    ff.
    repeat ff;
      try (unfold OptMonad_Coq.bind in * );
           repeat ff.
           +
             assert (e1 = et_fun e2).
             eapply IHe1.
             econstructor; eauto.
             subst.
             tauto.
           +

             Locate et_fun.
             Locate reconstruct_ev.
             
 *)
             
             
                      
   


  
  induction e1; intros e e0 H.
  - (* mt case *)
    invc H.
    ff.
    tauto.
  - (* nn case *)
    invc H.
    repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    
    
    

  (* 
    try (
    do_inv_recon;
    ff;
    invc H;
    repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff;
    rewrite fold_recev in *;
    do_wrap_reconP;
    repeat jkjke).
   *)
  
  - (* uu case *)
    destruct f; ff.
    + (* COMP case *)
      invc H.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    + (* ENCR case *)
      (*
      Print et_fun.
      Print do_inv_recon_ee.
      Print do_inv_recon_ee.
      Locate reconstruct_ev.
       *)
      
      invc H.
      unfold reconstruct_ev in *.
      unfold reconstruct_ev' in *.
      unfold OptMonad_Coq.bind in *.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
           
    + (* EXTD case *)
      (* left. *)
      invc H.
      ff.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
      assert (e1 = et_fun e2 (* \/ (exists (p : Plc) (ps : ASP_PARAMS) (et' : Evidence),
                                   e1 = uu p KEEP ps et' /\ et' = et_fun e2) *) ).
      {
      eapply IHe1.
      econstructor.
      ff.
      }
      (*
      door.
      ++ *)
        
      congruence.
      (*
      ++
        
        
      subst.
      
      
      congruence. *)
    + (* KILL case *)
      invc H.
      unfold reconstruct_ev in *.
      ff.
    + (* KEEP case *)
      invc H.
      unfold reconstruct_ev in *.
      ff.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
      assert (e1 = et_fun e2).
      { eapply IHe1.
        econstructor.
        unfold reconstruct_ev.
        symmetry.
        eassumption.
      }
      subst.
      tauto.
  - (* ss case *)
    invc H.
    ff.
    repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    assert (e1_1 = et_fun e1).
    {
      eapply IHe1_1.
      econstructor.
      symmetry.
      eassumption.
    }
    assert (e1_2 = et_fun e2).
    {
      eapply IHe1_2.
      econstructor.
      symmetry.
      eassumption.
    }
    congruence.
Qed.

Lemma wfec_split: forall e s,
    wf_ec e ->
    wf_ec (splitEv_l s e) /\ wf_ec (splitEv_r s e).
Proof.
  intros.
  split;
    destruct s; ff; try unfold mt_evc; ff;
      econstructor; ff.
Defined.

Ltac do_wfec_split :=
  match goal with
  | [H: context[splitEv_l ?s ?e],
        H2: context[splitEv_r ?s ?e],
            H3: wf_ec ?e
     |- _] =>
    
    assert_new_proof_by
      (wf_ec (splitEv_l s e) /\ wf_ec (splitEv_r s e))
      ltac: (eapply wfec_split; apply H3)
  end; destruct_conjs.




(* Lemma:  Encoding an EvC bundle gives you the bits used 
   to (re)construct it. *)
Lemma recon_encodeEv: forall bits et ec,
    reconstruct_evP (evc bits et) ec ->
    encodeEv ec = bits.
Proof.
  intros.
  generalizeEverythingElse ec.
  induction ec; intros.
  -
    dd.
    do_inv_recon.
    invc H.
    repeat ff.
    (*
    invc H.
    repeat ff. *)
  - (* nnc case *)
    do_inv_recon.
    ff.
  - (* ggc case *)
    do_inv_recon.
    ff.
    invc H.
    repeat ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    assert (reconstruct_evP (evc H0 H1) e).
    {
      econstructor; eauto.
    }
    assert (encodeEv e = H0) by eauto.
    congruence.
  - (* hhc case *)
    do_inv_recon.
    ff.
  - (* eec case *)
    
    do_inv_recon.
    ff.

    (*
  -
    do_inv_recon.
    ff. 
     *)

  - (* kkc case *)
    do_inv_recon.
    ff.
    invc H.
    ff.
    unfold reconstruct_ev' in *.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    rewrite fold_recev in *.
    unfold reconstruct_ev in *.
    unfold reconstruct_ev' in *.
    destruct et; try solve_by_inversion.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.


  - (* kpc case *)
    ff.

    assert (exists et', et = uu p KEEP a et').
    {
      destruct et; try solve_by_inversion.
      +
        invc H.
        ff.
      +
        invc H.
        ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
      +
        invc H.
        ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
        eexists.
        tauto.
      +
        invc H.
        ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    }
    
    destruct_conjs.
    subst.

    invc H.
    ff.
    repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    eapply IHec.
    econstructor.
    ff.
    
    
    
    
    
    
  - (* ssc case *)
    do_inv_recon.
    ff.
    invc H.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    rewrite fold_recev in *.
    do_wrap_reconP.
    
    
    assert (encodeEv e =  (firstn (et_size H0) bits)) by eauto.
    assert (encodeEv e0 = (skipn (et_size H0) bits)) by eauto.

    assert (bits = firstn (et_size H0) bits ++ skipn (et_size H0) bits).
    {
      symmetry.
      eapply firstn_skipn.
    }
    rewrite H3 at 1.
    congruence.
Qed.

Lemma recon_encodeEv_Raw: forall ec bits et,
    reconstruct_evP (evc bits et) ec ->
    encodeEvRaw (encodeEv ec) = encodeEvBits (evc bits et).
Proof.
  intros.
  unfold encodeEvBits.
  erewrite recon_encodeEv.
  tauto.
  eauto.
Defined.

Lemma wfec_recon: forall (ee:EvC) (ec:EvidenceC),
    reconstruct_evP ee ec ->
    wf_ec ee.
Proof.
  intros.
  generalizeEverythingElse ec.
  induction ec; intros; destruct ee.
  - (* mtc case *)
    do_inv_recon.
    dd.
    invc H.
    dd.
    ff.
    econstructor. tauto.
    (* 
    invc H.
    repeat ff. *)
    (*
    econstructor. tauto. *)
  - (* nnc case *)
    do_inv_recon.
    invc H.
    dd.
    econstructor; tauto.
  - (* ggc case *)
    do_inv_recon.
    invc H.
    dd.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    assert (wf_ec (evc H0 H1)).
    {
      apply IHec.
      econstructor.
      eauto.
    }
    econstructor.
    dd.
    invc H.
    lia.

  - (* hhc case *)
    do_inv_recon.
    invc H.
    dd.
    econstructor; tauto.
  - (* eec case *)
    do_inv_recon.
    invc H.
    dd.
    econstructor; tauto.
    (*
  -
    do_inv_recon.
    invc H.
    econstructor; tauto.   
     *)

  - (* kkc case *)
    invc H.
    unfold reconstruct_ev in *.
    unfold reconstruct_ev' in *.
    destruct e0; try solve_by_inversion.
    ff.
    unfold OptMonad_Coq.bind in *. ff.
    unfold OptMonad_Coq.bind in *. ff.
    econstructor.
    ff.
    unfold OptMonad_Coq.bind in *. ff.
  - (* kpc case *)
    invc H.
    destruct e; try solve_by_inversion.
    +
      ff.
    +
      ff.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    +
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
      assert (wf_ec (evc r e)).
      {
        eapply IHec. econstructor.
        symmetry. eassumption. }
      econstructor.
      ff.
    +
      ff.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
   
  -
    do_inv_recon.
    invc H.
    dd.
    ff.
    unfold OptMonad_Coq.bind in *.
    
    ff.

    assert (wf_ec (evc (firstn (et_size H0) r) H0)).
    {
      apply IHec1.
      econstructor.
      eauto.
    }
    assert (wf_ec (evc (skipn (et_size H0) r) H1)).
    {
      apply IHec2.
      econstructor.
      eauto.
    }
    
    econstructor.
    dd.
    invc H.
    invc H2.
    rewrite <- H4.
    rewrite <- H3.
    assert (r = firstn (et_size H0) r ++ skipn (et_size H0) r).
    {
      symmetry.
      eapply firstn_skipn.
    }
    rewrite H at 1.
    eapply app_length.
Qed.

Lemma reconP_determ: forall ec e e',
    reconstruct_evP ec e ->
    reconstruct_evP ec e' ->
    e = e'.
Proof.
  intros.
  invc H; invc H0.
  repeat jkjke'.
  ff.
Defined.

Ltac do_reconP_determ :=
  repeat 
  match goal with
  | [H: reconstruct_evP ?ec ?e,
        H2: reconstruct_evP ?ec ?e2
     |- _] =>
    assert_new_proof_by (e = e2)
                        ltac:(eapply reconP_determ; [apply H | apply H2]);
    clear H2
  end; subst.



Ltac inv_wfec :=
  repeat
    match goal with
    | [H: wf_ec _ |-  _ ] => invc H
    end.

(** * If a raw evidence sequence is non-empty, we can grab a first element. *)
Lemma some_recons' : forall e x,
    length e = S x ->
    exists bs ls', peel_bs e = Some (bs, ls').
Proof.
  intros.
  destruct e;
    ff; eauto.
Defined.

Ltac do_some_recons' :=
  match goal with
  | [H: length ?e = S _ |- _ ] =>
    edestruct some_recons'; [apply H | idtac]
                              
  end; destruct_conjs; jkjke.

Ltac do_rcih :=
  match goal with
  | [H: context[reconstruct_ev' _ _]
               

     |- context[reconstruct_ev' ?e' ?et] ] =>
    assert_new_proof_by
      (exists x, Some x = reconstruct_ev' e' et)
      ltac:(eapply H with (r:=e'); (* TODO:  make r less one-off *)
            try (eapply peel_fact; eauto; tauto);
            try (econstructor; first [eapply firstn_long | eapply skipn_long]; try eauto; try lia))      
  end.

(** * Lemma:  well-formed EvC bundles can be successfully reconstructed to a Typed Concrete Evidence (EvidenceC) value. *)
Lemma some_recons : forall (e:EvC),
    wf_ec e ->
    exists (ee:EvidenceC), Some ee = reconstruct_ev e.
Proof.
  intros.
  destruct e.
  generalizeEverythingElse e.
  induction e; intros.
  -
  try (repeat ff; eauto; tauto).
    try
      ( inv_wfec; ff;
        do_some_recons');
    try (
        repeat do_rcih;
        destruct_conjs;
        repeat jkjke');
    try ( inv_wfec; ff;
          repeat do_rcih;
          destruct_conjs;
          repeat jkjke';
          repeat ff; eauto).

  - (* nn case *)
    repeat ff.
    (unfold OptMonad_Coq.bind in * ).
     repeat ff.
     +
     eauto.
     +
       inv_wfec.
       ff.
       destruct r; try solve_by_inversion.
       ff.
       unfold OptMonad_Coq.ret in *.
       repeat ff.
       

     +
       destruct r; try solve_by_inversion.
       ff.
       invc H.
       ff.


    
  - (* uu case *)

    destruct f.
    
    + (* COMP case *)

      inv_wfec.
      ff.
      repeat ff;
    (unfold OptMonad_Coq.bind in * );
    repeat ff; eauto.

      ++
       ff.
       assert (exists v, r = [v]).
       {
         destruct r; ff.
         destruct r; ff. }
       destruct_conjs. subst.
       ff.
      ++
       assert (exists v, r = [v]).
       {
         destruct r; ff. }
       destruct_conjs. subst.
       ff.
    + (* ENCR case *)

      inv_wfec.
      ff.
      repeat ff;
    (unfold OptMonad_Coq.bind in * );
    repeat ff; eauto.
      ++
         ff.
       assert (exists v, r = [v]).
       {
         destruct r; ff.
         destruct r; ff. }
       destruct_conjs. subst.
       ff.
      ++
       assert (exists v, r = [v]).
       {
         destruct r; ff. }
       destruct_conjs. subst.
       ff.
    + (* EXTD case *)
      inv_wfec.
      ff.
      unfold OptMonad_Coq.bind in * ;
        repeat ff; eauto.
      ++
        assert (wf_ec (evc r0 e)).
        {
          eapply peel_fact.
          eassumption.
          eassumption.
          tauto.
        }
       
          
          
        assert (exists ee, Some ee = reconstruct_ev' r0 e).
        {
          invc H.
          eapply IHe.
         econstructor. eassumption. }
        destruct_conjs.
        ff.
      ++
         inv_wfec.
       ff.
       assert (r = []).
       {
         destruct r; ff.
       }
       subst.
       ff.
    + (* KILL case *)
      inv_wfec.
      ff.
      eauto.
    + (* KEEP case *)
      inv_wfec.
      simpl in H1.
      ff.

    repeat ff;
    (unfold OptMonad_Coq.bind in * );
    repeat ff; eauto.
    assert (exists ee, Some ee = reconstruct_ev' r e).
    { eapply IHe.
      econstructor.
      eassumption.
    }
    destruct_conjs.
    congruence.




    (*



    
     +
       inv_wfec.
       ff.
       assert (exists v, r = [v]).
       {
         destruct r; ff.
         destruct r; ff. }
       destruct_conjs. subst.
       ff.
     +
       inv_wfec.
       assert (r = []).
       {
         destruct r; ff. }
       subst.
       ff.
     +
       inv_wfec.
       ff.
       assert (exists v, r = [v]).
       { destruct r; ff.
       destruct r; ff. }
       destruct_conjs.
       subst.
       ff.
     +
       inv_wfec.
       ff.
       assert (exists v, r = [v]).
       { destruct r; ff. }
       destruct_conjs.
       subst.
       ff.
     +
       inv_wfec.
       ff.
       destruct r; ff.
       unfold OptMonad_Coq.ret in *.
       ff.
       assert (exists ee, Some ee = reconstruct_ev' r0 e).
       { eapply IHe.
         econstructor. eassumption. }
       destruct_conjs.
       rewrite <- H1 in *.
       solve_by_inversion.
     +
       inv_wfec.
       ff.
       assert (r = []).
       {
         destruct r; ff.
       }
       subst.
       ff.
     +
       inv_wfec.
       ff.
       
       
       
       
       
       
      (* 
       
       
     
     +
       inv_wfec.
       ff.
       eapply peel_fact.
     eauto.
     +
       inv_wfec.
       assert (wf_ec (evc r0 e)).
       {
         eapply peel_fact; eauto.
       }
       ff.
     +
       destruct r; try solve_by_inversion.
       ff.
       invc H.
       ff.

         -
    repeat ff.
    (unfold OptMonad_Coq.bind in * ).
     repeat ff.
     +
     eauto.
     +
       inv_wfec.
       ff.
       destruct r; try solve_by_inversion.
       ff.
       unfold OptMonad_Coq.ret in *.
       repeat ff.
       

     +
       destruct r; try solve_by_inversion.
       ff.
       invc H.
       ff.
       *)
     +
       inv_wfec.
       ff.
       edestruct IHe.
       econstructor.
       eassumption.
       asdf
       
       *)
         
       
    
     - (* ss case *)
       try (ff; eauto; tauto).
       inv_wfec; ff.
    do_rcih.
    do_rcih.
    destruct_conjs.
    jkjke'.
    jkjke'.
    ff.
    eauto.
Qed.

Lemma some_reconsP : forall e,
    wf_ec e ->
    exists ee, reconstruct_evP e ee.
(*Proof.
  intros.
  edestruct some_recons.
  eassumption.
  eexists.
  econstructor.
  eassumption.
Defined.*)

Proof. (* GPT-3.5-turbo-0613, score 100% - 1 shot + context: the above part of this file only *)
  intros.
  eapply some_recons in H.
  destruct H as [ee H].
  exists ee.
  eapply wrap_reconP.
  eauto.
Qed.

Ltac do_somerecons :=
  repeat
    match goal with
    | [H: wf_ec ?e
       |- _ ] =>
      assert_new_proof_by
        (exists x, reconstruct_evP e x)
        ltac:(eapply some_reconsP; apply H)     
    end; destruct_conjs.

Definition spc_ev (sp:SP) (e:EvidenceC) : EvidenceC :=
  match sp with
  | ALL => e
  | NONE => mtc
  end.

(*
TODO: try this again after appraisal lemmas settled 
*)

Definition cvm_evidence_denote_asp (a:ASP) (p:Plc) (e:EvidenceC) (x:Event_ID): EvidenceC :=
  match a with
  | NULL => mtc
  | CPY => e
  | ASPC sp fwd params =>
    match fwd with
    | COMP => hhc p params
                 (do_asp params (encodeEv (spc_ev sp e)) p x)
                 (sp_ev sp (et_fun e))
    | EXTD => ggc p params
                 (do_asp params (encodeEv (spc_ev sp e)) p x)
                 (spc_ev sp e)
    | ENCR => eec p params
                 (do_asp params (encodeEv (spc_ev sp e)) p x)
                 (sp_ev sp (et_fun e))
    | KEEP => (spc_ev sp e)
    | KILL => mtc (* kkc p params (sp_ev sp (et_fun e)) *)
    end
  | SIG => ggc p sig_params
              (do_asp sig_params (encodeEv e) p x)
              e
  | HSH => hhc p hsh_params
              (do_asp hsh_params (encodeEv e) p x)
              (et_fun e)
  | ENC q => eec p (enc_params q)
                (do_asp (enc_params q) (encodeEv e) p x)
                (et_fun e)
  end.


(** * Denotation function of a Typed Concrete Evidence value from an annotated term, initial place, initial evidence *)
Fixpoint cvm_evidence_denote (t:AnnoTerm) (p:Plc) (ec:EvidenceC) : EvidenceC :=
  match t with
  | aasp (i,_) x => cvm_evidence_denote_asp x p ec i
  | aatt _ q x => cvm_evidence_denote x q ec
  | alseq _ t1 t2 => cvm_evidence_denote t2 p (cvm_evidence_denote t1 p ec)
  | abseq _ s t1 t2 => ssc (cvm_evidence_denote t1 p ((splitEvl s ec)))
                         (cvm_evidence_denote t2 p ((splitEvr s ec)))
  | abpar _ s t1 t2 => ssc (cvm_evidence_denote t1 p ((splitEvl s ec)))
                         (cvm_evidence_denote t2 p ((splitEvr s ec)))
  end.


(** * Assert an arbitrary (remote) CVM execution.  
      Uses uninterpreted functions for "simulated" CVM evidence and events. *)
Ltac do_assert_remote t e p i :=
  assert (
      build_cvm t
                      {| st_ev := e; st_trace := []; st_pl := p; st_evid := i|} =
      (Some tt,
       {| st_ev := cvm_evidence_core t p e;
                   st_trace := cvm_events_core t p (get_et e);
                               st_pl := p; st_evid :=  (i + event_id_span t)
       |})
    ) by (eapply build_cvm_external).


(**  * Event ID spans same for a term and its corresponding core term. *)
Lemma event_id_spans_same : forall t,
    event_id_span' t = event_id_span (copland_compile t).
(*Proof.
  intros.
  induction t; ff.
  -
    destruct a; ff; try tauto.
Qed.*)

Proof.
  intros.
  induction t; ff.
  destruct a; ff; try tauto.
Qed.

(** * Lemma:  CVM increases event IDs according to event_id_span' denotation. *)
Lemma cvm_spans: forall t pt e tr p i e' tr' p' i',
    term_to_coreP t pt ->
    build_cvmP
      pt
      {| st_ev := e;
         st_trace := tr;
         st_pl := p;
         st_evid := i |}
      (Some tt)
      {|
        st_ev := e';
        st_trace := tr';
        st_pl := p';
        st_evid := i'
      |} ->
    i' = i + event_id_span' t.
Proof.
  intros.
  generalizeEverythingElse t.
  induction t; intros;
    wrap_ccp_anno.
  -
    destruct a;
      try destruct a;
      ff; try tauto.
    +
      wrap_ccp_anno; ff.
    +
      wrap_ccp_anno; ff.
    +
      destruct s.
      ++
        wrap_ccp_anno; ff.
      ++
        wrap_ccp_anno; ff.
    +
      wrap_ccp_anno; ff.
    +
      wrap_ccp_anno; ff.
    +
      wrap_ccp_anno; ff.
    +
      wrap_ccp_anno; ff.
  -
    lia.
  -
    wrap_ccp_anno.
    assert (st_evid0 = i + event_id_span' t1).
    eapply IHt1.
    2: { eassumption. }
    econstructor; eauto.

    assert (i' = st_evid0 + event_id_span' t2).
    eapply IHt2.
    2: { eassumption. }
    econstructor; eauto.
    lia.
  -
    destruct s0; destruct s1.
    +
      wrap_ccp_anno.

      assert (st_evid1 = (i + 1) +  event_id_span' t1).
    eapply IHt1.
    2: { eassumption. }
    econstructor; eauto.

    assert (st_evid = st_evid1 + event_id_span' t2).
    eapply IHt2.
    2: { eassumption. }
    econstructor; eauto.
    subst.
    lia.
    +
      wrap_ccp_anno.
      assert (st_evid1 = (i + 1) +  event_id_span' t1).
    eapply IHt1.
    2: { eassumption. }
    econstructor; eauto.

    assert (st_evid = st_evid1 + event_id_span' t2).
    eapply IHt2.
    2: { eassumption. }
    econstructor; eauto.
    subst.
    lia.
    +
      wrap_ccp_anno.
      assert (st_evid1 = (i + 1) +  event_id_span' t1).
    eapply IHt1.
    2: { eassumption. }
    econstructor; eauto.

    assert (st_evid = st_evid1 + event_id_span' t2).
    eapply IHt2.
    2: { eassumption. }
    econstructor; eauto.
    subst.
    lia.
    +
      wrap_ccp_anno.
      assert (st_evid1 = (i + 1) +  event_id_span' t1).
    eapply IHt1.
    2: { eassumption. }
    econstructor; eauto.

    assert (st_evid = st_evid1 + event_id_span' t2).
    eapply IHt2.
    2: { eassumption. }
    econstructor; eauto.
    subst.
    lia.
  - (* bpar case *)
    destruct s0; destruct s1.
    +
      wrap_ccp_anno.

      assert (st_evid = (i + 1) +  event_id_span' t1).
    eapply IHt1.
    2: { eassumption. }
    econstructor; eauto.

    assert (event_id_span' t2 = event_id_span (copland_compile t2)).
    {
      eapply event_id_spans_same.
    }
    lia.
    +
      wrap_ccp_anno.

      assert (st_evid = (i + 1) +  event_id_span' t1).
    eapply IHt1.
    2: { eassumption. }
    econstructor; eauto.

    assert (event_id_span' t2 = event_id_span (copland_compile t2)).
    {
      eapply event_id_spans_same.
    }
    lia.
    +
            wrap_ccp_anno.

      assert (st_evid = (i + 1) +  event_id_span' t1).
    eapply IHt1.
    2: { eassumption. }
    econstructor; eauto.

    assert (event_id_span' t2 = event_id_span (copland_compile t2)).
    {
      eapply event_id_spans_same.
    }
    lia.
    +
      wrap_ccp_anno.

      assert (st_evid = (i + 1) +  event_id_span' t1).
    eapply IHt1.
    2: { eassumption. }
    econstructor; eauto.

    assert (event_id_span' t2 = event_id_span (copland_compile t2)).
    {
      eapply event_id_spans_same.
    }
    
    lia.
Qed.

(** * CVM event ID span same as annotated term range *)
Lemma span_cvm: forall atp t annt i j e e' tr tr' p p' i',
    build_cvmP
      atp
      {| st_ev := e;
         st_trace := tr;
         st_pl := p;
         st_evid := i |} 
      (Some tt)
      {| st_ev := e';
         st_trace := tr';
         st_pl := p';
         st_evid := i' |} ->
    
    term_to_coreP t atp -> 
    anno t i = (j, annt) ->
    j = i'.
Proof.
  intros.
  assert (j = i + event_id_span' t).
  {
    assert (j - i = event_id_span' t).
    {
      symmetry.
      eapply span_range.
      eauto.
    }
    rewrite <- H2.
    assert (j > i).
    {
      eapply anno_mono; eauto.
    }
    lia.
  }
  subst.
  symmetry.
  eapply cvm_spans; eauto.
Defined.

(** * Propositional version of span_cvm *)
Lemma anno_span_cvm: forall t pt annt i i' e e' p p' tr tr' st_evid1,
    annoP_indexed annt t i i' ->
    term_to_coreP t pt ->
    build_cvmP pt
                     {|
                       st_ev := e ;
                       st_trace := tr ;
                       st_pl := p;
                       st_evid := i
                     |} (Some tt)
                     {|
                       st_ev := e';
                       st_trace := tr';
                       st_pl := p';
                       st_evid := st_evid1
                     |} ->
    i' = st_evid1.
(*Proof.
  intros.
  invc H.
  eapply span_cvm; eauto.
Qed.*)
Proof. (*GPT 3.5-turbo-0613, score 50% -> 80% -> 100% 4 shots, modifer: use invc H1, and remove assertions *) 
  intros t pt annt i i' e e' p p' tr tr' st_evid1 H1 H2 H3.
  invc H1.
  eapply span_cvm in H3; eauto.
Qed.


Lemma wfec_firstn: forall e0 e1 e2,
    wf_ec (evc e0 e1) ->
    firstn (et_size e1) (e0 ++ e2) = e0.
(*Proof.
  intros.
  inv_wfec.
  jkjke'.
  eapply More_lists.firstn_append.
Defined.*)
Proof. (*GPT3.5-turbo-16K-0613, 3 shots, score 50% -> 75%->100%, modifer use eapply More_lists.firstn_append and rewrite <- H1 when possible*)
  intros e0 e1 e2 H.
  inv H. 
  rewrite <- H1.
  eapply More_lists.firstn_append.
Qed.

Ltac do_wfec_firstn :=
  match goal with
  | [H: context[(firstn (et_size ?e1) (?e0 ++ ?e2))],
        H2: wf_ec (evc ?e0 ?e1)

     |- _] =>
    
    assert_new_proof_by
      (firstn (et_size e1) (e0 ++ e2) = e0)
      ltac: (eapply wfec_firstn; apply H2)
  end.

Lemma wfec_skipn: forall e0 e1 e2,
    wf_ec (evc e0 e1) ->
    skipn (et_size e1) (e0 ++ e2) = e2.
(*Proof.
  intros.
  inv_wfec.
  jkjke'.
  eapply More_lists.skipn_append.
Defined.*)

Proof. (* GPT3.5-turbo-16k-0613, 1st shot score 100%, contex continous from above *)
  intros e0 e1 e2 H.
  inv H.
  rewrite <- H1.
  apply More_lists.skipn_append.
Qed.

Ltac do_wfec_skipn :=
  match goal with
  | [H: context[(skipn (et_size ?e1) (?e0 ++ ?e2))],
        H2: wf_ec (evc ?e0 ?e1)

     |- _] =>
    
    assert_new_proof_by
      (skipn (et_size e1) (e0 ++ e2) = e2)
      ltac: (eapply wfec_skipn; apply H2)
  end.

Ltac clear_skipn_firstn :=
  match goal with
  | [H: firstn _ _ = _,
        H2: skipn _ _ = _ |- _]
    => rewrite H in *; clear H;
      rewrite H2 in *; clear H2
  end.





(** * Axiom:  assume parallel CVM threads preserve well-formedness of EvC bundles *)
Axiom wf_ec_preserved_par: forall e l t2 p,
    wf_ec e ->
    wf_ec (parallel_vm_thread l t2 p e).

(** * Lemma:  CVM execution preserves well-formedness of EvC bundles 
      (Evidence Type of sufficient length for raw evidence). *)
Lemma wf_ec_preserved_by_cvm : forall e e' t1 tr tr' p p' i i',
    wf_ec e ->
        build_cvmP t1
                    {| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |}
                    (Some tt)
                    {| st_ev := e'; st_trace := tr'; st_pl := p'; st_evid := i' |} ->
    wf_ec (e').
Proof.
  intros.
  generalizeEverythingElse t1.
  induction t1; intros.
  -
    rewrite <- ccp_iff_cc in *.
    destruct a; (* asp *)
      try destruct a; (* asp params *)
      ff;
      inv_wfec;
      try (
          econstructor;
          ff;
          try tauto;
          try congruence).
    +
      destruct f.
      ++
        ff.
        econstructor.
        ff.
      ++
        ff.
        econstructor.
        ff.
      ++
        ff.
        econstructor.
        ff.
        (* 
        congruence. *)
      ++
        ff.
        econstructor.
        ff.
      ++
        ff.
        econstructor.
        ff.
        
        
  -
    wrap_ccp.

    eapply wf_ec_preserved_remote; eauto.

  -
    wrap_ccp.
    eauto.
  -
    wrap_ccp.

    (*

    do_wfec_split. *)

    find_apply_hyp_hyp.
    find_apply_hyp_hyp.
    econstructor.
    dd.
    inv_wfec.
    repeat jkjke'.
    eapply app_length.

  -
    wrap_ccp.

    (*
    
    do_wfec_split. *)

    find_apply_hyp_hyp.

      inv_wfec;
      ff;
      econstructor;
      dd;
      repeat jkjke'.

    erewrite app_length.

    assert (wf_ec (evc r0 e1)).
    {
      rewrite <- Heqe1.
      eapply wf_ec_preserved_par.
      econstructor; eassumption.
    }

    solve_by_inversion.
Qed.



Ltac do_wfec_preserved :=
  repeat
    match goal with
    | [(*H: well_formed_r ?t, *)
          H2: wf_ec ?stev,
              H3: build_cvmP ?t
                                   {| st_ev := ?stev; st_trace := _; st_pl := _; st_evid := _ |}
                                   (Some tt)
                                   {| st_ev := ?stev'; st_trace := _; st_pl := _; st_evid := _ |}
       |- _ ] =>
      assert_new_proof_by (wf_ec stev')
                          ltac:(eapply wf_ec_preserved_by_cvm; [(*apply H |*) apply H2 | apply H3])
                                 
    end.


Axiom ev_cvm_mtc: forall ct p e loc,
    parallel_vm_thread loc ct p mt_evc = parallel_vm_thread loc (lseqc (aspc CLEAR) ct) p e.


(** * Lemma:  Evidence Type denotation respects evidence reference semantics  *)
Lemma cvm_ev_denote_evtype: forall annt p e,
    (*annoP annt t -> *)
    et_fun (cvm_evidence_denote annt p e) = (aeval annt p (et_fun e)).
Proof.
  intros.
  generalizeEverythingElse annt.
  induction annt; intros.
  -
    dd.
    destruct a; dd;
      try eauto.
    +
      destruct f; ff.
      destruct s; ff.
      destruct s; ff.
  -
    dd.
    eauto.
  -
    dd.
    assert (et_fun (cvm_evidence_denote annt1 p e) = aeval annt1 p (et_fun e)) by eauto.
    repeat jkjke.
  -
    dd.
    jkjke.
    jkjke.
    destruct s; destruct s; destruct s0; eauto.
  -
    dd.
    jkjke.
    jkjke.
    destruct s; destruct s; destruct s0; eauto.
Defined.


(** * Lemma:  CVM execution always succeeds *)
Lemma exists_some_cc: forall t st,
    exists st',
      build_cvm t st = (Some tt, st').
Proof.
  intros.
  destruct (build_cvm t st) eqn:ee.
  do_asome.
  subst.
  eauto.
Defined.

Ltac do_exists_some_cc t st :=
    assert_new_proof_by
      (exists st', build_cvm t st = (Some tt, st') )
      ltac:(eapply exists_some_cc);
    destruct_conjs.



(** * Helper Lemma stating: CVM traces are "cumulative" (or monotonic).  
      Traces are only ever extended--prefixes are maintained. *)
Lemma st_trace_cumul'' : forall t m k e p v_full v_suffix o_suffix i,
    build_cvmP t
               {| st_ev := e; st_trace := m ++ k; st_pl := p; st_evid := i |}
               (Some tt) v_full ->
    
    build_cvmP t
                     {| st_ev := e; st_trace := k; st_pl := p; st_evid := i |}
                     o_suffix v_suffix ->

    st_trace v_full = m ++ st_trace v_suffix.
Proof.
  induction t; intros.
  -
    wrap_ccp.
    
    destruct a; (* asp *)
      try destruct a; (* asp params *)
      simpl;
      df;
      repeat rewrite app_assoc;
      reflexivity.
  -
    wrap_ccp.
    repeat rewrite app_assoc.
    reflexivity.

  - (* alseq case *)
    wrap_ccp_dohi.
     
    cumul_ih.
    dd.
    repeat do_st_trace.
    repeat find_rw_in_goal.
    eauto.

  - (* abseq case *)
    wrap_ccp_dohi.
    repeat rewrite <- app_assoc in *.
    cumul_ih.
    dd.
    cumul_ih.
    dd.
    rewrite app_assoc.
    eauto.
    
  - (* abpar case *)
    wrap_ccp_dohi.
    repeat rewrite <- app_assoc in *.
    cumul_ih.
    dd.
    repeat rewrite app_assoc.
    eauto.
Defined.



(** * Instance of st_trace_cumul'' where k=[] *)
Lemma st_trace_cumul' : forall t m e p v_full v_suffix o_suffix i,
    build_cvmP t
               {| st_ev := e; st_trace := m; st_pl := p; st_evid := i |}
               (Some tt) v_full ->
    
    build_cvmP t
                     {| st_ev := e; st_trace := []; st_pl := p; st_evid := i |}
                     o_suffix v_suffix ->

    st_trace v_full = m ++ st_trace v_suffix.
Proof.
  intros.
  eapply st_trace_cumul''; eauto.
  repeat rewrite app_nil_r.
  eauto.
Defined.


(** * Lemma stating: CVM traces are "cumulative" (or monotonic).  
      Traces are only ever extended--prefixes are maintained. 
      TODO:  rename to st_trace_cumul 
*) 
Lemma suffix_prop : forall t e e' tr tr' p p' i i',
    build_cvmP t
           {| st_ev := e;
              st_trace := tr;
              st_pl := p;
              st_evid := i |}
           (Some tt)
           {|
             st_ev := e';
             st_trace := tr';
             st_pl := p';
             st_evid := i' |} ->
    exists l, tr' = tr ++ l.
Proof.
  intros.

  do_exists_some_cc t {| st_ev := e; st_trace := []; st_pl := p; st_evid := i |}.
  wrap_ccp.
  (*

  rewrite ccp_iff_cc in *. *)

  repeat do_st_trace_assumps.
  repeat find_rw_in_goal.
  eexists.

  erewrite st_trace_cumul''.
  3: {
    eassumption.
  }
  simpl.
  tauto.
  rewrite app_nil_r.
  eassumption.
Defined.

Ltac do_suffix name :=
  match goal with
  | [H': build_cvmP ?t
         {| st_ev := _; st_trace := ?tr; st_pl := _; st_evid := _ |}
         (Some tt)
         {| st_ev := _; st_trace := ?tr'; st_pl := _; st_evid := _ |}
         (*H2: well_formed_r ?t*) |- _] =>
    assert_new_proof_as_by
      (exists l, tr' = tr ++ l)
      ltac:(eapply suffix_prop; [apply H'])
             name
  end.

(** * Structural Lemma:   Decomposes the CVM trace for the lseq phrase into the appending of the two traces
      computed by its subterms, where each subterm starts from the empty trace.

      Useful for leveraging induction hypotheses in the lseq case of induction that require empty traces in the 
      initial CVM state. *)
Lemma alseq_decomp : forall t1' t2' e e'' p p'' tr i i'',
    build_cvmP
      (lseqc t1' t2')
      {| st_ev := e;
         st_trace := [];
         st_pl := p;
         st_evid := i |}
      (Some tt)
      {| st_ev := e'';
         st_trace := tr;
         st_pl := p'';
         st_evid := i'' |} ->

    exists e' tr' p' i',
      build_cvmP
        t1'
        {| st_ev := e;
           st_trace := [];
           st_pl := p;
           st_evid := i |}
        (Some  tt)
        {| st_ev := e';
           st_trace := tr';
           st_pl := p';
           st_evid := i' |} /\
      exists tr'',
        build_cvmP
          t2'
          {| st_ev := e';
             st_trace := [];
             st_pl := p';
             st_evid := i' |}
          (Some tt)
          {| st_ev := e'';
             st_trace := tr'';
             st_pl := p'';
             st_evid := i'' |} /\
        tr = tr' ++ tr''.     
Proof.
  intros.
  wrap_ccp_dohi.
  
  eexists.
  eexists.
  eexists.
  eexists.

  split.
  +
    eassumption.
  +
    do_exists_some_cc t2' {| st_ev := st_ev0; st_trace := []; st_pl := st_pl0; st_evid := st_evid0 |}.
    vmsts.

    eexists.

    wrap_ccp_dohi.

    split.
    ++
      eassumption.
    ++
      repeat do_st_trace.
      repeat find_rw_in_goal.
      eapply st_trace_cumul'; 
        eassumption.
Defined.


(** Structural convenience lemma:  reconfigures CVM execution to use an empty initial trace *)
Lemma restl : forall t e e' x tr p p' i i',
    build_cvmP t
                     {| st_ev := e; st_trace := x; st_pl := p; st_evid := i|}
                     (Some tt)
                     {| st_ev := e'; st_trace := x ++ tr; st_pl := p'; st_evid := i' |} ->

    build_cvmP t
                     {| st_ev := e; st_trace := []; st_pl := p; st_evid := i |}
                     (Some tt)
                     {| st_ev := e'; st_trace := tr; st_pl := p'; st_evid := i' |}.
Proof.
  intros.

  do_exists_some_cc t  {| st_ev := e; st_trace := []; st_pl := p; st_evid := i |}.
  wrap_ccp_dohi.

  assert (st_trace = tr).
  {
    do_st_trace.
    rewrite H0; clear H0.
    assert (tr = st_trace).
    {
      assert (Cvm_St.st_trace {| st_ev := st_ev; st_trace := x ++ tr; st_pl := st_pl; st_evid := st_evid|} =
              x ++ Cvm_St.st_trace {| st_ev := st_ev; st_trace := st_trace; st_pl := st_pl; st_evid := st_evid |}).
      {
        eapply st_trace_cumul'; 
        eassumption.
      }
      simpl in *.
      eapply app_inv_head; eauto.
    }
    jkjke.
  }
  congruence.
Defined.

Ltac do_restl :=
  match goal with
  | [H: build_cvmP ?t
        {| st_ev := ?e; st_trace := ?tr; st_pl := ?p; st_evid := ?i |}
        (Some tt)
        {| st_ev := ?e'; st_trace := ?tr ++ ?x; st_pl := ?p'; st_evid := ?i' |}
        (*H2: well_formed_r ?t*) |- _] =>
    assert_new_proof_by
      (build_cvmP t
                        {| st_ev := e; st_trace := []; st_pl := p; st_evid := i|}
                        (Some tt)
                        {| st_ev := e'; st_trace := x; st_pl := p'; st_evid := i' |})
      ltac:(eapply restl; [apply H])
  end.




(** * Lemma:  evidence semantics same for annotated and un-annotated terms *)
Lemma eval_aeval': forall t1 p et,
    eval (unanno t1) p et = aeval t1 p et.
Proof.
  induction t1; intros;
    repeat ff;
    repeat jkjke.
Defined.







(** * Lemma:  parallel CVM threads preserve the reference Evidence Type semantics (eval). *)
Lemma par_evidence_r: forall l p bits bits' et et' t2,
    parallel_vm_thread l (copland_compile t2) p (evc bits et) = evc bits' et' ->
    et' = eval t2 p et.
Proof.
  intros.
  rewrite par_evidence in H.
  rewrite <- at_evidence in H.
  rewrite <- remote_Evidence_Type_Axiom with (bits := bits).
  rewrite H.
  simpl.
  tauto.
Qed.
         
(** * Axiom about "simulated" parallel semantics of CVM execution:
      Executing a "CLEAR" before a term is the same as executing that term with mt initial evidence.
      TODO:  can we use existing axioms to prove this? *)
Axiom par_evidence_clear: forall l p bits et t2,
    parallel_vm_thread l (lseqc (aspc CLEAR) t2) p (evc bits et) =
    parallel_vm_thread l t2 p mt_evc.

(** * Main Lemma:  CVM execution maintains the Evidence Type reference semantics (eval) for 
      its internal evidence bundle. *)
Lemma cvm_refines_lts_evidence' : forall t tr tr' bits bits' et et' p p' i i',
    build_cvmP (copland_compile t)
                     (mk_st (evc bits et) tr p i)
                     (Some tt)
                     (mk_st (evc bits' et') tr' p' i') ->
    et' = (Term_Defs.eval t p et).
Proof.
  intros.
  generalizeEverythingElse t.
  induction t; intros.
  
  - (* aasp case *)
    rewrite <- ccp_iff_cc in *.
    subst.
    destruct a;
      (try dd; eauto).
    +
      destruct s; dd.
      destruct f; dd; eauto.
      unfold mt_evc in *.
      ff.
      destruct f; dd; eauto.
      unfold mt_evc in *.
      ff.
      unfold mt_evc in *.
      ff.

      

  - (* at case *)
    rewrite <- ccp_iff_cc in *.
    dd.
    erewrite <- remote_Evidence_Type_Axiom.
    jkjke.

  - (* alseq case *)
    do_suffix blah.
    destruct_conjs.
    subst.

    edestruct alseq_decomp.
    eapply restl.
    eassumption.
    destruct_conjs.

    wrap_ccp.
    
    destruct x.
    repeat jkjke'.
    
  - (* abseq case *)

    (*
    do_suffix blah.
    do_suffix blah'. *)

    wrap_ccp.

    destruct s0; destruct s1; ff.
    +
      wrap_ccp.
      assert (e = eval t1 st_pl1 et) by eauto.

      assert (e0 = eval t2 st_pl1 et) by eauto.
      congruence.
    +
      wrap_ccp.
      assert (e = eval t1 st_pl1 et) by eauto.

      assert (e0 = eval t2 st_pl1 mt) by eauto.
      congruence.
    +
      wrap_ccp.
      assert (e = eval t1 st_pl1 mt) by eauto.

      assert (e0 = eval t2 st_pl1 et) by eauto.
      congruence.
    +
      wrap_ccp.
      assert (e = eval t1 st_pl1 mt) by eauto.

      assert (e0 = eval t2 st_pl1 mt) by eauto.
      congruence.
      
   - (* abpar case *)

    (*
    do_suffix blah.
    do_suffix blah'. *)

    wrap_ccp.

    destruct s0; destruct s1; ff.
    +
      wrap_ccp.
      assert (e = eval t1 p et) by eauto.

      assert (e0 = eval t2 p et).
      {
        eapply par_evidence_r.
        eassumption.
      }
      congruence.
      
    +
      wrap_ccp.
      assert (e = eval t1 p et) by eauto.

      assert (e0 = eval t2 p mt).
      {
        rewrite par_evidence_clear in Heqe0.

        eapply par_evidence_r.
        eassumption.
      }
      
      congruence.
    +
      wrap_ccp.
      assert (e = eval t1 p mt) by eauto.

      assert (e0 = eval t2 p et).
      {
        eapply par_evidence_r.
        eassumption.
      }
      congruence.
    +
      wrap_ccp.
      assert (e = eval t1 p mt) by eauto.

      assert (e0 = eval t2 p mt).
      {
        rewrite par_evidence_clear in Heqe0.

        eapply par_evidence_r.
        eassumption.
      }
      congruence.
Qed.

(** * Propositional version of CVM Evidence Type preservation. *)
Lemma cvm_refines_lts_evidence :
  forall t t' tr tr' bits bits' et et' p p' i i',
    term_to_coreP t t' ->
    build_cvmP t'
                     (mk_st (evc bits et) tr p i)
                     (Some tt)
                     (mk_st (evc bits' et') tr' p' i') ->
    et' = (Term_Defs.eval t p et).
Proof.
  intros.
  invc H.
  eapply cvm_refines_lts_evidence'.
  eauto.
Qed.






(*
TODO: try this lemma again after getting appraisal Lemmas settled 
*)


(** * Lemma:  relating reconstructed CVM EvC bundles via the EvidenceC evidence denotation. *)
Lemma cvm_raw_evidence_denote_fact :
  forall t annt t' tr tr' bits bits' et et' p p' i i' ec ec',
    build_cvmP t
                     (mk_st (evc bits et) tr p i)
                     (Some tt)
                     (mk_st (evc bits' et') tr' p' i') ->
    term_to_coreP t' t ->
    annoP_indexed annt t' i i' ->

    reconstruct_evP (evc bits et) ec ->
    reconstruct_evP (evc bits' et') ec' ->

    cvm_evidence_denote annt p ec = ec'.
Proof.
  intros.
  generalizeEverythingElse t'.
  induction t'; intros.
  - (* Base case: aasp *)
    wrap_ccp_anno.
    destruct a.
    + (* NULL *)
      wrap_ccp_anno.
      ff.
      invc H3.
      dd.
      reflexivity.
    + (* CPY *)
      wrap_ccp_anno.
      dd.
      eapply reconP_determ; eauto.

    + (* ASPC *)
      wrap_ccp_anno.
      ff.
      ++ (* COMP case *)
        wrap_ccp_anno.
        invc H3.
        ff.
        assert (bits = encodeEv ec).
        {
          symmetry.
          invc H2.
          eapply recon_encodeEv.
          econstructor.
          eassumption.
        }
        subst.

        assert (et_fun ec = et).
        {
          symmetry.
          eapply etfun_reconstruct.
          eassumption.
        }
        congruence.
      ++ (* COMP NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
      ++ (* ENCR ALL case *)
        wrap_ccp_anno.
        invc H3.
        ff.
        assert (bits = encodeEv ec).
        {
          symmetry.
          invc H2.
          eapply recon_encodeEv.
          econstructor.
          eassumption.
        }
        subst.

        assert (et_fun ec = et).
        {
          symmetry.
          eapply etfun_reconstruct.
          eassumption.
        }
        congruence.

      ++ (* ENCR NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
        
      ++ (* EXTD ALL case *)
        wrap_ccp_anno.
        invc H3.
        ff.
        invc H2.
        ff.
        jkjke'.
        ff.
        assert (bits = encodeEv ec).
        {
          symmetry.
          eapply recon_encodeEv.
          econstructor.
          eassumption.
        }
        subst.
        reflexivity.
      ++ (* EXTD NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
      ++ (* KILL ALL case *)
        wrap_ccp_anno.
        invc H3.
        ff.
      ++ (* KILL NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
             
      ++
        wrap_ccp_anno.
        invc H3.
        ff.
        assert (et_fun ec' = et').
        {
          symmetry.
          eapply etfun_reconstruct.
          econstructor.
          
        eassumption.
        }
        invc H2.
        unfold reconstruct_ev in *.
        congruence.
      ++
        wrap_ccp_anno.
        invc H3.
        ff.

    + (* SIG *)
      wrap_ccp.
      invc H3; invc H2.
      dd.
      assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        econstructor.
        eassumption.
      }

      rewrite recon_encodeEv with (bits:=bits) (et:=et).
      admit. (* stopped here congruence.*)
      econstructor; eassumption.
    + (* HSH *)
      wrap_ccp.
      invc H3; invc H2.
      dd.
      assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        econstructor.
        eassumption.
      }

      rewrite recon_encodeEv with (bits:=bits) (et:=et).
      congruence.
      econstructor; eassumption.
    + (* ENC *)
      wrap_ccp.
      invc H3; invc H2.
      dd.
      assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        econstructor.
        eassumption.
      }

      rewrite recon_encodeEv with (bits:=bits) (et:=et).
      congruence.
      econstructor; eassumption.

  - (* Recursive case: aatt *)
    wrap_ccp_anno.
    ff.
    wrap_ccp_anno.

    do_assert_remote (copland_compile t') (evc bits et) p (S i).

    assert (evc bits' et' = cvm_evidence_core (copland_compile t') p (evc bits et)). {
      rewrite at_evidence in *.
      unfold cvm_evidence in *.
      rewrite H5.
      tauto.
    }

    eapply IHt'.
    econstructor.
    rewrite <- H7 in H4.
    eassumption.
    econstructor; eauto.
    assert (n = (S i + event_id_span (copland_compile t'))).
    {
      wrap_ccp_anno.
      eapply anno_span_cvm.
      eassumption.
      2: { eassumption. }
      econstructor; eauto.
    }
    subst.
    eassumption.
    eassumption.
    eassumption.

  - (* Recursive case: alseq *)
    wrap_ccp_anno.
    ff.
    wrap_ccp_anno.
    ff.

    assert (n = st_evid0).
    {
      eapply anno_span_cvm.
      eassumption.
      2: { eassumption. }
      econstructor; eauto.
    }
    
    dd.

    destruct st_ev0.

    assert (wf_ec (evc bits et)).
    {
      eapply wfec_recon; eauto.
    }

    do_wfec_preserved.

    do_somerecons.
    
    assert ((cvm_evidence_denote a p ec) = H8).
    {
      eapply IHt'1.
      
      eassumption.
      econstructor; eauto.
      eassumption.

      eassumption.
      eassumption.
    }
    
    subst.
    eapply IHt'2.
    apply Heqp1.
    econstructor; eauto.
    eassumption.
    eauto.
    eauto.
Admitted.
    
(*Proof.
  intros.
  generalizeEverythingElse t'.
  induction t'; intros;
    inversion H1; subst; clear H1; simpl in *.

  - (* Case: aasp *)
    destruct a;
    wrap_ccp_anno;
    try (inversion H2; inversion H3; subst; reflexivity). 
    admit. admit. admit. admit. admit. admit.
    (*destruct s; destruct f; wrap_ccp_anno;
    try (inversion H2; inversion H3; subst; reflexivity).*)

  - (* Case: aatt *)
    wrap_ccp_anno.
    assert (evc bits' et' = cvm_evidence_core (copland_compile t') p (evc bits et)).
    {
      (*rewrite at_evidence*) admit. (*reflexivity.*)
    }
    subst.
    eapply IHt'.
    all: eauto. 
    admit. admit. admit.

  - (* Case: alseq *)
    wrap_ccp_anno.
    (*rewrite <- span_cvm with (t:=t'1) (annt:=a) (i:=i) (j:=st_evid0)
                              (e:=evc bits et) (e':=st_ev0) (tr:=tr) (tr':=st_trace0)
                              (p:=p) (p':=p) (i':=st_evid0).*) eauto; try econstructor; eauto.
    (*rewrite <- span_cvm with (t:=t2) (annt:=a0) (i:=st_evid0) (j:=i')
                              (e:=st_ev0) (e':=evc bits' et') (tr:=st_trace0) (tr':=tr')
                              (p:=p) (p':=p') (i':=i');*) eauto; try econstructor; eauto.
    eapply IHt'1; eauto.
    (*eapply IHt'2; eauto.*)
     admit. admit. admit. admit.
  - (* Case: abseq *)
    wrap_ccp_anno.
    assert (evc bits' et' = cvm_evidence_core (lseqc (aspc CLEAR) (copland_compile t'2)) p (evc bits et)).
    (*{
      rewrite events_cvm_to_core_mt. reflexivity.
    }*)
    subst.
    (*eapply IHt'1; eauto.*)
    (*eapply IHt'2; eauto.*)
    admit. admit.
  - (* Case: abpar *)
    wrap_ccp_anno.
    assert (evc bits' et' = parallel_vm_thread 0 (copland_compile t'2) p (evc bits et)).
    {
      rewrite par_evidence. eauto. admit. (* reflexivity.*)
    }
    subst.
    (*eapply IHt'1; eauto.
    eapply IHt'2; eauto.*)
    admit.
Admitted.*)

(*Proof.
  intros.
  generalizeEverythingElse t'.
  induction t'; intros.
  -
    wrap_ccp_anno.
    
    destruct a. (* wrap_ccp_anno. *)
    + (* NULL case *)
      wrap_ccp_anno.
      ff.
      invc H3.
      dd.
      tauto.   
    + (* CPY case *)
      wrap_ccp_anno.
      dd.
      eapply reconP_determ; eauto.

    + (* ASPC case *)
      wrap_ccp_anno.
      ff.
      ++ (* COMP case *)
        wrap_ccp_anno.
        invc H3.
        ff.
        assert (bits = encodeEv ec).
        {
          symmetry.
          invc H2.
          eapply recon_encodeEv.
          econstructor.
          eassumption.
        }
        subst.

        assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        eassumption.
      }
      congruence.
      ++ (* COMP NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
      ++ (* ENCR ALL case *)
        wrap_ccp_anno.
        invc H3.
        ff.
         assert (bits = encodeEv ec).
        {
          symmetry.
          invc H2.
          eapply recon_encodeEv.
          econstructor.
          eassumption.
        }
        subst.

        assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        eassumption.
      }
      congruence.

      ++ (* ENCR NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
        
      ++ (* EXTD ALL case *)
        wrap_ccp_anno.
        invc H3.
        ff.
        invc H2.
        ff.
        jkjke'.
        ff.
        assert (bits = encodeEv ec).
        {
          symmetry.
          eapply recon_encodeEv.
          econstructor.
          eassumption.
        }
        subst.
        tauto.
      ++ (* EXTD NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
      ++ (* KILL ALL case *)
        wrap_ccp_anno.
        invc H3.
        ff.
      ++ (* KILL NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
             
      ++
        wrap_ccp_anno.
        invc H3.
        ff.
        assert (et_fun ec' = et').
        {
          symmetry.
          eapply etfun_reconstruct.
          econstructor.
          
        eassumption.
        }
        invc H2.
        unfold reconstruct_ev in *.
        congruence.
      ++
        wrap_ccp_anno.
        invc H3.
        ff.

    +
      wrap_ccp.
      dd.
      invc H3; invc H2.
      dd.
      jkjke'.
      dd.
      (* Search (encodeEv _ = _). *)
      rewrite recon_encodeEv with (bits:=bits) (et:=et).
      tauto.
      econstructor; eassumption.

    +
      wrap_ccp.
      invc H3; invc H2.
      dd.
      assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        econstructor.
        eassumption.
      }

      rewrite recon_encodeEv  with (bits:=bits) (et:=et).
      congruence.
      econstructor; eassumption.
    +
      wrap_ccp.
      invc H3; invc H2.
      dd.
      assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        econstructor.
        eassumption.
      }

      rewrite recon_encodeEv  with (bits:=bits) (et:=et).
      congruence.
      econstructor; eassumption.
      

  -
    wrap_ccp_anno.
    ff.
    wrap_ccp_anno.

    do_assert_remote (copland_compile t') (evc bits et) p (S i).

    assert (evc bits' et' = cvm_evidence_core (copland_compile t') p (evc bits et)). {

      rewrite at_evidence in *.
      unfold cvm_evidence in *.
      rewrite H5.
      tauto.
    }

    eapply IHt'.
    econstructor.
    rewrite <- H7 in H4.
    eassumption.
    econstructor; eauto.
    assert (n = (S i + event_id_span (copland_compile t'))).
    {
      wrap_ccp_anno.
      eapply anno_span_cvm.
      eassumption.
      2: { eassumption. }
      econstructor; eauto.
    }
    subst.
    eassumption.
    eassumption.
    eassumption.

  - (* lseq case *)
    wrap_ccp_anno.
    ff.
    wrap_ccp_anno.
    ff.

    assert (n = st_evid0).
    {
      eapply anno_span_cvm.
      eassumption.
      2: { eassumption. }
      econstructor; eauto.
    }
    
    dd.

    destruct st_ev0.

    assert (wf_ec (evc bits et)).
    {
      eapply wfec_recon; eauto.
    }

    do_wfec_preserved.

    do_somerecons.
    
    assert ((cvm_evidence_denote a p ec) = H8).
    {
      eapply IHt'1.
      
      eassumption.
      econstructor; eauto.
      eassumption.

      eassumption.
      eassumption.
    }
    
    subst.
    eapply IHt'2.
    apply Heqp1.
    econstructor; eauto.
    eassumption.
    eauto.
    eauto.
    
  - (* bseq case *)
    wrap_ccp_anno;
      ff;
      wrap_ccp_anno.
    
    +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid1).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp2. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a st_pl1 ec = e1).
    {
      eapply IHt'1.
      apply Heqp2.
      econstructor; eauto.
      

      eassumption.
      eassumption.
      eassumption.
    }

     assert (cvm_evidence_denote a0 st_pl1 ec = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      eassumption.
      eassumption.
    }
    
      
    dd.
    congruence.
    +
            do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid1).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp2. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a st_pl1 ec = e1).
    {
      eapply IHt'1.
      apply Heqp2.
      econstructor; eauto.
      

      eassumption.
      eassumption.
      eassumption.
    }

     assert (cvm_evidence_denote a0 st_pl1 mtc = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      econstructor. ff.
      eassumption.
    }
    
      
    dd.
    congruence.


    +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec mt_evc).
      {
        econstructor.
        ff.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid1).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp8. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a st_pl1 mtc = e1).
    {
      eapply IHt'1.
      apply Heqp8.
      econstructor; eauto.
      

      eassumption.
      econstructor; eauto.
      eassumption.
    }

     assert (cvm_evidence_denote a0 st_pl1 ec = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      econstructor. ff.
      eassumption.
    }
    
      
    dd.
    congruence.
    


        +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec mt_evc).
      {
        econstructor.
        ff.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid1).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp9. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a st_pl1 mtc = e1).
    {
      eapply IHt'1.
      apply Heqp9.
      econstructor; eauto.
      

      eassumption.
      econstructor; eauto.
      eassumption.
    }

     assert (cvm_evidence_denote a0 st_pl1 mtc = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      econstructor. ff.
      eassumption.
    }
    
      
    dd.
    congruence.



  - (* bpar case *)
    wrap_ccp_anno;
      ff;
      wrap_ccp_anno.
    
    +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp2. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a p ec = e1).
    {
      eapply IHt'1.
      apply Heqp2.
      econstructor; eauto.
      

      eassumption.
      eassumption.
      eassumption.
    }

    do_assert_remote (copland_compile t'2) (evc bits et) p (st_evid).

    wrap_ccp_anno.

    rewrite par_evidence in *.

    unfold cvm_evidence in *.
    rewrite Heqe0 in *.

    assert (cvm_evidence_denote a0 p ec = e2).
    {
      eapply IHt'2.
      apply H9.
      econstructor; eauto.
      assert (n0 = st_evid + event_id_span (copland_compile t'2)).
      {
        eapply anno_span_cvm.
        apply Heqp1.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      eassumption.
      eassumption.
    }
    
      
    dd.
    congruence.


    +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp2. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a p ec = e1).
    {
      eapply IHt'1.
      apply Heqp2.
      econstructor; eauto.
      

      eassumption.
      eassumption.
      eassumption.
    }

     do_assert_remote (copland_compile t'2) mt_evc p (st_evid).

    wrap_ccp_anno.

    rewrite <- ev_cvm_mtc in *.

    rewrite par_evidence in *.

    unfold cvm_evidence in *.
    rewrite Heqe0 in *.


     assert (cvm_evidence_denote a0 p mtc = e2).
    {
      eapply IHt'2.
      apply H9.
      econstructor; eauto.
      assert (n0 = st_evid + event_id_span (copland_compile t'2)).
      {
        eapply anno_span_cvm.
        apply Heqp1.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      econstructor; eauto.
      eassumption.
    }
    
      
    dd.
    congruence.


    +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec mt_evc).
      {
        econstructor.
        ff.
      }

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid).
      {
        eapply anno_span_cvm.
        apply Heqp0.
        2: { 
             apply Heqp3. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a p mtc = e1).
    {
      eapply IHt'1.
      apply Heqp3.
      econstructor; eauto.
      

      eassumption.
      econstructor; eauto.
      eassumption.
    }

     do_assert_remote (copland_compile t'2) (evc bits et) p (st_evid).

    wrap_ccp_anno.

    rewrite par_evidence in *.

    unfold cvm_evidence in *.
    rewrite Heqe0 in *.


     assert (cvm_evidence_denote a0 p ec = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid + event_id_span (copland_compile t'2)).
      {
        eapply anno_span_cvm.
        apply Heqp1.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      eassumption.
      eassumption.
    }
    
      
    dd.
    congruence.



        +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec mt_evc).
      {
        econstructor.
        ff.
      }

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid).
      {
        eapply anno_span_cvm.
        apply Heqp0.
        2: { 
             apply Heqp3. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a p mtc = e1).
    {
      eapply IHt'1.
      apply Heqp3.
      econstructor; eauto.
      

      eassumption.
      econstructor; eauto.
      eassumption.
    }

     do_assert_remote (copland_compile t'2) mt_evc p (st_evid).

    wrap_ccp_anno.

    rewrite <- ev_cvm_mtc in *.

    rewrite par_evidence in *.

    unfold cvm_evidence in *.
    rewrite Heqe0 in *.


     assert (cvm_evidence_denote a0 p mtc = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid + event_id_span (copland_compile t'2)).
      {
        eapply anno_span_cvm.
        apply Heqp1.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      econstructor; eauto.
      eassumption.
    }
    
      
    dd.
    congruence.
Qed.


Lemma cvm_raw_evidence_denote_fact_eval :
  forall t annt t' tr tr' bits bits' et et' p p' i i' ec ec',
    build_cvmP t
                     (mk_st (evc bits et) tr p i)
                     (Some tt)
                     (mk_st (evc bits' et') tr' p' i') ->
    term_to_coreP t' t ->
    annoP_indexed annt t' i i' ->

    reconstruct_evP (evc bits et) ec ->
    reconstruct_evP (evc bits' (eval t' p et)) ec' ->

    cvm_evidence_denote annt p ec = ec'.
Proof.
intros.
  assert (et' = eval t' p et) by (eapply cvm_refines_lts_evidence; eauto).
  eapply cvm_raw_evidence_denote_fact; eauto.
  congruence.
Qed.
(*Proof.
  intros.
  assert (et' = eval t' p et).
  {
    eapply cvm_refines_lts_evidence.
    eassumption.
    eassumption.
  }
  eapply cvm_raw_evidence_denote_fact; eauto.
  congruence.
Qed.*)
  




































(** BEGIN Deprecated parallel annotated term stuff *)

(*
Lemma anno_parP_redo: forall t pt loc loc',
    anno_par_list' t loc = Some (loc', pt) ->
    anno_parP pt t.
Proof.
  intros.
  econstructor.
  eexists.
  jkjke.
Defined.

(*
Lemma anno_parPloc_redo: forall t pt loc loc',
    anno_par t loc = (loc', pt) ->
    anno_parPloc pt t loc.
Proof.
  intros.
  econstructor.
  jkjke.
Defined.
 *)
Lemma anno_parPloc_redo: forall t pt loc loc',
    anno_par_list' t loc = Some (loc', pt) ->
    anno_parPloc pt t loc.
Proof.
  intros.
  econstructor.
  jkjke.
Defined.

 *)

(*

Ltac do_annopar_redo :=
  match goal with
  | [H: anno_par ?t ?loc = (_,?pt)
     |- _ ] =>
    eapply anno_parP_redo in H
  end.

Ltac do_annopar_loc_redo :=
  match goal with
  | [H: anno_par ?t ?loc = (_,?pt)
     |- _ ] =>
    eapply anno_parPloc_redo in H
  end.
 *)


(*

Ltac do_annopar_redo :=
  match goal with
  | [H: anno_par_list' ?t ?loc = Some (_,?pt)
     |- _ ] =>
    eapply anno_parP_redo in H
  end.

Ltac do_annopar_loc_redo :=
  match goal with
  | [H: anno_par_list' ?t ?loc = (_,?pt)
     |- _ ] =>
    eapply anno_parPloc_redo in H
  end.



Ltac inv_annoparP :=
  match goal with
  | [H: anno_parP _ _ (* ?t (?c _) *)
     |- _ ] =>
    inversion H; subst
  end;
  destruct_conjs.

Ltac inv_annoparPloc :=
  match goal with
  | [H: anno_parPloc _ _ _(*?t (?c _) _ *)
     |- _ ] =>
    inversion H; subst
  end;
  destruct_conjs.
 *)


(*
Ltac wrap_annopar :=
  inv_annoparP;
  dd;
  repeat do_annopar_redo.

Ltac wrap_annoparloc :=
  inv_annoparPloc;
  dd;
  repeat do_annopar_loc_redo.
 *)


(** END Deprecated parallel annotated term stuff *)
(*
Definition of the CVM Monad + monadic helper functions.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import Term_Defs Term ConcreteEvidence Axioms_Io Evidence_Bundlers Defs.
Require Import StructTactics.

Require Import Coq.Program.Tactics Lia.

Require Import List.
Import ListNotations.

Require Export Cvm_St StMonad_Coq IO_Stubs.


(** * CVM monadic primitive operations *)

Definition put_ev (e:EvC) : CVM unit :=
  st <- get ;;
     let tr' := st_trace st in
     let p' := st_pl st in
     let i := st_evid st in
     put (mk_st e tr' p' i).

Definition put_pl (p:Plc) : CVM unit :=
  st <- get ;;
     let tr' := st_trace st in
     let e' := st_ev st in
     let i := st_evid st in
     put (mk_st e' tr' p i).

Definition get_ev : CVM EvC :=
  st <- get ;;
  ret (st_ev st).

Definition get_pl : CVM Plc :=
  st <- get ;;
  ret (st_pl st).

Definition inc_id : CVM Event_ID :=
  st <- get ;;
    let tr' := st_trace st in
    let e' := st_ev st in
    let p' := st_pl st in
    let i := st_evid st in
    put (mk_st e' tr' p' (Nat.add i (S O))) ;;
    ret i.
  

Definition modify_evm (f:EvC -> EvC) : CVM unit :=
  st <- get ;;
  let '{| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |} := st in
  put (mk_st (f e) tr p i).

Definition add_trace (tr':list Ev) : cvm_st -> cvm_st :=
  fun '{| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |} =>
    mk_st e (tr ++ tr') p i.

Definition add_tracem (tr:list Ev) : CVM unit :=
  modify (add_trace tr).

(* TODO: consider removing split/join events from reference semantics.
         Would make this (no-op) helper unecessary. *)
Definition split_ev : CVM unit :=
  p <- get_pl ;;
  i <- inc_id ;;
  add_tracem [Term_Defs.split i p].


(** * Partially-symbolic implementations of IO operations *)

(* Generates a new event ID and adds a measurement event with that ID to the 
   CVM internal trace.  Returns the new Event_ID (used to represent raw 
   evidence, relevant for appraisal verification).  *)
Definition tag_ASP (params :ASP_PARAMS) (mpl:Plc) (e:EvC) : CVM Event_ID :=
  x <- inc_id ;;
  add_tracem [umeas x mpl params (get_et e)] ;;
  ret x.

(* Helper function that builds a new internal evidence bundle based on 
   the evidence extension parameter of an ASP term. *)
Definition fwd_asp (fwd:FWD) (bs:BS) (e:EvC) (p:Plc) (ps:ASP_PARAMS): EvC :=
  match fwd with
  | COMP => cons_hsh bs e p ps
  | EXTD => cons_gg bs e p ps
  | ENCR => cons_enc bs e p ps
  | KILL => mt_evc
  | KEEP => e
  end.

(* Simulates invoking an arbitrary ASP.  Tags the event, builds and returns 
   the new evidence bundle. *)
Definition invoke_ASP (fwd:FWD) (params:ASP_PARAMS) : CVM EvC :=
  e <- get_ev ;;
  p <- get_pl ;;
  x <- tag_ASP params p e ;;
  bs <- do_asp' params (get_bits e) p x ;;
  ret (fwd_asp fwd bs e p params).

Definition copyEv : CVM EvC :=
  p <- get_pl ;;
  x <- inc_id ;;
  add_tracem [copy x p] ;;
  get_ev.

Definition nullEv : CVM EvC :=
  p <- get_pl ;;
  x <- inc_id ;;
  add_tracem [null x p] ;;
  ret mt_evc.

Definition clearEv : unit -> CVM EvC :=
  fun _ => ret mt_evc.

(* Helper that interprets primitive core terms in the CVM.  *)
Definition do_prim (a:ASP_Core) : CVM EvC :=
  match a with
  | NULLC => nullEv
  | CLEAR => clearEv tt
  | CPYC => copyEv
  | ASPCC fwd params => invoke_ASP fwd params
  end.


(* event_id_span functions were HERE *)


(* Monadic helper function to simulate a span of remote event IDs 
   corresponding to the size of a Term *)
Definition inc_remote_event_ids (t:Term) : CVM unit :=
  st <- get ;;
    let tr' := st_trace st in
    let e' := st_ev st in
    let p' := st_pl st in
    let i := st_evid st in
    let new_i := Nat.add i (event_id_span' t) in
    put (mk_st e' tr' p' new_i).

(* Monadic helper function to simulate a span of parallel event IDs 
   corresponding to the size of a Core_Term *)
Definition inc_par_event_ids (t:Core_Term) : CVM unit :=
  st <- get ;;
    let tr' := st_trace st in
    let e' := st_ev st in
    let p' := st_pl st in
    let i := st_evid st in
    let new_i := Nat.add i (event_id_span t) in
    put (mk_st e' tr' p' new_i).
  
(* Primitive monadic communication primitives 
   (some rely on Admitted IO Stubs). *)

Definition tag_REQ (t:Term) (p:Plc) (q:Plc) (e:EvC) : CVM unit :=
  reqi <- inc_id ;;
  add_tracem [req reqi p q t (get_et e)].

Definition tag_RPY (p:Plc) (q:Plc) (e:EvC) : CVM unit :=
  rpyi <- inc_id ;;
  add_tracem [rpy rpyi p q (get_et e)].

Definition remote_session (t:Term) (p:Plc) (q:Plc) (e:EvC) : CVM EvC :=
  tag_REQ t p q e ;;
  e' <- doRemote_session' t q e ;;
  add_tracem (cvm_events t q (get_et e)) ;;
  inc_remote_event_ids t ;;
  ret e'.

Definition doRemote (t:Term) (q:Plc) (e:EvC) : CVM EvC :=
  p <- get_pl ;;
  e' <- remote_session t p q e ;;
  tag_RPY p q e' ;;
  ret e'.

Definition join_seq (e1:EvC) (e2:EvC): CVM unit :=
  p <- get_pl ;;
  n <- inc_id ;;
  put_ev (ss_cons e1 e2) ;;
  add_tracem [join n p].

(* Primitive monadic parallel CVM thread primitives 
   (some rely on Admitted IO Stubs). *)

Definition start_par_thread (loc:Loc) (t:Core_Term) (e:EvC) : CVM unit :=
  p <- get_pl ;;
  do_start_par_thread loc t (get_bits e) ;;
  add_tracem [cvm_thread_start loc p t (get_et e)].

Definition wait_par_thread (loc:Loc) (t:Core_Term) (e:EvC) : CVM EvC :=
  p <- get_pl ;;
  e' <- do_wait_par_thread loc t p e ;;
  add_tracem [cvm_thread_end loc] ;;
  inc_par_event_ids t ;;
  ret e'.
   
Ltac monad_unfold :=
  repeat unfold
  execSt,  
  do_prim,
  invoke_ASP,
  clearEv,
  copyEv,
  
  doRemote,

  get_ev,
  get_pl,
  add_tracem,
  modify_evm,
  add_trace,
  failm,
  get,
  when,
  put,
  nop,
  modify,
  bind,
  ret in * ;
  simpl in * .

(* Grouping together some common hypothesis normalizations.  Inverting pairs of
   Some values, cvm_st equivalences, etc. *)
Ltac pairs :=
  simpl in *;
  vmsts;
  repeat
    match goal with
    | [H: (Some _, _) =
          (Some _, _) |- _ ] => invc H; monad_unfold
                                                          
    | [H: {| st_ev := _; st_trace := _; st_pl := _(*; st_store := _*); st_evid := _ |} =
          {| st_ev := _; st_trace := _; st_pl := _ (*; st_store := _*); st_evid := _ |} |- _ ] =>
      invc H; monad_unfold
    end; destruct_conjs; monad_unfold.
(** Abstract definitions of IO Stub signatures.  The functions with monadic 
    return types (i.e. do_asp') can be replaced by concrete monadic functions
    in the target language upon extraction.  Alternatively,
    if the target language does not have built-in monadic support, one can
    instantiate the non-monadic versions of the stubs instead (i.e. do_asp).

    The non-monadic stubs (i.e. do_asp) remain abstract (Admitted) in Coq 
    because they are either too low-level to reason about, or require external 
    IO capabilities not modeled first-class in our spec.  The abstract binary
    and evidence value results support specification of correctness properties 
    for Appraisal (see usage of do_asp in appEvent_EvidenceC of 
    Appraisal_Defs.v).        
 *)

Require Import Term_Defs ConcreteEvidence StMonad_Coq IO_Type.

(** * Stub to encode a sequence of BS values to a single BS value.
      Real implmenetation will depend on the instantition of BS *)
Definition encodeEvRaw(e:RawEv): BS.
Admitted.

(** * Stub for invoking external ASP procedures.  
      Extracted code should not need to use the Plc or Event_ID parameters 
      (those can be erased upon extraction). *)
Definition do_asp (params :ASP_PARAMS) (e:RawEv) (mpl:Plc) (x:Event_ID) : BS.
Admitted.

(** * Stub for completing a remote communication session with an external AM. *)
Definition doRemote_session (t:Term) (pTo:Plc) (e:EvC) : EvC.
Admitted.

(** * Stub to simulate evidence collected by a parallel CVM instance *)
Definition parallel_vm_thread (l:Loc) (t:Core_Term) (p:Plc) (e:EvC) : EvC.
Admitted.


(** * Stub for a top-level request from a remote client AM  *)
Definition am_sendReq (t:Term) (pFrom:Plc) (pTo:Plc) (authTok:ReqAuthTok) (e:RawEv) : RawEv.
Admitted.

Definition do_asp' (params :ASP_PARAMS) (e:RawEv) (mpl:Plc) (x:Event_ID) : IO BS :=
  ret (do_asp params e mpl x).

Definition doRemote_session' (t:Term) (pTo:Plc) (e:EvC) : IO EvC :=
  ret (doRemote_session t pTo e).

Definition do_start_par_thread (loc:Loc) (t:Core_Term) (e:RawEv) : IO unit :=
  ret tt.

Definition do_wait_par_thread (loc:Loc) (t:Core_Term) (p:Plc) (e:EvC) : IO EvC :=
  ret (parallel_vm_thread loc t p e).

Definition requester_bound (t:Term) (fromPl:Plc) (authTok:ReqAuthTok) : bool.
Admitted.

Definition appraise_auth_tok (res:AppResultC) : bool.
Admitted.
(** The abstract IO type.  For smoother extraction to Haskell *)

Require Import Cvm_St.


Definition IO := CVM.
(*
Record representing the CVM Monad state structure.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import ConcreteEvidence StMonad_Coq AbstractedTypes.
Require Import List.
Import ListNotations.

(** CVM monad state structure.

    st_ev - Evidence bundle.  Holds raw evidence sequence along with its 
            Evidence Type.
    st_trace - Event trace accumulated by the CVM (relevant only during 
               verification)
    st_pl - Current "executing place".
    st_evid - Monotonic event ID counter.  Incremented after each 
              attestation-relevant event/invocation.
 *)
Record cvm_st : Type := mk_st
                          {st_ev:EvC ;
                           st_trace:list Ev ;
                           st_pl:Plc;
                           st_evid:Event_ID}.

Definition empty_vmst := mk_st (evc [] mt) [] min_id_type 0.

(** CVM monad -- simple instantiation of the general St monad with cvm_st *)
Definition CVM := St cvm_st.

(* Look for cvm_st hyps and destruct them *)
Ltac vmsts :=
  simpl in *;
  repeat
    match goal with
    | [H: cvm_st |- _] => destruct H
    end.

(* Same as vmsts, but without preceding simplification (simpl). *)
Ltac amsts :=
  repeat match goal with
         | H:cvm_st |- _ => destruct H
         end.
Require Import EqClass.

Definition ID_Type : Set. Admitted.

Global Instance Eq_Class_ID_Type : EqClass ID_Type. Admitted.

Definition min_id_type : ID_Type. Admitted.(*
Generic Typeclass for equality, plus some instances.

Author:  Adam Petz, ampetz@ku.edu
 *)

Require Import StructTactics.

Require Import Coq.Arith.EqNat.

Class EqClass (A : Type) :=
  { eqb : A -> A -> bool ;
    eqb_leibniz : forall x y, eqb x y = true <-> x = y }.

Theorem EqClass_impl_DecEq: forall (A : Type) `{H : EqClass A},
    forall (x y : A), {x = y} + {x <> y}.
Proof.
  intros.
  destruct (eqb x y) eqn:E.
  - left; eapply eqb_leibniz; eauto.
  - right; erewrite <- eqb_leibniz; intros HC; congruence.
Qed.

Fixpoint general_list_eq_class_eqb {A : Type} `{H : EqClass A} (l1 l2 : list A) : bool :=
  match l1, l2 with
  | nil, nil => true
  | cons h1 t1, cons h2 t2 => andb (eqb h1 h2) (general_list_eq_class_eqb t1 t2)
  | _, _ => false
  end.

Theorem general_list_eqb_leibniz : forall {A : Type} `{H : EqClass A},
  forall (a1 a2 : list A), general_list_eq_class_eqb a1 a2 = true <-> a1 = a2.
Proof.
  induction a1; destruct a2; split; intros; simpl in *; eauto; try congruence.
  - eapply Bool.andb_true_iff in H0. destruct H0.
    erewrite eqb_leibniz in H0; subst. 
    rewrite IHa1 in H1; subst; eauto.
  - inv H0.
    eapply Bool.andb_true_iff; split; eauto.
    * eapply eqb_leibniz; eauto.
    * erewrite IHa1; eauto.
Qed.

Global Instance EqClass_extends_to_list (A : Type) `{H : EqClass A} : EqClass (list A) := {
  eqb := general_list_eq_class_eqb ;
  eqb_leibniz := general_list_eqb_leibniz
}.

Global Instance nat_EqClass : EqClass nat :=
  { eqb:= PeanoNat.Nat.eqb;
    eqb_leibniz := PeanoNat.Nat.eqb_eq }.

Definition eqbPair{A B:Type}`{H:EqClass A}`{H':EqClass B} (p1:A*B) (p2:A*B) : bool :=
  match (p1,p2) with
  | ((a1,b1), (a2,b2)) => andb (eqb a1 a2) (eqb b1 b2)
  end.

Lemma beq_pair_true{A B:Type}`{H:EqClass A}`{H':EqClass B} : forall (p1 p2:(A*B)),
    eqbPair p1 p2 = true -> p1 = p2.
Proof.
  intros.
  unfold eqbPair in *.
  repeat break_let.
  assert (a = a0).
  {
    assert (eqb a a0 = true).
    {
      destruct (eqb a a0); try solve_by_inversion.
    }
    eapply eqb_leibniz; eauto.
  }
  
  assert (b = b0).
  {
        assert (eqb b b0 = true).
        {
          destruct (eqb b b0); try reflexivity.
          cbv in *.
          repeat break_let.
          break_if; solve_by_inversion.     
        }
    eapply eqb_leibniz; eauto.
  }
  subst.
  reflexivity.
Defined.

                                                             

(*
#[global]
Instance pair_EqClass{A B:Type}`{H:EqClass A}`{H':EqClass B} : EqClass (A*B) :=
  { eqb:= eqbPair;
    eqb_leibniz := beq_pair_true }.
*)
(* Local copy of structural tactics library from:  https://github.com/uwplse/StructTact *)


(** [subst_max] performs as many [subst] as possible, clearing all
    trivial equalities from the context. *)
Ltac subst_max :=
  repeat match goal with
           | [ H : ?X = _ |- _ ]  => subst X
           | [H : _ = ?X |- _] => subst X
         end.

(** The Coq [inversion] tries to preserve your context by only adding
    new equalities, and keeping the inverted hypothesis.  Often, you
    want the resulting equalities to be substituted everywhere.  [inv]
    performs this post-substitution.  Often, you don't need the
    original hypothesis anymore.  [invc] extends [inv] and removes the
    inverted hypothesis.  Sometimes, you also want to perform
    post-simplification.  [invcs] extends [invc] and tries to simplify
    what it can. *)
Ltac inv H := inversion H; subst_max.
Ltac invc H := inv H; clear H.
Ltac invcs H := invc H; simpl in *.

(** [inv_prop] finds the first hypothesis including the term [P] and uses [inv]
    to invert it. *)
Ltac inv_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    inv H
  end.

(** [inv_prop] finds the first hypothesis including the term [P] and uses [invc]
    to invert it. *)
Ltac invc_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invc H
  end.

(** [inv_prop] finds the first hypothesis including the term [P] and uses
    [invcs] to invert it. *)
Ltac invcs_prop P :=
  match goal with
  | [ H : context[P] |- _] =>
    invcs H
  end.

(** [break_if] finds instances of [if _ then _ else _] in your goal or
    context, and destructs the discriminee, while retaining the
    information about the discriminee's value leading to the branch
    being taken. *)
Ltac break_if :=
  match goal with
    | [ |- context [ if ?X then _ else _ ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
    | [ H : context [ if ?X then _ else _ ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

Ltac break_if' :=
  match goal with
    | [ |- context [ if ?X then _ else _ ] ] =>
      match type of X with
        (*| sumbool _ _ => destruct X*)
        | _ => destruct X eqn:?
      end
    | [ H : context [ if ?X then _ else _ ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

(** [break_match_hyp] looks for a [match] construct in some
    hypothesis, and destructs the discriminee, while retaining the
    information about the discriminee's value leading to the branch
    being taken. *)
Ltac break_match_hyp :=
  match goal with
    | [ H : context [ match ?X with _ => _ end ] |- _] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

(** [break_match_goal] looks for a [match] construct in your goal, and
    destructs the discriminee, while retaining the information about
    the discriminee's value leading to the branch being taken. *)
Ltac break_match_goal :=
  match goal with
    | [ |- context [ match ?X with _ => _ end ] ] =>
      match type of X with
        | sumbool _ _ => destruct X
        | _ => destruct X eqn:?
      end
  end.

(** [break_match] breaks a match, either in a hypothesis or in your
    goal. *)
Ltac break_match := break_match_goal || break_match_hyp.

(** [break_inner_match' t] tries to destruct the innermost [match] it
    find in [t]. *)
Ltac break_inner_match' t :=
 match t with
   | context[match ?X with _ => _ end] =>
     break_inner_match' X || destruct X eqn:?
   | _ => destruct t eqn:?
 end.

(** [break_inner_match_goal] tries to destruct the innermost [match] it
    find in your goal. *)
Ltac break_inner_match_goal :=
 match goal with
   | [ |- context[match ?X with _ => _ end] ] =>
     break_inner_match' X
 end.

(** [break_inner_match_hyp] tries to destruct the innermost [match] it
    find in a hypothesis. *)
Ltac break_inner_match_hyp :=
 match goal with
   | [ H : context[match ?X with _ => _ end] |- _ ] =>
     break_inner_match' X
 end.

(** [break_inner_match] tries to destruct the innermost [match] it
    find in your goal or a hypothesis. *)
Ltac break_inner_match := break_inner_match_goal || break_inner_match_hyp.

(** [break_exists] destructs an [exists] in your context. *)
Ltac break_exists :=
  repeat match goal with
           | [H : exists _, _ |- _ ] => destruct H
         end.

(** [break_exists_exists] destructs an [exists] in your context, and uses
    the witness found as witness for your current goal. *)
Ltac break_exists_exists :=
  repeat match goal with
           | H:exists _, _ |- _ =>
             let x := fresh "x" in
             destruct H as [x]; exists x
         end.

(** [break_and] destructs all conjunctions in context. *)
Ltac break_and :=
  repeat match goal with
           | [H : _ /\ _ |- _ ] => destruct H
         end.

(** [break_and_goal] splits a conjunctive goal into one goal per
    conjunct.  In simpler terms, it splits a goal of the shape [G1 /\
    ... /\ Gn] into [n] goals [G1], ..., [Gn]. *)
Ltac break_and_goal :=
    repeat match goal with
             | [ |- _ /\ _ ] => split
           end.

(** [solve_by_inverison' tac] succeeds if it can solve your goal by
    inverting a hypothesis and then running [tac]. *)
Ltac solve_by_inversion' tac :=
  match goal with
    | [H : _ |- _] => solve [inv H; tac]
  end.

(** [solve_by_inverison] succeeds if it can solve your goal by
    inverting a hypothesis and then running [auto]. *)
Ltac solve_by_inversion := solve_by_inversion' auto.

(** TODO: document this. *)
Ltac apply_fun f H:=
  match type of H with
    | ?X = ?Y => assert (f X = f Y)
  end.

(** [conclude H tac] assumes [H] is of the form [A -> B] and
    specializes it into [B] if it successfully proves [A] using
    [tac]. *)
Ltac conclude H tac :=
  (let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H' by (tac)
   end; specialize (H H'); clear H').

(** [concludes] specializes all implication hypotheses if it can prove
    their premise using [auto]. *)
Ltac concludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H auto
  end.

(** [forward H] performs forward reasoning in hypothesis [H] of the
    shape [A -> B] by asserting [A] to be proven.  You can
    subsequently call [concludes] to specialize [H] to [B]. *)
Ltac forward H :=
  let H' := fresh in
   match type of H with
     | ?P -> _ => assert P as H'
   end.

(** [forwards] performs forward reasoning in all hypotheses. *)
Ltac forwards :=
  match goal with
    | [ H : ?P -> _ |- _ ] => forward H
  end.

(** [find_elim_prop] finds a hypothesis that includes [P] and eliminates it with
    the built-in [elim] tactic. *)
Ltac find_elim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    elim H
  end.

(** [find_elim_prop] finds a hypothesis that includes [P] and eliminates it with
    the built-in [eelim] tactic. *)
Ltac find_eelim_prop P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eelim H
  end.

(** [find_contradiction] solves a goal if two equalities are
    incompatible. *)
Ltac find_contradiction :=
  match goal with
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'; solve_by_inversion
  end.

(** [find_rewrite] performs a [rewrite] with some hypothesis in some
    other hypothesis. *)
Ltac find_rewrite :=
  match goal with
    | [ H : ?X _ _ _ _ = _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite H in H'
    | [ H : ?X = _, H' : ?X = _ |- _ ] => rewrite H in H'
    | [ H : ?X = _, H' : context [ ?X ] |- _ ] => rewrite H in H'
    | [ H : ?X = _ |- context [ ?X ] ] => rewrite H
  end.

(** [find_rewrite_lem lem] rewrites with [lem] in some hypothesis. *)
Ltac find_rewrite_lem lem :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H; [idtac]
  end.

(** [find_rewrite_lem_by lem t] rewrites with [lem] in some
    hypothesis, discharging the generated obligations with [t]. *)
Ltac find_rewrite_lem_by lem t :=
  match goal with
    | [ H : _ |- _ ] =>
      rewrite lem in H by t
  end.

(** [find_erewrite_lem_by lem] erewrites with [lem] in some hypothesis
    if it can discharge the obligations with [eauto]. *)
Ltac find_erewrite_lem lem :=
  match goal with
    | [ H : _ |- _] => erewrite lem in H by eauto
  end.

(** [find_reverse_rewrite] performs a [rewrite <-] with some hypothesis in some
    other hypothesis. *)
Ltac find_reverse_rewrite :=
  match goal with
    | [ H : _ = ?X _ _ _ _, H' : ?X _ _ _ _ = _ |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X, H' : context [ ?X ] |- _ ] => rewrite <- H in H'
    | [ H : _ = ?X |- context [ ?X ] ] => rewrite <- H
  end.

(** [find_inversion] find a symmetric equality and performs [invc] on it. *)
Ltac find_inversion :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => invc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => invc H
    | [ H : ?X _ = ?X _ |- _ ] => invc H
  end.

(** [prove_eq] derives equalities of arguments from an equality of
    constructed values. *)
Ltac prove_eq :=
  match goal with
    | [ H : ?X ?x1 ?x2 ?x3 = ?X ?y1 ?y2 ?y3 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        assert (x3 = y3) by congruence;
        clear H
    | [ H : ?X ?x1 ?x2 = ?X ?y1 ?y2 |- _ ] =>
      assert (x1 = y1) by congruence;
        assert (x2 = y2) by congruence;
        clear H
    | [ H : ?X ?x1 = ?X ?y1 |- _ ] =>
      assert (x1 = y1) by congruence;
        clear H
  end.

(** [tuple_inversion] inverses an equality of tuple into equalities for
    each component. *)
Ltac tuple_inversion :=
  match goal with
    | [ H : (_, _, _, _) = (_, _, _, _) |- _ ] => invc H
    | [ H : (_, _, _) = (_, _, _) |- _ ] => invc H
    | [ H : (_, _) = (_, _) |- _ ] => invc H
  end.

(** [f_apply H f] derives a hypothesis of type [f X = f Y] if [H] has
    type [X = Y]. *)
Ltac f_apply H f :=
  match type of H with
    | ?X = ?Y =>
      assert (f X = f Y) by (rewrite H; auto)
  end.

(** [break_let] breaks a destructuring [let] for a pair. *)
Ltac break_let :=
  match goal with
    | [ H : context [ (let (_,_) := ?X in _) ] |- _ ] => destruct X eqn:?
    | [ |- context [ (let (_,_) := ?X in _) ] ] => destruct X eqn:?
  end.

(** [break_or_hyp] breaks a disjunctive hypothesis, splitting your
    goal into two. *)
Ltac break_or_hyp :=
  match goal with
    | [ H : _ \/ _ |- _ ] => invc H
  end.

(** [copy_apply lem H] adds a hypothesis obtained by [apply]-ing [lem]
    in [H]. *)
Ltac copy_apply lem H :=
  let x := fresh in
  pose proof H as x;
    apply lem in x.

(** [copy_eapply lem H] adds a hypothesis obtained by [eapply]-ing
    [lem] in [H]. *)
Ltac copy_eapply lem H :=
  let x := fresh in
  pose proof H as x;
    eapply lem in x.

(** [conclude_using tac] specializes a hypothesis if it can prove its
    premise using [tac]. *)
Ltac conclude_using tac :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H tac
  end.

(** [find_higher_order_rewrite] tries to [rewrite] with
    possibly-quantified hypotheses into other hypotheses or the
    goal. *)
Ltac find_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite H in *
  end.

(** [find_reverse_higher_order_rewrite] tries to [rewrite <-] with
    possibly-quantified hypotheses into other hypotheses or the
    goal. *)
Ltac find_reverse_higher_order_rewrite :=
  match goal with
    | [ H : _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _, _ = _ |- _ ] => rewrite <- H in *
    | [ H : forall _ _, _ = _ |- _ ] => rewrite <- H in *
  end.

(** [clean] removes any hypothesis of the shape [X = X]. *)
Ltac clean :=
  match goal with
    | [ H : ?X = ?X |- _ ] => clear H
  end.

(** [find_apply_hyp_goal] tries solving the goal applying some
    hypothesis. *)
Ltac find_apply_hyp_goal :=
  match goal with
    | [ H : _ |- _ ] => solve [apply H]
  end.

(** [find_copy_apply_lem_hyp lem] tries to find a hypothesis to which
    [lem] can be applied, and adds a hypothesis resulting from the
    application. *)
Ltac find_copy_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_apply lem H
  end.

(** [find_apply_hyp_hyp] finds a hypothesis which can be applied in
    another hypothesis, and performs the application. *)
Ltac find_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      apply H in H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      apply H in H'; auto; [idtac]
  end.

Ltac find_eapply_hyp_hyp :=
  match goal with
  | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
    eapply H in H'; [idtac]
  | [ H : _ -> _ , H' : _ |- _ ] =>
    eapply H in H'; auto; [idtac]
  end.

(** [find_copy_apply_hyp_hyp] finds a hypothesis which can be applied
    in another hypothesis, and adds a hypothesis with the application
    performed. *)
Ltac find_copy_apply_hyp_hyp :=
  match goal with
    | [ H : forall _, _ -> _,
        H' : _ |- _ ] =>
      copy_apply H H'; [idtac]
    | [ H : _ -> _ , H' : _ |- _ ] =>
      copy_apply H H'; auto; [idtac]
  end.

(** [find_apply_lem_hyp lem] finds a hypothesis where [lem] can be
    [apply]-ed, and performes the application. *)
Ltac find_apply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => apply lem in H
  end.

(** [find_eapply_lem_hyp lem] finds a hypothesis where [lem] can be
    [eapply]-ed, and performes the application. *)
Ltac find_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => eapply lem in H
  end.

(** TODO: document this. *)
Ltac insterU H :=
  match type of H with
    | forall _ : ?T, _ =>
      let x := fresh "x" in
      evar (x : T);
      let x' := (eval unfold x in x) in
        clear x; specialize (H x')
  end.

(** TODO: document this. *)
Ltac find_insterU :=
  match goal with
    | [ H : forall _, _ |- _ ] => insterU H
  end.

(** [eapply_prop P] finds a hypothesis proving [P] and [eapply]-es it. *)
Ltac eapply_prop P :=
  match goal with
    | H : P _ |- _ =>
      eapply H
  end.

(** [find_eapply_prop P] finds a hypothesis including [P] and [eapply]-es it. *)
Ltac find_eapply_prop P :=
  match goal with
    | H : context [ P ] |- _ =>
      eapply H
  end.

(** [isVar t] succeeds if term [t] is a variable in the context. *)
Ltac isVar t :=
    match goal with
      | v : _ |- _ =>
        match t with
          | v => idtac
        end
    end.

(** [remGen t] is useful when one wants to do induction on a
    hypothesis whose indices are not concrete.  By default, the
    [induction] tactic will first generalize them, losing information
    in the process.  By introducing an equality, one can save this
    information while generalizing the hypothesis. *)
Ltac remGen t :=
  let x := fresh in
  let H := fresh in
  remember t as x eqn:H;
    generalize dependent H.

(** [remGenIfNotVar t] performs [remGen t] unless [t] is a simple
    variable. *)
Ltac remGenIfNotVar t := first [isVar t| remGen t].

(** [rememberNonVars H] will pose an equation for all indices of [H]
    that are concrete.  For instance, given: [H : P a (S b) c], it
    will generalize into [H : P a b' c] and [EQb : b' = S b]. *)
Ltac rememberNonVars H :=
  match type of H with
    | _ ?a ?b ?c ?d ?e =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d;
      remGenIfNotVar e
    | _ ?a ?b ?c ?d =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c;
      remGenIfNotVar d
    | _ ?a ?b ?c =>
      remGenIfNotVar a;
      remGenIfNotVar b;
      remGenIfNotVar c
    | _ ?a ?b =>
      remGenIfNotVar a;
      remGenIfNotVar b
    | _ ?a =>
      remGenIfNotVar a
  end.

(* [generalizeEverythingElse H] tries to generalize everything that is
   not [H]. *)
Ltac generalizeEverythingElse H :=
  repeat match goal with
           | [ x : ?T |- _ ] =>
             first [
                 match H with
                   | x => fail 2
                 end |
                 match type of H with
                   | context [x] => fail 2
                 end |
                 revert x]
         end.

(* [prep_induction H] prepares your goal to perform [induction] on [H] by:
   - remembering all concrete indices of [H] via equations;
   - generalizing all variables that are not depending on [H] to strengthen the
     induction hypothesis. *)
Ltac prep_induction H :=
  rememberNonVars H;
  generalizeEverythingElse H.

(* [econcludes] tries to specialize a hypothesis using [eauto]. *)
Ltac econcludes :=
  match goal with
    | [ H : ?P -> _ |- _ ] => conclude H eauto
  end.

(** [find_copy_eapply_lem_hyp lem] tries to find a hypothesis to which
    [lem] can be [eapply]-ed, and adds a hypothesis resulting from the
    application. *)
Ltac find_copy_eapply_lem_hyp lem :=
  match goal with
    | [ H : _ |- _ ] => copy_eapply lem H
  end.

(** [apply_prop_hyp P Q] tries to [apply] a hypothesis about [P] to a
    hypothesis about [Q]. *)
Ltac apply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    apply H in H'
  end.

(** [apply_prop_hyp P Q] tries to [eapply] a hypothesis about [P] to a
    hypothesis about [Q]. *)
Ltac eapply_prop_hyp P Q :=
  match goal with
  | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
    eapply H in H'
  end.

(** [apply_prop_hyp P Q] tries to [eapply] a hypothesis about [P] to a
    hypothesis about [Q], posing the result as a new hypothesis. *)
Ltac copy_eapply_prop_hyp P Q :=
  match goal with
    | [ H : context [ P ], H' : context [ Q ] |- _ ] =>
      copy_eapply H H'
  end.

Ltac eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    eapply lem in H
  end.

Ltac copy_eapply_lem_prop_hyp lem P :=
  match goal with
  | [ H : context [ P ] |- _ ] =>
    copy_eapply lem H
  end.

(** [find_false] finds a hypothesis of the shape [P -> False] in the
    context and cuts your goal with it, leaving you with the
    obligation of proving its premise [P]. *)
Ltac find_false :=
  match goal with
    | H : _ -> False |- _ => exfalso; apply H
  end.

(** [injc H] performs [injection] on [H], then clears [H] and
    simplifies the context. *)
Ltac injc H :=
  injection H; clear H; intros; subst_max.

(** [find_injection] looks for an [injection] in the context and
    performs [injc]. *)
Ltac find_injection :=
  match goal with
    | [ H : ?X _ _ _ _ _ _ = ?X _ _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ _ = ?X _ _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ _ = ?X _ _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ _ = ?X _ _ _ |- _ ] => injc H
    | [ H : ?X _ _ = ?X _ _ |- _ ] => injc H
    | [ H : ?X _ = ?X _ |- _ ] => injc H
  end.

(** [aggressive_rewrite_goal] rewrites in the goal with any
    hypothesis. *)
Ltac aggressive_rewrite_goal :=
  match goal with H : _ |- _ => rewrite H end.

(** [break_exists_name x] destructs an existential in context and
    names the witness [x]. *)
Ltac break_exists_name x :=
  match goal with
  | [ H : exists _, _ |- _ ] => destruct H as [x H]
  end.
(*
General definition of a state monad with error + monadic notations, borrowed/tweaked from:  https://github.com/uwplse/verdi/blob/master/core/StateMachineHandlerMonad.v

Author:  Adam Petz, ampetz@ku.edu
*)

(* Generalized State Monad *)
Definition St(S A : Type) : Type := S -> (option A) * S % type.

Definition ret {S A : Type} (a : A) : St S A := fun s => (Some a, s).

Definition bind {S A B : Type} (m : St S A) (f : A -> St S B) : St S B :=
  fun s =>
    let '(a, s') := m s in
    match a with
    | Some v =>
      let '(b, s'') := f v s' in
      (b, s'')
    | _ => (None,s')
    end.

Definition failm {S A : Type} : St S A := fun s => (None, s).
      

(* alias for ret *)
(*Definition write_output {S O} (o : O) : GenHandler1 S O := ret o.*)

Definition modify {S} (f : S -> S) : St S unit := fun s => (Some tt, f s).

Definition put {S} (s : S) : St S unit := fun _ => (Some tt, s).

Definition get {S} : St S S := fun s => (Some s, s).

Definition runSt {S A} (h : St S A) (s : S)  : (option A) * S % type :=
  h s.

Definition evalSt {S A} (h : St S A) (s : S) : option A :=
 fst (runSt h s).

Definition execSt {S A} (h : St S A) (s : S) : S :=
  snd ((*runSt*) h s).




Definition nop {S : Type} := @ret S _ tt.

Notation "a >> b" := (bind a (fun _ => b)) (at level 50).

Notation "x <- c1 ;; c2" := (@bind _ _ _ c1 (fun x => c2))
                              (at level 100, c1 at next level, right associativity).

Notation "e1 ;; e2" := (_ <- e1 ;; e2)
                         (at level 100, right associativity).

Notation "' pat <- c1 ;; c2" :=
    (@bind _ _ c1 (fun x => match x with pat => c2 end))
    (at level 100, pat pattern, c1 at next level, right associativity).

Definition gets {S} {A} (f:S -> A) : St S A :=
  st <- get ;;
  ret (f st).

Definition when {S A} (b : bool) (m : St S A) : St S unit :=
  if b then m ;; ret tt else nop.
(*
Evidence structure that models concrete results of Copland phrase execution.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import StructTactics Defs. (*AutoPrim. *)

Require Import Coq.Program.Tactics.

Require Import List.
Import ListNotations.

Require Export Term_Defs.

(** * Concrete Evidence 
    This datatype acts as a "Typed Concrete Evidence" structure.  It captures
    both the type of evidence (parameters associated with its collection) 
    along with concrete binary (BS) values collected during attestation.
*)

Inductive EvidenceC: Set :=
| mtc: EvidenceC
| nnc: N_ID -> BS -> EvidenceC
| ggc: Plc -> ASP_PARAMS -> BS -> EvidenceC -> EvidenceC
| hhc: Plc -> ASP_PARAMS -> BS -> Evidence -> EvidenceC
| eec: Plc -> ASP_PARAMS -> BS -> Evidence -> EvidenceC
| kkc: Plc -> ASP_PARAMS -> Evidence -> EvidenceC
| kpc: Plc -> ASP_PARAMS -> EvidenceC -> EvidenceC
| ssc: EvidenceC -> EvidenceC -> EvidenceC.

(** The Evidence Type associated with a Typed Concrete Evidence value *)
Fixpoint et_fun (ec:EvidenceC) : Evidence :=
  match ec with
  | mtc => mt
  | ggc p params _ ec' => uu p EXTD params (et_fun ec')
  | hhc p params _ et => uu p COMP params et
  | eec p params _ et => uu p ENCR params et (* (et_fun ec') *)
  | kkc p params et' => uu p KILL params et'
  | kpc p params ec' => uu p KEEP params (et_fun ec')
                       
  | nnc ni _ => nn ni
  | ssc ec1 ec2 => ss (et_fun ec1) (et_fun ec2)
  end.

(** Evidence Type subterm relation *)
Inductive EvSubT: Evidence -> Evidence -> Prop :=
| evsub_reflT : forall e : Evidence, EvSubT e e
| uuSubT: forall e e' p fwd ps,
    EvSubT e e' -> 
    EvSubT e (uu p fwd ps e')
| ssSublT: forall e e' e'',
    EvSubT e e' ->
    EvSubT e (ss e' e'')
| ssSubrT: forall e e' e'',
    EvSubT e e'' ->
    EvSubT e (ss e' e'').
#[export] Hint Constructors EvSubT : core.

Ltac evSubTFacts :=
  match goal with
  | [H: EvSubT (?C _) _ |- _] => invc H
  | [H: EvSubT _ (?C _) |- _] => invc H
  | [H: EvSubT _ mt |- _] => invc H
  | [H: EvSubT mt _ |- _] => invc H
  end.

Lemma evsubT_transitive: forall e e' e'',
    EvSubT e e' ->
    EvSubT e' e'' ->
    EvSubT e e''.
Proof.
  intros.
  generalizeEverythingElse e''.
  induction e''; intros;
    try evSubTFacts;
       eauto.
Defined.

(** Typed Concrete Evidence subterm relation *)
Inductive EvSub: EvidenceC -> EvidenceC -> Prop :=
| evsub_refl : forall e : EvidenceC, EvSub e e
| ggSub: forall e e' p ps bs,
    EvSub e e' ->
    EvSub e (ggc p ps bs e')
          (* TODO: encrypt case here? *)
| ssSubl: forall e e' e'',
    EvSub e e' ->
    EvSub e (ssc e' e'')
| ssSubr: forall e e' e'',
    EvSub e e'' ->
    EvSub e (ssc e' e'').
#[export] Hint Constructors EvSub : core.

Ltac evSubFacts :=
  match goal with
  | [H: EvSub (?C _) _ |- _] => invc H
  | [H: EvSub _ (?C _) |- _] => invc H
  | [H: EvSub _ mtc |- _] => invc H
  | [H: EvSub mtc _ |- _] => invc H
  end.

(** Subterm relation is preserved through et_fun *)
Lemma evsub_etfun: forall e e',
    EvSub e e' ->
    EvSubT (et_fun e) (et_fun e').
Proof.
  intros.
  induction H; intros;
    cbn in *; eauto.
Defined.

Lemma evsub_hh: forall e e' e0,
    EvSub e0 e' ->
    EvSubT (et_fun e') e ->
    EvSubT (et_fun e0) e.
Proof.
  intros.
  generalizeEverythingElse e.
  induction e; intros; ff.
  -
    invc H0.
    jkjke.
    assert (e' = mtc).
    {
      destruct e'; try solve_by_inversion.
    }
    (*
    assert (e' = mtc \/ (exists p ps et', e' = kkc p ps et')).
    {
      destruct e'; try solve_by_inversion.
      eauto.
    }
    door.
    +
    subst.
    ff.
    +
      subst.
      ff.
     *)
    subst.
    ff.
      
  -
    invc H0.
    jkjke.
    destruct e'; try solve_by_inversion.
    ff.
  -
    invc H0.
    +
      destruct f.
      ++
        destruct e'; ff.
          
      ++
        destruct e'; ff.
          
      ++
        destruct e'; ff.
        invc H; ff; eauto.

      ++
        destruct e'; ff.
        
      ++
        destruct e'; ff.
          
    +
      eauto.
  -
    invc H0.
    +
      destruct e'; ff.
      invc H; ff; eauto.
    +
      eauto.
    +
      eauto.   
Qed.

Lemma evsub_transitive: forall e e' e'',
    EvSub e e' ->
    EvSub e' e'' ->
    EvSub e e''.
Proof.
  intros e e' e'' H H0.
  generalizeEverythingElse e''.
  induction e''; intros; ff; invc H0; eauto.
Defined.

Definition splitEv_l (sp:Split) (e:EvC): EvC :=
  match sp with
  | (ALL, _) => e
  | _ => mt_evc
  end.

Definition splitEv_r (sp:Split) (e:EvC): EvC :=
  match sp with
  | (_,ALL) => e
  | _ => mt_evc
  end.

Definition splitEvl (sp:Split) (e:EvidenceC) : EvidenceC :=
  match sp with
  | (ALL,_) => e
  | _ => mtc
  end.

Definition splitEvr (sp:Split) (e:EvidenceC) : EvidenceC :=
  match sp with
  | (_,ALL) => e
  | _ => mtc
  end.
(** This file contains the basic definitions for Copland terms, Core terms, 
   Evidence Types, and Copland events. *)

(*
   These definitions have been adapted from an earlier version, archived 
   here:  https://ku-sldg.github.io/copland/resources/coplandcoq.tar.gz
*)

(* LICENSE NOTICE

Copyright (c) 2018 The MITRE Corporation.
All Rights Reserved.

This proof script is free software: you can redistribute it and/or
modify it under the terms of the BSD License as published by the
University of California.  See license.txt for details. *)

(*
Require Export BS.
Require Export String. *)

Require Import List.
Import List.ListNotations.

Require Export Params_Admits.

Require Export Term_Defs_Core.

(* sig_params, hsh_params, defs were here *)

(**  Translating a primitive Copland phrase to its Core_Term equivalent *)
Definition asp_term_to_core (a:ASP) : Core_Term :=
  match a with
  | NULL => aspc NULLC
  | CPY => aspc CPYC
  | ASPC sp fwd params =>
    match sp with
    | NONE => lseqc (aspc CLEAR) (aspc (ASPCC fwd params))
    | ALL => (aspc (ASPCC fwd params))
    end                
  | SIG => aspc (ASPCC EXTD sig_params)
  | HSH => aspc (ASPCC COMP hsh_params)
  | ENC q => aspc (ASPCC ENCR (enc_params q))
  end.

(**  Translating a Copland phrase to its Core_Term equivalent *)
Fixpoint copland_compile (t:Term) : Core_Term :=
  match t with
  | asp a => (asp_term_to_core a)
  | att q t' => attc q t'

  | lseq t1 t2 => lseqc (copland_compile t1) (copland_compile t2)

  | bseq (ALL,ALL) t1 t2 =>
    bseqc
      (copland_compile t1) (copland_compile t2)  
  | bseq (ALL,NONE) t1 t2 =>
    bseqc
      (copland_compile t1)
      (lseqc (aspc CLEAR) (copland_compile t2))
  | bseq (NONE,ALL) t1 t2 =>
    bseqc
      (lseqc (aspc CLEAR) (copland_compile t1))
      (copland_compile t2)
  | bseq (NONE,NONE) t1 t2 =>
    bseqc
      (lseqc (aspc CLEAR) (copland_compile t1))
      (lseqc (aspc CLEAR) (copland_compile t2))
          
  | bpar (ALL,ALL) t1 t2 =>
    bparc O (copland_compile t1) (copland_compile t2)     
  | bpar (ALL,NONE) t1 t2 =>
    bparc O
      (copland_compile t1)
      (lseqc (aspc CLEAR) (copland_compile t2))
  | bpar (NONE,ALL) t1 t2 =>
    bparc O
      (lseqc (aspc CLEAR) (copland_compile t1))
      (copland_compile t2)
  | bpar (NONE,NONE) t1 t2 =>
    bparc O
      (lseqc (aspc CLEAR) (copland_compile t1))
      (lseqc (aspc CLEAR) (copland_compile t2))
  end.


(** Propositional encapsulation of copland_compile.  
    Useful to avoid spurious rewriting during proofs *)
Inductive term_to_coreP: Term -> Core_Term -> Prop :=
| toCoreP: forall t t',
    copland_compile t = t' ->
    term_to_coreP t t'.


(**  Calculate the size of an Evidence type *)
Fixpoint et_size (e:Evidence): nat :=
  match e with
  | mt => O
  | uu _ fwd _ e' =>
    match fwd with
    | COMP => 1
    | ENCR => 1
    | EXTD => 1 + et_size e'
    | KILL => 0
    | KEEP => et_size e'
    end 
  | nn _ => 1
  | ss e1 e2 => (et_size e1) + (et_size e2)
  end.


(** Raw Evidence representaiton:  a list of binary (BS) values. *)
Definition RawEv := list BS.

(**  Type-Tagged Raw Evidence representation.  Used as the internal evidence
     type managed by the CVM to track evidence contents and its structure. *)
Inductive EvC: Set :=
| evc: RawEv -> Evidence -> EvC.

Definition mt_evc: EvC := (evc [] mt).

Definition get_et (e:EvC) : Evidence :=
  match e with
  | evc ec et => et
  end.

Definition get_bits (e:EvC): list BS :=
  match e with
  | evc ls _ => ls
  end.

(** A "well-formed" EvC value is where the length of its raw evidence portion
    has the proper size (calculated over the Evidence Type portion). *)
Inductive wf_ec : EvC -> Prop :=
| wf_ec_c: forall (ls:RawEv) et,
    length ls = et_size et ->
    wf_ec (evc ls et).


Definition ReqAuthTok := EvC.
    
    
Definition splitEv_T_l (sp:Split) (e:Evidence) : Evidence :=
  match sp with
  | (ALL,_) => e
  |  _ => mt
  end.

Definition splitEv_T_r (sp:Split) (e:Evidence) : Evidence :=
  match sp with
  | (_,ALL) => e
  |  _ => mt
  end.

Definition sp_ev (sp:SP) (e:Evidence) : Evidence :=
  match sp with
  | ALL => e
  | NONE => mt
  end.

(** Helper function for evidence type reference semantics *)
Definition eval_asp t p e :=
  match t with
  | NULL => mt
  | CPY => e 
  | ASPC sp fwd params =>
    match fwd with
    | KEEP => (sp_ev sp e)
    | KILL => mt
    | _ => uu p fwd params (sp_ev sp e)
    end
  | SIG => uu p EXTD sig_params e
  | HSH => uu p COMP hsh_params e
  | ENC q => uu p ENCR (enc_params q) e
  end.

(** Evidence Type denotational reference semantics.
    The evidence associated with a term, a place, and some initial evidence. *)

Fixpoint eval (t:Term) (p:Plc) (e:Evidence) : Evidence :=
  match t with
  | asp a => eval_asp a p e
  | att q t1 => eval t1 q e
  | lseq t1 t2 => eval t2 p (eval t1 p e)
  | bseq s t1 t2 => ss (eval t1 p (splitEv_T_l s e))
                      (eval t2 p (splitEv_T_r s e))
  | bpar s t1 t2 => ss (eval t1 p (splitEv_T_l s e))
                      (eval t2 p (splitEv_T_r s e))
  end.

(** * Events

    There are events for each kind of action. This includes ASP
    actions such as measurement or data processing. It also includes
    control flow actions: a [split] occurs when a thread of control
    splits, and a [join] occurs when two threads join.  [req] and [rpy] 
    are communication events.  [cvm_thread_start] and [cvm_thread_end] are 
    parallel thread synchonization events, unique to CVM execution (not in 
    the reference semantics).  Each event is distinguished using a unique 
    natural number.
 *)

Inductive Ev: Set :=
| null: nat -> Plc -> Ev
| copy:  nat -> Plc -> Ev 
| umeas: nat -> Plc -> ASP_PARAMS -> Evidence -> Ev
| req: nat -> Plc -> Plc -> Term -> Evidence -> Ev
| rpy: nat -> Plc -> Plc -> Evidence -> Ev 
| split: nat -> Plc -> Ev
| join:  nat -> Plc -> Ev
| cvm_thread_start: Loc -> Plc -> Core_Term -> Evidence -> Ev
| cvm_thread_end: Loc -> Ev.

(** The natural number used to distinguish events. *)

Definition ev x : nat :=
  match x with
  | null i _ => i
  | copy i _ => i
  | umeas i _ _ _ => i
  | req i _ _ _ _ => i
  | rpy i _ _ _ => i 
  | split i _ => i
  | join i _ => i
  | cvm_thread_start _ _ _ _ => 42
  | cvm_thread_end _ => 43
  end.
(* 
(** The natural number indicating the place where an event occured. *)
Definition pl x : Plc :=
  match x with
  | null _ p => p
  | copy _ p => p
  | umeas _ p _ _ => p
  | req _ p _ _ _ => p
  | rpy _ p _ _ => p
  | split _ p => p
  | join _ p => p
  | cvm_thread_start _ p _ _ => p
  | cvm_thread_end _ => 45
  end. *)

(** Events are used in a manner that ensures that
[[
    forall e0 e1, ev e0 = ev e1 -> e0 = e1.
]]
See Lemma [events_injective].
 *)


Definition asp_event i x p e :=
  match x with
  | NULL => null i p
  | CPY => copy i p
  | ASPC sp _ ps => umeas i p ps (sp_ev sp e)
  | SIG => umeas i p sig_params e
  | HSH => umeas i p hsh_params e
  | ENC q => umeas i p (enc_params q) e
  end.



(** This file contains the basic definitions for Copland terms, Core terms, 
   Evidence Types, and Copland events. *)

(*
   These definitions have been adapted from an earlier version, archived 
   here:  https://ku-sldg.github.io/copland/resources/coplandcoq.tar.gz 

   with License:

LICENSE NOTICE

Copyright (c) 2018 The MITRE Corporation.
All Rights Reserved.

This proof script is free software: you can redistribute it and/or
modify it under the terms of the BSD License as published by the
University of California.  See license.txt for details. *)

Require Export BS.
Require Import String.

Require Import List AbstractedTypes.
Import List.ListNotations.

(*
Set Nested Proofs Allowed.
 *)


(*
Module Export Term_Defs_Core.
 *)





(** * Terms and Evidence

    A term is either an atomic ASP, a remote call, a sequence of terms
    with data a dependency, a sequence of terms with no data
    dependency, or parallel terms. *)

(** [Plc] represents a place (or attestation domain). *)
Definition Plc: Set := ID_Type.
(** [N_ID] represents a nonce identifier.  *)
Definition N_ID: Set := nat.
(** [Event_ID] represents Event identifiers *)
Definition Event_ID: Set := nat.

(** [ASP_ID], [TARG_ID], and [Arg] are all string-typed parameters to ASPs 
    [ASP_ID] identifies the procedure invoked.
    [TARG_ID] identifies the target (when a target makes sense).
    [Arg] represents a custom argument for a given ASP 
          (defined and interpreted per-scenario/implementaiton).
*)
Definition ASP_ID: Set := ID_Type.
Definition TARG_ID: Set := ID_Type.
Definition Arg: Set := ID_Type.

(** Grouping ASP parameters into one constructor *)
Inductive ASP_PARAMS: Set :=
| asp_paramsC: ASP_ID -> (list Arg) -> Plc -> TARG_ID -> ASP_PARAMS.

(** Evidence extension types for ASPs:
      COMP:  Compact evidence down to a single value (i.e. a hash).
      ENCR:  Like COMP, but the single value is semantically an ENCRYPTED one.
      EXTD:  Extend bundle (non-destructively) by prepending the new ASP result to the front.
      KILL:  Ignore evidence produced by an ASP and put Mt evidence.
      KEEP:  Ignore evidence produced by an ASP and keep the input evidence unchanged.


COMP:  [b1, b2, ..., bn] ==> [hash([b1, b2, ..., bn])]
ENCR:  [b1, b2, ..., bn] ==> [encrypt([b1, b2, ..., bn])]
EXTD:  [b1, b2, ..., bn] ==> [f([b1, b2, ..., bn]), b1, b2, ..., bn]], 
            where f represents the ASP's functional result over an input evidence bundle.
KILL:  [b1, b2, ..., bn] ==> []
KEEP:  [b1, b2, ..., bn] ==> [b1, b2, ..., bn]
*)
Inductive FWD: Set :=
| COMP
| ENCR
| EXTD
| KILL
| KEEP.

(** The structure of evidence. 

    mt:  Empty evidence 
    nn:  Nonce evidence (with an ID)
    uu:  ASP evidence 
    ss:  evidence pairing (composition)
*)
Inductive Evidence: Set :=
| mt: Evidence
| nn: N_ID -> Evidence
| uu: Plc -> FWD -> ASP_PARAMS -> Evidence -> Evidence
| ss: Evidence -> Evidence -> Evidence.

(** Evidene routing types:  
      ALL:   pass through all evidence
      NONE   pass through empty evidence
*)
Inductive SP: Set :=
| ALL
| NONE.


(** Primitive Copland phases 

    NULL:    Empty out evidence (optionally with a strong "zeroize" effect)
    CPY:     Copy evidence (leave input evidence unchanged)
    ASPC sp fwd ps:    
        Arbitrary ASPs:
          sp indicates passing ALL or NONE as input evidence.
          fwd indicates how to extend output evidence.
          ps indicates the asp parameters structure
    SIG:     Signature primitive
    HSH:     Hash primitive 
    ENC q:   Encryption primitive using public key associated with place q.
*)
Inductive ASP: Set :=
| NULL: ASP
| CPY: ASP
| ASPC: SP -> FWD -> ASP_PARAMS -> ASP
| SIG: ASP
| HSH: ASP
| ENC: Plc -> ASP.

(** Pair of evidence splitters that indicate routing evidence to subterms 
    of branching phrases *)
Definition Split: Set := (SP * SP).

(** Main Copland phrase datatype definition *)
Inductive Term: Set :=
| asp: ASP -> Term
| att: Plc -> Term -> Term
| lseq: Term -> Term -> Term
| bseq: Split -> Term -> Term -> Term
| bpar: Split -> Term -> Term -> Term.

(* Adapted from Imp language Notation in Software Foundations (Pierce) *)
Declare Custom Entry copland_entry.
Declare Scope cop_ent_scope.
Notation "<{ e }>" := e (at level 0, e custom copland_entry at level 99) : cop_ent_scope.
Notation "( x )" := x (in custom copland_entry, x at level 99) : cop_ent_scope.
Notation "x" := x (in custom copland_entry at level 0, x constr at level 0) : cop_ent_scope.
(* Branches*)
Notation "x -<- y" := (bseq (NONE, NONE) x y) (in custom copland_entry at level 70, right associativity).
Notation "x +<- y" := (bseq (ALL, NONE) x y) (in custom copland_entry at level 70, right associativity).
Notation "x -<+ y" := (bseq (NONE, ALL) x y) (in custom copland_entry at level 70, right associativity).
Notation "x +<+ y" := (bseq (ALL, ALL) x y) (in custom copland_entry at level 70, right associativity).
Notation "x -~- y" := (bpar (NONE, NONE) x y) (in custom copland_entry at level 70, right associativity).
Notation "x +~- y" := (bpar (ALL, NONE) x y) (in custom copland_entry at level 70, right associativity).
Notation "x -~+ y" := (bpar (NONE, ALL) x y) (in custom copland_entry at level 70, right associativity).
Notation "x +~+ y" := (bpar (ALL, ALL) x y) (in custom copland_entry at level 70, right associativity).
(* ARROW sequences *)
Notation "x -> y" := (lseq x y) (in custom copland_entry at level 99, right associativity).
(* ASP's *)
Notation "!" := (asp SIG) (in custom copland_entry at level 98).
Notation "#" := (asp HSH) (in custom copland_entry at level 98).
Notation "* p" := (asp (ENC p)) (in custom copland_entry at level 98).
Notation "$" := (asp KILL) (in custom copland_entry at level 98).
Notation "'__'" := (asp CPY) (in custom copland_entry at level 98).
Notation "'{}'" := (asp NULL) (in custom copland_entry at level 98).
Notation "'<<' x y z '>>'" := (asp (ASPC ALL EXTD (asp_paramsC x nil y z))) 
                      (in custom copland_entry at level 98).
(* @ plc phrase *)
Notation "@ p [ ph ]" := (att p ph) (in custom copland_entry at level 50).

Open Scope cop_ent_scope.
Definition test1 := <{ __ -> {} }>.
Example test1ex : test1 = (lseq (asp CPY) (asp NULL)). reflexivity. Defined.
Definition test_enc := <{ __ -> * min_id_type}>.
Example testencex : test_enc = (lseq (asp CPY) (asp (ENC min_id_type))). reflexivity. Defined.

(** Copland Core_Term primitive datatypes *)
Inductive ASP_Core: Set :=
| NULLC: ASP_Core
| CLEAR: ASP_Core
| CPYC: ASP_Core
| ASPCC: FWD -> ASP_PARAMS -> ASP_Core.

(** Abstract Location identifiers used to aid in management and execution 
    of parallel Copland phrases. *)
Definition Loc: Set := nat.
Definition Locs: Set := list Loc.

(** Copland Core_Term definition.  Compilation target of the Copland Compiler, 
    execution language of the Copland VM (CVM). *)
Inductive Core_Term: Set :=
| aspc: ASP_Core -> Core_Term
| attc: Plc -> Term -> Core_Term
| lseqc: Core_Term -> Core_Term -> Core_Term
| bseqc: Core_Term -> Core_Term -> Core_Term
| bparc: Loc -> Core_Term -> Core_Term -> Core_Term.

Declare Custom Entry core_copland_entry.
Declare Scope core_cop_ent_scope.
Notation "<<core>{ e }>" := e (at level 0, e custom core_copland_entry at level 99) : core_cop_ent_scope.
Notation "( x )" := x (in custom core_copland_entry, x at level 99) : core_cop_ent_scope.
Notation "x" := x (in custom core_copland_entry at level 0, x constr at level 0) : core_cop_ent_scope.
(* Branches*)
Notation "x < y" := (bseqc x y) (in custom core_copland_entry at level 70, right associativity).
Notation "x ~ l y" := (bparc l x y) (in custom core_copland_entry at level 70, right associativity).
(* ARROW sequences *)
Notation "x -> y" := (lseqc x y) (in custom core_copland_entry at level 99, right associativity).
(* ASP_CORE's *)
Notation "'__'" := (aspc CPYC) (in custom core_copland_entry at level 98).
Notation "'{}'" := (aspc NULLC) (in custom core_copland_entry at level 98).
Notation "'CLR'" := (aspc CLEAR) (in custom core_copland_entry at level 98).
Notation "'<<' F x y z '>>'" := (aspc (ASPCC F (asp_paramsC x nil y z))) 
                      (in custom core_copland_entry at level 98).
(* @ plc phrase *)
Notation "@ p [ ph ]" := (attc p ph) (in custom core_copland_entry at level 50).


Open Scope core_cop_ent_scope.
Definition test2 := <<core>{ __ -> {} }>.
Example test2ex : test2 = (lseqc (aspc CPYC) (aspc NULLC)). reflexivity. Defined.
Example test3 : <<core>{ CLR -> {}}> = (lseqc (aspc CLEAR) (aspc NULLC)). reflexivity. Defined.


Inductive AppResultC: Set :=
| mtc_app: AppResultC
| nnc_app: N_ID -> BS -> AppResultC
| ggc_app: Plc -> ASP_PARAMS -> BS -> AppResultC -> AppResultC
| hhc_app: Plc -> ASP_PARAMS -> BS -> AppResultC -> (* Evidence -> *) AppResultC
| eec_app: Plc -> ASP_PARAMS -> BS -> AppResultC ->(* Evidence -> *) AppResultC
| ssc_app: AppResultC -> AppResultC -> AppResultC.


Fixpoint appresultc_size (res:AppResultC) : nat :=
  match res with
  | mtc_app => 0
  | nnc_app _ _ => 1
  | ggc_app _ _ _ res' => Nat.add 1 (appresultc_size res')
  | hhc_app _ _ _ res' => Nat.add 1 (appresultc_size res')
  | eec_app _ _ _ res' => Nat.add 1 (appresultc_size res')
  | ssc_app res1 res2 => Nat.add (appresultc_size res1) (appresultc_size res2)
  end.

Definition appres_size_lt_zero (res:AppResultC) : bool :=
  Nat.ltb (appresultc_size res) 0.



(*
End Term_Defs_Core.
*)
(* Defining (abstract) representation for binary data values.
   BS stands for "Binary String".   *)

Definition BS : Set.
Admitted.
Definition default_bs : BS.
Admitted.

Definition passed_bs : BS.
Admitted.
Definition failed_bs : BS.
Admitted.
Require Import Term_Defs_Core.


(** Abstract definitions for signing and hashing parameters.  
    May instantiate these during compilation in the future. *)
Definition sig_params : ASP_PARAMS.
Admitted.
Definition hsh_params : ASP_PARAMS.
Admitted.

Definition enc_params : Plc -> ASP_PARAMS.
Admitted.
(* 
  Collection of general (structural) Ltac tactics for simplification and 
  rewriting proof contexts

  Author:  Adam Petz
*)

Require Import StructTactics.

Require Import List.
Import List.ListNotations.

Require Import Coq.Program.Tactics.

(*
Ltac dff :=
  repeat (
      cbn in *;
      repeat break_let;
      repeat (cbn in *; find_inversion);
      unfold snd in * ).

Ltac fff := repeat break_match; try solve_by_inversion; dff.
*)

(* rewrite (existentially) an arbitrary hypothesis and attempt eauto *)
Ltac jkjke :=
  match goal with
  | [H: _ |-  _ ] => erewrite H; eauto
  end.

(* rewrite <- (existentially) an arbitrary hypothesis and attempt eauto *)
Ltac jkjke' :=
  match goal with
  | [H: _ |-  _ ] => erewrite <- H in *; eauto
  end.

(* attempt to rerwite an arbitrary equality assumption whose LHS is mentioned
   in the proof goal *)
Ltac jkjk :=
  match goal with
  | [H: ?X = _ |- context[?X] ] => rewrite H
  end.

(* attempt to rerwite an arbitrary <- equality assumption whose LHS is  
   mentioned in the proof goal *)
Ltac jkjk' :=
  match goal with
  | [H: ?X = _ |- context[?X] ] => rewrite <- H
  end.

(* "Do OR":  find a disjunction in hyps and destruct it *)
Ltac door :=
  match goal with
  | [H: _ \/ _  |- _] =>
    destruct H
  end; destruct_conjs.

Lemma pairsinv : forall (a a' b b':nat),
    a <> a' -> (a,b) <> (a',b').
Proof.
  intros.
  congruence.
Defined.


(* Simplification hammer.  Used at beginning of many proofs in this 
   development.  Conservative simplification, break matches, 
   invert on resulting goals *)
Ltac ff :=
  repeat (cbn in *;
          repeat break_match;
          repeat find_inversion;
          try solve_by_inversion).

Ltac fail_if_in_hyps_type t := 
  lazymatch goal with 
  | [G : t |- _ ] => fail "There is already a hypothesis of this type"
  | [_ : _ |- _ ] => idtac
  end.

Ltac fail_if_in_hyps H := 
  let t := type of H in
  fail_if_in_hyps_type t.

Ltac pose_new_proof H := 
  fail_if_in_hyps H;
  pose proof H.

Ltac assert_new_proof_by H tac := 
  fail_if_in_hyps_type H;
  assert H by tac.

(*  For every implication in proof context, try to apply each other arbitrary
    hyp, assuming the result type of the implication does not already exist
    in the context.  *)
Ltac find_apply_hyp_hyp' :=
  match goal with
  | [ H : _ -> _ , H' : _ |- _ ] =>
    (*let x := fresh in *)
    pose_new_proof (H H')
  end.

Ltac find_apply_lem_hyp lem :=
  match goal with
  | [ H : _ |- _ ] => apply lem in H
  end.

Ltac find_pose_new_lem_hyp lem :=
  match goal with
  | [ H : _ |- _ ] => pose_new_proof (lem H)
  end.

(** Core evidence bundling operations internal to the CVM.  
    Each updates the raw evidence sequence (compacting, extending, etc.),
    along with a principled update to its corresponding Evidence Type.

    Matching on the Evidence Type param is only for verification.  
    Extracted code could be simplified to only the raw evidence operation. *)

Require Import ConcreteEvidence IO_Stubs.

Require Import List.

Import ListNotations.

(* Helper that simulates encoding the raw bits portion of an evidence bundle.
   Note: encodeEvRaw is (as of now) an Admitted (abstract) operation.  *)
Definition encodeEvBits (e:EvC): BS :=
  match e with
  | (evc bits _) => encodeEvRaw bits
  end.

(** Extends raw evidence by prepending one value to the front.
    Also updates underlying Evidence Type.
    An example is digital signatures, where the signature value is prepended *)
Definition cons_gg (sig:BS) (e:EvC) (p:Plc) (ps:ASP_PARAMS): EvC :=
  match e with
  | evc bits et => evc (sig :: bits) (uu p EXTD ps et)
  end.

(** Collapses raw evidence by replacing the entire sequence with the input 
    binary hash value.  Updates underlying Evidence Type to reflect the hash. *)
Definition cons_hsh (hsh:BS) (e:EvC) (p:Plc) (ps:ASP_PARAMS): EvC :=
  match e with
  | evc _ et => evc [hsh] (uu p COMP ps et)
  end.

(** Collapses raw evidence by replacing the entire sequence with the input 
    encrypted value blob.  Updates underlying Evidence Type to reflect the
    encryption. *)
Definition cons_enc (enc:BS) (e:EvC) (p:Plc) (ps:ASP_PARAMS): EvC :=
  match e with
  | evc _ et => evc [enc] (uu p ENCR ps et)
  end.

(** Appends raw evidence and Evidence Types for the pair of input bundles *)
Definition ss_cons (e1:EvC) (e2:EvC): EvC :=
  match (e1, e2) with
  | (evc bits1 et1, evc bits2 et2) => evc (bits1 ++ bits2) (ss et1 et2)
  end.
(*
Uninterpreted functions and rewrite rules that model external (remote and local parallel) components that interpret Copland phrases.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import Term_Defs Anno_Term_Defs LTS IO_Stubs.

Require Import List.
Import ListNotations.

(** IO Axioms *)

(*
Definition doRemote_session (t:Term) (pTo:Plc) (e:EvC) : EvC.
Admitted.

Definition parallel_vm_thread (l:Loc) (t:Term) (p:Plc) (e:EvC) : EvC.
Admitted.
*)

Definition shuffled_events (el1:list Ev) (el2:list Ev) : list Ev.
Admitted.

Definition cvm_events_core (t:Core_Term) (p:Plc) (e:Evidence) : list Ev. 
Admitted.

Definition cvm_evidence_core (t:Core_Term) (p:Plc) (e:EvC) : EvC.
Admitted.

Definition cvm_events (t:Term) (p:Plc) (e:Evidence) : list Ev :=
  cvm_events_core (copland_compile t) p e.

Definition cvm_evidence (t:Term) (p:Plc) (e:EvC) : EvC :=
  cvm_evidence_core (copland_compile t) p e.


Axiom remote_LTS: forall t annt n et i i',
    annoP_indexed annt t i i' ->
    lstar (conf annt n et) (cvm_events t n et) (stop n (aeval annt n et)).


Axiom remote_Evidence_Type_Axiom: forall t n bits et,
    get_et (doRemote_session t n (evc bits et)) = eval t n et.


Axiom at_evidence : forall t (p:Plc) (e:EvC),
    doRemote_session t p e = cvm_evidence t p e.


Axiom par_evidence : forall t (p:Plc) (e:EvC) loc,
    parallel_vm_thread loc (copland_compile t) p e = cvm_evidence t p e.



Axiom bpar_shuffle : forall x annt2 i i' tr p t1 t2 et1 et2,
    annoP_indexed annt2 t2 i i' ->
    lstar (conf t1 p et1) tr (stop p (aeval t1 p et1)) ->
    lstar (bp x (conf t1 p et1) (conf annt2 p et2))
          (shuffled_events tr
                           (cvm_events t2 p et2))
          (bp x (stop p (aeval t1 p et1)) (stop p (aeval annt2 p et2))).

Axiom thread_bookend_peel: forall (t:AnnoTerm) p (*et*) etr l (a:Core_Term) tr,
    (*lstar (conf t p et) tr (stop p (aeval t p et)) -> *)
    ([cvm_thread_start l p a etr] ++ tr ++ [cvm_thread_end l] =
     (shuffled_events tr (cvm_events_core a p etr))
    ).


Axiom wf_ec_preserved_remote: forall a n e,
    wf_ec e ->
    wf_ec (doRemote_session a n e).
(* Small-step semantics *)

(* LICENSE NOTICE

Copyright (c) 2018 The MITRE Corporation.
All Rights Reserved.

This proof script is free software: you can redistribute it and/or
modify it under the terms of the BSD License as published by the
University of California.  See license.txt for details. *)

(** A small-step semantics for annotated terms. *)

Require Import List.
Import List.ListNotations.
Open Scope list_scope.
Require Import PeanoNat Minus Lia Preamble Term_Defs Term.

(** * States *)

Inductive St: Set :=
| stop: Plc -> Evidence -> St
| conf: AnnoTerm -> Plc -> Evidence -> St
| rem: nat -> Plc -> St -> St
| ls: St -> AnnoTerm -> St
| bsl: nat -> St -> AnnoTerm -> Plc -> Evidence -> St
| bsr: nat -> Evidence -> St -> St
| bp: nat -> St -> St -> St.

Fixpoint pl (s:St) :=
  match s with
  | stop p _ => p
  | conf _ p _ => p
  | rem _ p _ => p
  | ls st _ => pl st
  | bsl _ _ _ p _ => p
  | bsr _ _ st => pl st
  | bp _ _ st => pl st
  end.

(** The evidence associated with a state. *)

Fixpoint seval st :=
  match st with
  | stop _ e => e
  | conf t p e => aeval t p e
  | rem _ _ st => seval st
  | ls st t => aeval t (pl st) (seval st)
  | bsl _ st t p e => ss (seval st) (aeval t p e)
  | bsr _ e st => ss e (seval st)
  | bp _ st0 st1 => ss (seval st0) (seval st1)
  end.

(** * Labeled Transition System

    The label in a transition is either an event or [None] when the
    transition is silent.  Notice the use of annotations to provide
    the correct number for each event.  *)

Inductive step: St -> option Ev -> St -> Prop :=
(** Measurement *)

| stasp:
    forall r x p e,
      step (conf (aasp r x) p e)
           (Some (asp_event (fst r) x p e))
           (stop p (aeval (aasp r x) p e))
(** Remote call *)

| statt:
    forall r x p q e,
      step (conf (aatt r q x) p e)
           (Some (req (fst r) p q (unanno x) e))
           (rem (snd r) p (conf x q e))
| stattstep:
    forall st0 ev st1 p j,
      step st0 ev st1 ->
      step (rem j p st0) ev (rem j p st1)
| stattstop:
    forall j p q e,
      step (rem j p (stop q e))
           (Some (rpy (pred j) p q e))
           (stop p e)
(** Linear Sequential Composition *)

| stlseq:
    forall r x y p e,
      step (conf (alseq r x y) p e)
           None
           (ls (conf x p e) y)
| stlseqstep:
    forall st0 ev st1 t,
      step st0 ev st1 ->
      step (ls st0 t) ev (ls st1 t)
| stlseqstop:
    forall t p e,
      step (ls (stop p e) t) None (conf t p e)
(** Branching Sequential Composition *)

           
| stbseq:
    forall r s x y p e,
      step (conf (abseq r s x y) p e)
           (Some (split (fst r) p))
           (bsl (snd r) (conf x p (splitEv_T_l s e))
                y p (splitEv_T_r s e))
| stbslstep:
    forall st0 ev st1 j t p e,
      step st0 ev st1 ->
      step (bsl j st0 t p e) ev (bsl j st1 t p e)
| stbslstop:
    forall j e e' t p p',
      step (bsl j (stop p e) t p' e')
           None
           (bsr j e (conf t p' e'))
           
| stbsrstep:
    forall st0 ev st1 j e,
      step st0 ev st1 ->
      step (bsr j e st0) ev (bsr j e st1)
| stbsrstop:
    forall j e p e',
      step (bsr j e (stop p e'))
           (Some (join (pred j) p))
           (stop p (ss e e'))

(** Branching Parallel composition *)

| stbpar:
    forall r s x y p e,
      step (conf (abpar r s x y) p e)
           (Some (Term_Defs.split (fst r) p))
           (bp (snd r)
               (conf x p (splitEv_T_l s e))
               (conf y p (splitEv_T_r s e)))
| stbpstepleft:
    forall st0 st1 st2 ev j,
      step st0 ev st2 ->
      step (bp j st0 st1) ev (bp j st2 st1)
| stbpstepright:
    forall st0 st1 st2 ev j,
      step st1 ev st2 ->
      step (bp j st0 st1) ev (bp j st0 st2)
| stbpstop:
    forall j p e p' e',
      step (bp j (stop p e) (stop p' e'))
           (Some (join (pred j) p'))
           (stop p' (ss e e')).
#[export] Hint Constructors step : core.

(** A step preserves place. *)

Lemma step_pl_eq:
  forall st0 ev st1,
    step st0 ev st1 -> pl st0 = pl st1.
Proof.
  intros.
  induction H; simpl; auto.
Qed.

(** A step preserves evidence. *)

Lemma step_seval:
  forall st0 ev st1,
    step st0 ev st1 ->
    seval st0 = seval st1.
Proof.
  intros.
  induction H; simpl; auto; try rewrite IHstep; auto.
  apply step_pl_eq in H. rewrite H; auto.
Qed.

(** * Transitive Closures *)

Inductive lstar: St -> list Ev -> St -> Prop :=
| lstar_refl: forall st, lstar st [] st
| lstar_tran: forall st0 e st1 tr st2,
    step st0 (Some e) st1 -> lstar st1 tr st2 -> lstar st0 (e :: tr) st2
| lstar_silent_tran: forall st0 st1 tr st2,
    step st0 None st1 -> lstar st1 tr st2 -> lstar st0 tr st2.
#[export] Hint Resolve lstar_refl : core.

Lemma lstar_transitive:
  forall st0 tr0 st1 tr1 st2,
    lstar st0 tr0 st1 ->
    lstar st1 tr1 st2 ->
    lstar st0 (tr0 ++ tr1) st2.
Proof.
  intros.
  induction H.
  - rewrite app_nil_l; auto.
  - apply IHlstar in H0.
    rewrite <- app_comm_cons.
    eapply lstar_tran; eauto.
  - apply IHlstar in H0.
    eapply lstar_silent_tran; eauto.
Qed.

(** Transitive closure without labels. *)

Inductive star: St -> St -> Prop :=
| star_refl: forall st, star st st
| star_tran: forall st0 e st1 st2,
    step st0 e st1 -> star st1 st2 -> star st0 st2.
#[export] Hint Resolve star_refl : core.

Lemma star_transitive:
  forall st0 st1 st2,
    star st0 st1 ->
    star st1 st2 ->
    star st0 st2.
Proof.
  intros.
  induction H; auto.
  apply IHstar in H0.
  eapply star_tran; eauto.
Qed.

Lemma lstar_star:
  forall st0 tr st1,
    lstar st0 tr st1 -> star st0 st1.
Proof.
  intros.
  induction H; auto;
    eapply star_tran; eauto.
Qed.

Lemma star_lstar:
  forall st0 st1,
    star st0 st1 -> exists tr, lstar st0 tr st1.
Proof.
  intros.
  induction H; auto.
  - exists []; auto.
  - destruct IHstar as [tr G].
    destruct e.
    + exists (e :: tr).
      eapply lstar_tran; eauto.
    + exists tr.
      eapply lstar_silent_tran; eauto.
Qed.

Lemma star_seval:
  forall st0 st1,
    star st0 st1 -> seval st0 = seval st1.
Proof.
  intros.
  induction H; auto.
  apply step_seval in H; auto.
  rewrite H; auto.
Qed.

Lemma steps_preserves_eval:
  forall t p p' e0 e1,
    star (conf t p e0) (stop p' e1) ->
    aeval t p e0 = e1.
Proof.
  intros.
  apply star_seval in H.
  simpl in H; auto.
Qed.

(** * Correct Path Exists *)

Lemma star_strem:
  forall st0 st1 j p,
    star st0 st1 -> star (rem j p st0) (rem j p st1).
Proof.
  intros.
  induction H; auto.
  eapply star_tran; eauto.
Qed.

Lemma star_stls:
  forall st0 st1 t,
    star st0 st1 -> star (ls st0 t) (ls st1 t).
Proof.
  intros.
  induction H; auto.
  eapply star_tran; eauto.
Qed.


Lemma star_stbsl:
  forall st0 st1 j t p e,
    star st0 st1 ->
    star (bsl j st0 t p e) (bsl j st1 t p e).
Proof.
  intros.
  induction H; auto.
  eapply star_tran; eauto.
Qed.

Lemma star_stbsr:
  forall st0 st1 j e,
    star st0 st1 ->
    star (bsr j e st0) (bsr j e st1).
Proof.
  intros.
  induction H; auto.
  eapply star_tran; eauto.
Qed.

(* Congruence lemmas for Copland LTS semantics *)
Lemma lstar_stls :
  forall st0 st1 t tr,
    lstar st0 tr st1 -> lstar (ls st0 t) tr (ls st1 t).
Proof.
  intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.
Qed.

Lemma lstar_strem : forall st st' tr p r,
    lstar st tr
          st' ->
    lstar (rem r p st) tr (rem r p st').
Proof.
  intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.
Defined.


Lemma lstar_stbsl:
  forall st0 st1 j t p e tr,
    lstar st0 tr st1 ->
    lstar (bsl j st0 t p e) tr (bsl j st1 t p e).
Proof.
  intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.
Defined.

Lemma lstar_stbsr:
  forall st0 st1 j e tr,
    lstar st0 tr st1 ->
    lstar (bsr j e st0) tr (bsr j e st1).
Proof.
  intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.
Defined.

Lemma lstar_stbparl:
  forall st0 st1 st2 j tr,
    lstar st0 tr st1 ->
    lstar (bp j st0 st2) tr (bp j st1 st2).
Proof.
  intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.
Defined.

Lemma lstar_stbparr:
  forall st0 st1 st2 j tr,
    lstar st1 tr st2 ->
    lstar (bp j st0 st1) tr (bp j st0 st2).
Proof.
  intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.
Defined.

Lemma star_stbp:
  forall st0 st1 st2 st3 j,
    star st0 st1 ->
    star st2 st3 ->
    star (bp j st0 st2) (bp j st1 st3).
Proof.
  intros.
  induction H; auto.
  - induction H0; auto.
    eapply star_tran; eauto.
  - eapply star_tran; eauto.
Qed.

Theorem correct_path_exists:
  forall t p e,
    star (conf t p e) (stop p (aeval t p e)).
Proof.
  induction t; intros; simpl; eauto.
  - eapply star_tran; eauto.
  - (* destruct p. *)
    eapply star_tran; eauto.
    eapply star_transitive.
    apply star_strem.
    apply IHt.
    eapply star_tran; eauto.
  - eapply star_tran; eauto.
    eapply star_transitive.
    apply star_stls.
    apply IHt1.
    eapply star_tran; eauto.
    
  - eapply star_tran; eauto.
    eapply star_transitive.
    apply star_stbsl.
    apply IHt1.
    eapply star_tran; eauto.
    eapply star_transitive.
    apply star_stbsr.
    apply IHt2.
    eapply star_tran; eauto.
    
  -
    repeat dest_range.
    (*destruct p; destruct p0. *)
    eapply star_tran; eauto.
    eapply star_transitive.
    apply star_stbp.
    apply IHt1.
    apply IHt2.
    eapply star_tran; eauto.
Qed.

(** * Progress *)

Definition halt st :=
  match st with
  | stop _ _ => True
  | _ => False
  end.

(** The step relation nevers gets stuck. *)

Theorem never_stuck:
  forall st0,
    halt st0 \/ exists e st1, step st0 e st1.
Proof.
  induction st0.
  - left; simpl; auto.
  - right.
    destruct a.
    + exists (Some (asp_event (fst r) a p e)).
      eapply ex_intro; eauto.
    + exists (Some (req (fst r) p p0 (unanno a) e)).
      repeat dest_range.
      eapply ex_intro; eauto.
    + exists None.
      eapply ex_intro; eauto.
      
    + exists (Some (split (fst r) p)).
      eapply ex_intro; eauto.
      
    + exists (Some (Term_Defs.split(fst r) p)).
      (*destruct p; destruct p0. *)
      repeat dest_range.
      eapply ex_intro; eauto.
  -
    right.
    destruct IHst0.
    + destruct st0; simpl in H; try tauto.
      exists (Some (rpy (pred n) p p0 e)).
      eapply ex_intro; eauto.
    + destruct H as [e H].
      exists e.
      destruct H as [st1 H].
      exists (rem n p st1); auto.
  -
    right.
    destruct IHst0.
    + destruct st0; simpl in H; try tauto.
      exists None. eapply ex_intro; eauto.
    + destruct H as [e H].
      exists e.
      destruct H as [st H].
      exists (ls st a). auto.
          
  -
    right.
    destruct IHst0.
    + destruct st0; simpl in H; try tauto.
      exists None. eapply ex_intro; eauto.
    + destruct H as [e0 H].
      exists e0.
      destruct H as [st H].
      exists (bsl n st a p e). auto.
  - right.
    destruct IHst0.
    + destruct st0; simpl in H; try tauto.
      exists (Some (join (pred n) p)).
      eapply ex_intro; eauto.
    + destruct H as [e0 H].
      exists e0.
      destruct H as [st H].
      exists (bsr n e st). auto.
         
  - right.
    destruct IHst0_1 as [H|H].
    + destruct st0_1; simpl in H; try tauto.
      clear H.
      destruct IHst0_2.
      * destruct st0_2; simpl in H; try tauto.
        exists (Some (join (pred n) p0)).
        eapply ex_intro; eauto.
      * destruct H as [e0 H].
        exists e0.
        destruct H as [st H].
        exists (bp n (stop p e) st). auto.
    + destruct H as [e0 H].
      exists e0.
      destruct H as [st H].
      exists (bp n st st0_2). auto.
Qed.

(** * Termination *)

Inductive nstar: nat -> St -> St -> Prop :=
| nstar_refl: forall st, nstar 0 st st
| nstar_tran: forall st0 st1 st2 e n,
    nstar n st0 st1 -> step st1 e st2 -> nstar (S n) st0 st2.
#[export] Hint Resolve nstar_refl : core.

Lemma nstar_transitive:
  forall m n st0 st1 st2,
    nstar m st0 st1 ->
    nstar n st1 st2 ->
    nstar (m + n) st0 st2.
Proof.
  intros.
  induction H0.
  rewrite Nat.add_0_r; auto.
  apply IHnstar in H.
  eapply nstar_tran in H; eauto.
  rewrite plus_n_Sm in H.
  eauto.
Qed.

Lemma nstar_star:
  forall n st0 st1,
    nstar n st0 st1 -> star st0 st1.
Proof.
  intros.
  induction H; auto.
  eapply star_transitive; eauto.
  eapply star_tran; eauto.
Qed.

Lemma star_nstar:
  forall st0 st1,
    star st0 st1 ->
    exists n, nstar n st0 st1.
Proof.
  intros.
  induction H.
  - exists 0; auto.
  - destruct IHstar as [n G].
    exists (S n).
    rewrite <- Nat.add_1_l.
    eapply nstar_transitive; eauto.
    eapply nstar_tran; eauto.
Qed.

(** Size of a term (number of steps to reduce). *)

Fixpoint tsize t: nat :=
  match t with
  | aasp _ _ => 1
  | aatt _ _ x => 2 + tsize x
  | alseq _ x y => 2 + tsize x + tsize y
  | abseq _ _ x y => 3 + tsize x + tsize y
  | abpar _ _ x y => 2 + tsize x + tsize y
  end.

(** Size of a state (number of steps to reduce). *)

Fixpoint ssize s: nat :=
  match s with
  | stop _ _ => 0
  | conf t _ _ => tsize t
  | rem _ _ x => 1 + ssize x
  | ls x t => 1 + ssize x + tsize t
  | bsl _ x t _ _ => 2 + ssize x + tsize t
  | bsr _ _ x => 1 + ssize x
  | bp _ x y => 1 + ssize x + ssize y
  end.

(** Halt state has size 0. *)

Lemma halt_size:
  forall st,
    halt st <-> ssize st = 0.
Proof.
  split; intros.
  - destruct st; simpl in H; try tauto.
  - destruct st; simpl in H; try tauto;
      try discriminate.
    + simpl; auto.
    + destruct a; simpl in H; discriminate.
Qed.

(** A state decreases its size by one. *)

Lemma step_size:
  forall st0 e st1,
    step st0 e st1 ->
    S (ssize st1) = ssize st0.
Proof.
  intros.
  induction H; simpl; auto; lia.
Qed.

Lemma step_count:
  forall n t p e st,
    nstar n (conf t p e) st ->
    tsize t = n + ssize st.
Proof.
  induction n; intros.
  - inv H; simpl; auto.
  - inv H.
    apply IHn in H1.
    rewrite H1.
    apply step_size in H2.
    lia.
Qed.

(** Every run terminates. *)

Theorem steps_to_stop:
  forall t p e st,
    nstar (tsize t) (conf t p e) st ->
    halt st.
Proof.
  intros.
  apply step_count in H.
  apply halt_size.
  lia.
Qed.

(** * Numbered Labeled Transitions *)

Inductive nlstar: nat -> St -> list Ev -> St -> Prop :=
| nlstar_refl: forall st, nlstar 0 st [] st
| nlstar_tran: forall n st0 e st1 tr st2,
    step st0 (Some e) st1 -> nlstar n st1 tr st2 -> nlstar (S n) st0 (e :: tr) st2
| nlstar_silent_tran: forall n st0 st1 tr st2,
    step st0 None st1 -> nlstar n st1 tr st2 -> nlstar (S n) st0 tr st2.
#[export] Hint Resolve nlstar_refl : core.

Lemma nlstar_transitive:
  forall m n st0 tr0 st1 tr1 st2,
    nlstar m st0 tr0 st1 ->
    nlstar n st1 tr1 st2 ->
    nlstar (m + n) st0 (tr0 ++ tr1) st2.
Proof.
  intros.
  induction H.
  - rewrite app_nil_l; auto.
  - apply IHnlstar in H0.
    rewrite <- app_comm_cons.
    eapply nlstar_tran; eauto.
  - apply IHnlstar in H0.
    eapply nlstar_silent_tran; eauto.
Qed.

Lemma nlstar_lstar:
  forall n st0 tr st1,
    nlstar n st0 tr st1 -> lstar st0 tr st1.
Proof.
  intros.
  induction H; auto.
  - eapply lstar_tran; eauto.
  - eapply lstar_silent_tran; eauto.
Qed.

Lemma lstar_nlstar:
  forall st0 tr st1,
    lstar st0 tr st1 ->
    exists n, nlstar n st0 tr st1.
Proof.
  intros.
  induction H.
  - exists 0; auto.
  - destruct IHlstar as [n G].
    exists (S n).
    eapply nlstar_tran; eauto.
  - destruct IHlstar as [n G].
    exists (S n).
    eapply nlstar_silent_tran; eauto.
Qed.

Lemma nlstar_step_size:
  forall n st0 tr st1,
    nlstar n st0 tr st1 ->
    ssize st1 <= ssize st0.
Proof.
  intros.
  induction H; auto;
    apply step_size in H;
    lia.
Qed.

Lemma lstar_nlstar_size:
  forall st0 tr st1,
    lstar st0 tr st1 ->
    nlstar (ssize st0 - ssize st1) st0 tr st1.
Proof.
  intros.
  induction H.
  - rewrite Nat.sub_diag; auto.
  - pose proof H as G.
    apply step_size in G.
    rewrite <- G.
    rewrite <- minus_Sn_m.
    + eapply nlstar_tran; eauto.
    + apply nlstar_step_size in IHlstar; auto.
  - pose proof H as G.
    apply step_size in G.
    rewrite <- G.
    rewrite <- minus_Sn_m.
    + eapply nlstar_silent_tran; eauto.
    + apply nlstar_step_size in IHlstar; auto.
Qed.

(** The reverse version of [nlstar]. *)

Inductive rlstar: nat -> St -> list Ev -> St -> Prop :=
| rlstar_refl: forall st, rlstar 0 st [] st
| rlstar_tran: forall n st0 e st1 tr st2,
    rlstar n st0 tr st1 -> step st1 (Some e) st2 ->
    rlstar (S n) st0 (tr ++ [e]) st2
| rlstar_silent_tran: forall n st0 st1 tr st2,
    rlstar n st0 tr st1 -> step st1 None st2 ->
    rlstar (S n) st0 tr st2.
#[export] Hint Resolve rlstar_refl : core.

Lemma rlstar_transitive:
  forall m n st0 tr0 st1 tr1 st2,
    rlstar m st0 tr0 st1 ->
    rlstar n st1 tr1 st2 ->
    rlstar (m + n) st0 (tr0 ++ tr1) st2.
Proof.
  intros.
  induction H0.
  - rewrite Nat.add_0_r; rewrite app_nil_r; simpl; auto.
  - apply IHrlstar in H.
    rewrite Nat.add_succ_r.
    rewrite app_assoc.
    eapply rlstar_tran; eauto.
  - apply IHrlstar in H.
    rewrite Nat.add_succ_r.
    eapply rlstar_silent_tran; eauto.
Qed.

Lemma rlstar_lstar:
  forall n st0 tr st1,
    rlstar n st0 tr st1 -> lstar st0 tr st1.
Proof.
  intros.
  induction H; auto.
  - eapply lstar_transitive; eauto.
    eapply lstar_tran; eauto.
  - rewrite <- app_nil_r with (l:=tr).
    eapply lstar_transitive; eauto.
    apply lstar_silent_tran with st2; auto.
Qed.

Lemma lstar_rlstar:
  forall st0 tr st1,
    lstar st0 tr st1 ->
    exists n, rlstar n st0 tr st1.
Proof.
  intros.
  induction H.
  - exists 0; auto.
  - destruct IHlstar as [n G].
    exists (S n).
    cut (rlstar (1 + n) st0 ([e] ++ tr) st2).
    simpl; auto.
    eapply rlstar_transitive; eauto.
    cut (rlstar 1 st0 ([] ++ [e]) st1).
    simpl; auto.
    eapply rlstar_tran; eauto.
  - destruct IHlstar as [n G].
    exists (S n).
    cut (rlstar (1 + n) st0 ([] ++ tr) st2).
    rewrite app_nil_l; auto.
    eapply rlstar_transitive; eauto.
    eapply rlstar_silent_tran; eauto.
Qed.

Lemma rlstar_nlstar:
  forall n st0 tr st1,
    rlstar n st0 tr st1 <-> nlstar n st0 tr st1.
Proof.
  split; intros.
  - induction H; auto.
    + rewrite <- Nat.add_1_r.
      eapply nlstar_transitive; eauto.
      eapply nlstar_tran; eauto.
    + rewrite <- Nat.add_1_r.
      rewrite <- app_nil_r with (l:=tr).
      eapply nlstar_transitive; eauto.
      eapply nlstar_silent_tran; eauto.
  - induction H; auto.
    + rewrite <- Nat.add_1_l.
      assert (G: e :: tr = [e] ++ tr).
      simpl; auto.
      rewrite G.
      eapply rlstar_transitive; eauto.
      rewrite <- app_nil_l with (l:=[e]).
      eapply rlstar_tran; eauto.
    + rewrite <- Nat.add_1_l.
      rewrite <- app_nil_l with (l:=tr).
      eapply rlstar_transitive; eauto.
      eapply rlstar_silent_tran in H; eauto.
Qed.
(*  This file contains structural lemmas about well-formedness of annotated 
    phrases and their ranges, associated automation, the `events` relation 
    --a denotational semantics for phrase events, and lemmas/automation related 
    to `events` *)

Require Import Defs Eqb_Evidence.
Require Import Preamble More_lists StructTactics.

Require Import Compare_dec Coq.Program.Tactics.
Require Import PeanoNat.

Require Import Lia.

Require Import List.
Import List.ListNotations.

Require Export Term_Defs Anno_Term_Defs.

(*
Set Nested Proofs Allowed.
*)

Lemma wfr_lseq_pieces: forall r t1 t2,
    well_formed_r_annt (alseq r t1 t2) ->
    well_formed_r_annt t1 /\ well_formed_r_annt t2.
Proof.
  intros.
  inversion H.
  tauto.
Defined.

Lemma wfr_at_pieces: forall t r p,
    well_formed_r_annt (aatt r p t) ->
    well_formed_r_annt t.
Proof.
  intros.
  inversion H.
  tauto.
Defined.

Lemma wfr_bseq_pieces: forall r s t1 t2,
    well_formed_r_annt (abseq r s t1 t2) ->
    well_formed_r_annt t1 /\ well_formed_r_annt t2.
Proof.
  intros.
  inversion H.
  tauto.
Defined.

Lemma wfr_bpar_pieces: forall r s t1 t2,
    well_formed_r_annt (abpar r s t1 t2) ->
    well_formed_r_annt t1 /\ well_formed_r_annt t2.
Proof.
  intros.
  inversion H.
  tauto.
Defined.

Ltac do_wf_pieces :=
  match goal with
  | [H: well_formed_r_annt (alseq _ _ _ ) |- _] =>
    (edestruct wfr_lseq_pieces; eauto)
  | [H: well_formed_r_annt (aatt _ _?t) |- _] =>   
    assert (well_formed_r_annt t)
      by (eapply wfr_at_pieces; eauto)
  | [H: well_formed_r_annt (abseq _ _ _ _) |- _] =>
    (edestruct wfr_bseq_pieces; eauto)
  | [H: well_formed_r_annt (abpar _ _ _ _) |- _] =>
    (edestruct wfr_bpar_pieces; eauto)
  end.


Lemma well_formed_range_r:
  forall t,
    well_formed_r_annt t ->
    snd (range t) = fst (range t) + esize t.
Proof.
    induction t;
    try (intros H; simpl; inv H; simpl;
         repeat find_apply_hyp_hyp; lia).
Defined.

Lemma esize_nonempty: forall t, esize t > 0.
Proof.
  intros.
  induction t; intros;
    try (destruct a);
    (cbn; lia).
Defined.

Lemma wf_mono: forall t,
    well_formed_r_annt t ->
    snd (range t) > fst (range t).
Proof.
  intros.
  rewrite well_formed_range_r.
  pose (esize_nonempty t).
  lia.
  eauto.
Defined.

Ltac do_mono :=
  (* let asdff := eapply anno_mono; eauto in *)
  match goal with
  | [H: anno _ ?x _ _ = Some (?y,_) |- _] => assert_new_proof_by (y > x) ltac:(eapply anno_mono; eauto)
  end.

Lemma asp_lrange_irrel: forall a i a0 a1 n n',
    anno (asp a) i = (n, a0) ->
    anno (asp a) i = (n',a1) ->
    a0 = a1.
Proof.
  intros.
  destruct a; ff.
Defined.

(** This predicate specifies when a term, a place, and some initial
    evidence is related to an event.  In other words, it specifies the
    set of events associated with a term, a place, and some initial
    evidence. *)

Inductive events: AnnoTerm -> Plc -> Evidence -> Ev -> Prop :=
| evtsnull:
    forall r i p e,
      fst r = i ->
      events (aasp r NULL) p e (null i p)
| evtscpy:
    forall r i p e,
      fst r = i ->
      events (aasp r CPY) p e (copy i p)
| evtsusm:
    forall i r p e sp fwd ps,
      fst r = i ->
      events (aasp r (ASPC sp fwd ps)) p e (umeas i p ps (sp_ev sp e))
| evtssig:
    forall r i p e,
      fst r = i ->
      events (aasp r SIG) p e (umeas i p sig_params e) (* (sign i p e) *)
| evtshsh:
    forall r i p e,
      fst r = i ->
      events (aasp r HSH) p e (umeas i p hsh_params e) (* (hash i p e) *)
| evtsenc:
    forall r i p q e,
      fst r = i ->
      events (aasp r (ENC q)) p e (umeas i p (enc_params q) e) (* (hash i p e) *)
| evtsattreq:
    forall r q t i p e,
      fst r = i ->
      events (aatt r q t) p e (req i p q (unanno t) e)
| evtsatt:
    forall r q t ev p e,
      events t q e ev ->
      events (aatt r q t) p e ev
| evtsattrpy:
    forall r q t i p e,
      snd r = S i ->
      events (aatt r q t) p e (rpy i p q (aeval t q e))
| evtslseql:
    forall r t1 t2 ev p e,
      events t1 p e ev ->
      events (alseq r t1 t2) p e ev
| evtslseqr:
    forall r t1 t2 ev p e,
      events t2 p (aeval t1 p e) ev ->
      events (alseq r t1 t2) p e ev
             
| evtsbseqsplit:
    forall r i s e t1 t2 p,
      fst r = i ->
      events (abseq r s t1 t2) p e (Term_Defs.split i p)
| evtsbseql:
    forall r s e t1 t2 ev p,
      events t1 p (splitEv_T_l s e) ev ->
      events (abseq r s t1 t2) p e ev
| evtsbseqr:
    forall r s e t1 t2 ev p,
      events t2 p (splitEv_T_r s e) ev ->
      events (abseq r s t1 t2) p e ev
| evtsbseqjoin:
    forall r i s e t1 t2 p,
      snd r = S i ->
      events (abseq r s t1 t2) p e (join i p)

| evtsbparsplit:
    forall r i s e t1 t2 p,
      fst r = i ->
      events (abpar r s t1 t2) p e
             (Term_Defs.split i p)
| evtsbparl:
    forall r s e t1 t2 ev p,
      events t1 p (splitEv_T_l s e) ev ->
      events (abpar r s t1 t2) p e ev
| evtsbparr:
    forall r s e t1 t2 ev p,
      events t2 p (splitEv_T_r s e) ev ->
      events (abpar r s t1 t2) p e ev
| evtsbparjoin:
    forall r i s e t1 t2 p,
      snd r = S i ->
      events (abpar r s t1 t2) p e
             (join i  p).
#[export] Hint Constructors events : core.

Ltac inv_events :=
  match goal with
  | [H:events (?C _) _ _ _ |- _] => inv H
  end.

Ltac inv_wfr :=
  match goal with
  | [H: well_formed_r_annt _ |- _] => inv H
  end.

Lemma events_range:
  forall t v p e,
    well_formed_r_annt t ->
    events t p e v ->
    fst (range t) <= ev v < snd (range t).
Proof.
  intros t v p e H H0.
  pose proof H as G.
  apply well_formed_range_r in G.
  rewrite G.
  clear G.
  induction H0;
    try (inv_wfr; simpl in *; auto;
         repeat find_apply_hyp_hyp;
         repeat (find_apply_lem_hyp well_formed_range_r); lia).
Defined.

Lemma at_range:
  forall x r i,
    S (fst r) = fst x ->
    snd r = S (snd x) ->
    fst r <= i < snd r ->
    i = fst r \/
    fst x <= i < snd x \/
    i = snd x.
Proof.
  intros.
  pose proof lt_dec i (S (fst r)) as G.
  destruct G as [G|G]; [left; lia| right].
  pose proof lt_dec i (snd x) as F.
  destruct F as [F|F]; [left; lia| right].
  lia.
Qed.

Lemma lin_range:
  forall x y i,
    snd x = fst y ->
    fst x <= i < snd y ->
    fst x <= i < snd x \/
    fst y <= i < snd y.
Proof.
  intros.
  pose proof lt_dec i (snd x) as G.
  destruct G; lia.
Qed.

Lemma bra_range:
  forall x y r i,
    S (fst r) = fst x ->
    snd x = fst y ->
    snd r = S (snd y) ->
    fst r <= i < snd r ->
    i = fst r \/
    fst x <= i < snd x \/
    fst y <= i < snd y \/
    i = snd y.
Proof.
  intros.
  pose proof lt_dec i (S (fst r)) as G.
  destruct G as [G|G]; [left; lia| right].
  pose proof lt_dec i (snd x) as F.
  destruct F as [F|F]; [left; lia| right].
  pose proof lt_dec i (snd y) as E.
  destruct E; lia.
Qed.

Ltac dest_range :=
  match goal with
  | [H: (nat * nat) |- _] => destruct H
  end.

Ltac do_lin_range :=
  match goal with
  | [H: snd _ = fst _,
        H': fst _ <= ?n < snd _
     |- _] =>
    apply lin_range with (i:=n) in H; eauto
  end.

Ltac do_bra_range :=
  match goal with
  | [H: snd _ = fst _,
        H': fst ?x <= ?n < snd ?x
     |- _] =>
    apply bra_range with (i:=n) (r:=x) in H; eauto
  end.

(** Properties of events. *)

Lemma events_range_event:
  forall t p i e,
    well_formed_r_annt t ->
    fst (range t) <= i < snd (range t) ->
    exists v, events t p e v /\ ev v = i.
Proof.
  intros t p i e H; revert i; revert p; revert e.
  induction H; intros; simpl in *.
  - destruct x; try destruct a; eapply ex_intro; split; auto;
      (*destruct r as [j k];*) simpl in *; try lia.
    (*
    + admit.
    + *)
      
  - find_eapply_lem_hyp at_range; eauto.
    repeat destruct_disjunct; subst; eauto.
    (* + eapply ex_intro; split; auto. *)

    find_eapply_hyp_hyp.
    (*apply IHwell_formed with (p:=p) in H2. *)
    destruct_conjs.
    eauto.
  -
    do_lin_range;       
      eauto;
      repeat destruct_disjunct;
      try lia;
      try (find_eapply_hyp_hyp; eauto;
           destruct_conjs;
           eauto).  
  -
    do_bra_range;
      eauto;
      repeat destruct_disjunct; subst;
        try lia;
        try (find_eapply_hyp_hyp; eauto;
             destruct_conjs;
             eauto; tauto).
    

    + eapply ex_intro; split; try (auto; eauto;tauto).
    + eapply ex_intro; split; try (eauto; auto; tauto).
      
  -
    do_bra_range;
      eauto;
      repeat destruct_disjunct; subst;
        try lia;
        try (find_eapply_hyp_hyp; eauto;
             destruct_conjs;
             eauto; tauto).

    + eapply ex_intro; split; auto.
    + eapply ex_intro; split; eauto.
Qed.

Ltac events_event_range :=
  repeat match goal with
         | [ H: events _ _ _ _ |- _ ] =>
           apply events_range in H; auto
         end; lia.

Ltac aba :=
  match goal with
  | [H: events _ _ _ _, H': events _ _ _ _ |- _] => inv H; inv H'
  end.

Ltac wfr :=
  match goal with
  | [H': well_formed_r_annt ?HH |- _] => pose_new_proof (well_formed_range_r HH H')
  end.

Lemma events_injective:
  forall t p e v1 v2,
    well_formed_r_annt t ->
    events t p e v1 ->
    events t p e v2 ->
    ev v1 = ev v2 ->
    v1 = v2.
Proof.
  intros.
  generalizeEverythingElse H.
  induction H; intros;
    try (
        repeat wfr;
        aba; simpl in *; subst; auto;
        try (events_event_range; tauto);
        try (find_eapply_hyp_hyp; eauto);
        eauto).
Qed.
Require Import Term_Defs OptMonad_Coq BS Preamble.
Require Import StructTactics Defs.


Require Import Lia Coq.Program.Tactics.
Require Import List.
Import List.ListNotations.


(** * Annotated Terms

    Annotated terms are used to ensure that each distinct event has a
    distinct natural number.  To do so, each term is annotated by a
    pair of numbers called a range.  Let [(i, k)] be the label for
    term [t].  The labels will be chosen to have the property such
    that for each event in the set of events associated with term [t],
    its number [j] will be in the range [i <= j < k].  *)

Definition Range: Set := nat * nat.

Inductive AnnoTerm: Set :=
| aasp: Range -> ASP -> AnnoTerm
| aatt: Range -> Plc -> AnnoTerm -> AnnoTerm
| alseq: Range -> AnnoTerm -> AnnoTerm -> AnnoTerm
| abseq: Range -> Split -> AnnoTerm -> AnnoTerm -> AnnoTerm
| abpar: Range -> Split -> AnnoTerm -> AnnoTerm -> AnnoTerm.

(* Evidence Type size *)
Fixpoint esize t :=
  match t with
  | aasp _ _ => 1
  | aatt _ _ t1 => 2 + esize t1
  | alseq _ t1 t2 => esize t1 + esize t2
  | abseq _ _ t1 t2 => 2 + esize t1 + esize t2
  | abpar _ _ t1 t2 => 2 + esize t1 + esize t2
  end.

(* Extract Range from each annotated term *)
Definition range x :=
  match x with
  | aasp r _ => r
  | aatt r _ _ => r
  | alseq r _ _ => r
  | abseq r _ _ _ => r
  | abpar r _ _ _ => r
  end.

(* Term subset relation *)
Inductive term_sub : Term -> Term -> Prop :=
| termsub_refl_annt: forall t: Term, term_sub t t
| aatt_sub_annt: forall t t' p,
    term_sub t' t ->
    term_sub t' (att p t)
| alseq_subl_annt: forall t' t1 t2,
    term_sub t' t1 ->
    term_sub t' (lseq t1 t2)
| alseq_subr_annt: forall t' t1 t2,
    term_sub t' t2 ->
    term_sub t' (lseq t1 t2)
| abseq_subl_annt: forall t' t1 t2 s,
    term_sub t' t1 ->
    term_sub t' (bseq s t1 t2)
| abseq_subr_annt: forall t' t1 t2 s,
    term_sub t' t2 ->
    term_sub t' (bseq s t1 t2)
| abpar_subl_annt: forall t' t1 t2 s,
    term_sub t' t1 ->
    term_sub t' (bpar s t1 t2)
| abpar_subr_annt: forall t' t1 t2 s,
    term_sub t' t2 ->
    term_sub t' (bpar s t1 t2).
#[export] Hint Constructors term_sub : core.

Lemma termsub_transitive: forall t t' t'',
    term_sub t t' ->
    term_sub t' t'' ->
    term_sub t t''.
Proof.  
  generalizeEverythingElse t''.
  induction t'';
    intros H H0; ff.
Defined.

(** This function annotates a term.  It feeds a natural number
    throughout the computation so as to ensure each event has a unique
    natural number. *)
Fixpoint anno (t: Term) (i:nat) : (nat * AnnoTerm) :=
  match t with
  | asp x => (S i, (aasp (i, S i) x))

  | att p x =>
    let '(j,a) := anno x (S i)  in
    (S j, aatt (i, S j) p a)

  | lseq x y =>
    let '(j,a) := anno x i in
    let '(k,bt) := anno y j in
    (k, alseq (i, k) a bt)

  | bseq s x y =>
    let '(j,a) := anno x (S i) in
    let '(k,b) := anno y j in
    (S k, abseq (i, S k) s a b)

  | bpar s x y =>
    let '(j,a) := anno x (S i) in
    let '(k,b) := anno y j in
    (S k, abpar (i, S k) s a b)
  end.

Definition annotated x :=
  snd (anno x 0).

Fixpoint unanno a :=
  match a with
  | aasp _ a => asp a
  | aatt _ p t => att p (unanno t)
  | alseq _ a1 a2 => lseq (unanno a1) (unanno a2)                 
  | abseq _ spl a1 a2 => bseq spl (unanno a1) (unanno a2) 
  | abpar _ spl a1 a2 => bpar spl (unanno a1) (unanno a2)
  end.

Lemma anno_unanno: forall t i,
    unanno (snd (anno t i)) = t.
Proof.
  intros.
  generalizeEverythingElse t.
  induction t; intros.
  -
    destruct a; ff.
  -
    ff.
    erewrite <- IHt.
    jkjke.
  -
    ff.
    erewrite <- IHt1.
    erewrite <- IHt2.
    jkjke.
    jkjke.
  -
    ff.
    erewrite <- IHt1.
    erewrite <- IHt2.
    jkjke.
    jkjke.
  -
    ff.
    erewrite <- IHt1.
    erewrite <- IHt2.
    jkjke.
    jkjke.
Defined.

(* Propositional versions of anno function equalities *)
Inductive annoP: AnnoTerm -> Term -> Prop :=
| annoP_c: forall anno_term t,
    (exists n n', anno t n = (n',anno_term)) -> (* anno_term = snd (anno t n)) -> *)
    annoP anno_term t.

Inductive annoP_indexed': AnnoTerm -> Term -> nat -> Prop :=
| annoP_c_i': forall anno_term t n,
    (exists n', anno t n = (n', anno_term)) -> (*anno_term = snd (anno t n) -> *)
    annoP_indexed' anno_term t n.

Inductive annoP_indexed: AnnoTerm -> Term -> nat -> nat ->  Prop :=
| annoP_c_i: forall anno_term t n n',
    (*(exists n', anno t n = (n', anno_term)) -> (*anno_term = snd (anno t n) -> *) *)
    anno t n = (n', anno_term) ->
    annoP_indexed anno_term t n n'.


(** eval (evidence semantics) for annotated terms. *)

Fixpoint aeval t p e :=
  match t with
  | aasp _ x => eval (asp x) p e
  | aatt _ q x => aeval x q e
  | alseq _ t1 t2 => aeval t2 p (aeval t1 p e)
  | abseq _ s t1 t2 => ss (aeval t1 p ((splitEv_T_l s e)))
                         (aeval t2 p ((splitEv_T_r s e)))
  | abpar _ s t1 t2 => ss (aeval t1 p ((splitEv_T_l s e)))
                         (aeval t2 p ((splitEv_T_r s e)))
  end.

Lemma eval_aeval:
  forall t p e i,
    eval t p e = aeval (snd (anno t i)) p e.
Proof.
  induction t; intros; simpl; auto;
    repeat expand_let_pairs; simpl;
      try (repeat jkjk; auto;congruence);
      try (repeat jkjk'; auto).
Defined.


(** This predicate determines if an annotated term is well formed,
    that is if its ranges correctly capture the relations between a
    term and its associated events. *)
Inductive well_formed_r_annt: AnnoTerm -> Prop :=
| wf_asp_r_annt: forall r x,
    snd r = S (fst r) ->
    well_formed_r_annt (aasp r x)
| wf_att_r_annt: forall r p x,
    well_formed_r_annt x ->
    S (fst r) = fst (range x) ->
    snd r = S (snd (range x)) ->
    Nat.pred (snd r) > fst r ->
    well_formed_r_annt (aatt r p x)               
| wf_lseq_r_annt: forall r x y,
    well_formed_r_annt x -> well_formed_r_annt y ->
    fst r = fst (range x) ->
    snd (range x) = fst (range y) ->
    snd r = snd (range y) -> 
    well_formed_r_annt (alseq r x y)               
| wf_bseq_r_annt: forall r s x y,
    well_formed_r_annt x -> well_formed_r_annt y ->
    S (fst r) = fst (range x) ->
    snd (range x) = fst (range y) ->
    snd r = S (snd (range y)) ->  
    well_formed_r_annt (abseq r s x y)              
| wf_bpar_r_annt: forall r s x y,
    well_formed_r_annt x -> well_formed_r_annt y ->  
    S (fst r) = fst (range x) ->
    snd (range x) = fst (range y) ->
    (snd r) = S (snd (range y)) ->
    (*fst (range y) > fst (range x) -> *)
    well_formed_r_annt (abpar r s x y).
#[export] Hint Constructors well_formed_r_annt : core.


Lemma same_anno_range: forall t i a b n n',
    anno t i = (n,a) ->
    anno t i = (n',b) ->
    n = n'.
Proof.
  intros.
  generalizeEverythingElse t.
  induction t; intros;
    try destruct a;
    ff.
Defined.
  
Lemma anno_mono : forall (t:Term) (i j:nat) (t':AnnoTerm),
  anno t i = (j,t') ->
  j > i.
Proof.
  induction t; intros; (*i j t' ls b H; *)
    ff;
    repeat find_apply_hyp_hyp;
    lia.
Defined.
#[export] Hint Resolve anno_mono : core.

Lemma anno_range:
  forall x i j t',
     anno x i = (j,t') ->
    range (t') = (i, j).
Proof.
  induction x; intros; ff.
Defined.


(** Lemma stating that any annotated term produced via anno is well formed *)
Lemma anno_well_formed_r:
  forall t i j t',
    anno t i = (j, t') ->
    well_formed_r_annt t'.
Proof.
  intros.
  generalizeEverythingElse t.
  induction t; intros.
  -
    destruct a;
      ff.
  -
    ff.
    +
      econstructor.
      eauto.
      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

      simpl.
      assert (n > S i) by (eapply anno_mono; eauto).
      lia.
  -
    ff.
    econstructor.
    eauto.
    eauto.

    simpl.
    erewrite anno_range.
    2: {
        eassumption.
      }
    tauto.

    simpl.
    erewrite anno_range.
    2: {
        eassumption.
      }
    erewrite anno_range.
    2: {
        eassumption.
      }
    tauto.

    simpl.
    erewrite anno_range.
    2: {
        eassumption.
      }
    tauto.
      
  -
    ff.
    econstructor.
    eauto.
    eauto.

     simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

  -
    ff.
    econstructor.
    eauto.
    eauto.

     simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      erewrite anno_range.
      2: {
        eassumption.
      }
      
      tauto.
      
      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.     
Defined.

(* Computes the length of the "span" or range of event IDs for a given Term *)
(* TODO: consider changing this to event_id_span_Term *)
Fixpoint event_id_span' (t: Term) : nat :=
  match t with
  | asp x => 1
  | att p x => Nat.add (S (S O)) (event_id_span' x)
  | lseq x y => Nat.add (event_id_span' x) (event_id_span' y)
  | bseq s x y => Nat.add (S (S O)) (Nat.add (event_id_span' x) (event_id_span' y))
  | bpar s x y => Nat.add (S (S O)) (Nat.add (event_id_span' x) (event_id_span' y))
  end.

(* Same as event_id_span', but for Core Terms *)
(* TODO: consider changing this to event_id_span_Core *)
Fixpoint event_id_span (t: Core_Term) : nat :=
  match t with
  | aspc CLEAR =>  O
  | attc _ x => Nat.add (S (S O)) (event_id_span' x)
  | lseqc x y => Nat.add (event_id_span x) (event_id_span y)
  | bseqc x y => Nat.add (S (S O)) (Nat.add (event_id_span x) (event_id_span y))
  | bparc _ x y => Nat.add (S (S O)) (Nat.add (event_id_span x) (event_id_span y))
  | _ => S O
  end.

Lemma event_id_works : forall t,
  event_id_span' t = event_id_span (copland_compile t).
Proof with (simpl in *; eauto).
  induction t...
  - destruct a... destruct s...
  - destruct s, s, s0...
  - destruct s, s, s0...
Qed.


Lemma span_range : forall t i j t',
  anno t i = (j, t') ->
  event_id_span' t = (j - i).
Proof.
  intros.
  generalizeEverythingElse t.
  induction t; intros.
  -
    destruct a;
    try 
    cbn in *;
    find_inversion;
    lia.
  -
    cbn in *.
    repeat break_let.
    find_inversion.
    assert (event_id_span' t = n - (S i)).
    { eauto. }
    rewrite H.
    assert (n > (S i)).
    {
      eapply anno_mono.
      eassumption.
    }
    lia.
  -
    cbn in *.
    repeat break_let.
    repeat find_inversion.
    assert (event_id_span' t1 = (n - i)) by eauto.
    assert (event_id_span' t2 = (j - n)) by eauto.
    repeat jkjke.
    assert (n > i /\ j > n). {
      split; eapply anno_mono; eauto.
    }
    lia.
  -
    cbn in *.
    repeat break_let.
    repeat find_inversion.
    assert (event_id_span' t1 = (n - (S i))) by eauto.
    assert (event_id_span' t2 = (n0 - n)) by eauto.
    repeat jkjke.
    assert (n > S i /\ n0 > n). {
      split; eapply anno_mono; eauto.
    }
    lia.
  -
        cbn in *.
    repeat break_let.
    repeat find_inversion.
    assert (event_id_span' t1 = (n - (S i))) by eauto.
    assert (event_id_span' t2 = (n0 - n)) by eauto.
    repeat jkjke.
    assert (n > S i /\ n0 > n). {
      split; eapply anno_mono; eauto.
    }
    lia.
Defined.
(* Tactics used throughout the proofs *)

(* LICENSE NOTICE

Copyright (c) 2018 The MITRE Corporation.
All Rights Reserved.

This proof script is free software: you can redistribute it and/or
modify it under the terms of the BSD License as published by the
University of California.  See license.txt for details. *)

(** Tactics that provide useful automation. *)

Ltac inv H := inversion H; clear H; subst.

(** Expand let expressions in both the antecedent and the
    conclusion. *)

Ltac expand_let_pairs :=
  match goal with
  | |- context [let (_,_) := ?e in _] =>
    rewrite (surjective_pairing e)
  | [ H: context [let (_,_) := ?e in _] |- _ ] =>
    rewrite (surjective_pairing e) in H
  end.

(** Destruct disjuncts in the antecedent without naming them.  *)

Ltac destruct_disjunct :=
  match goal with
  | [ H: _ \/ _  |- _ ] => destruct H as [H|H]
  end.
(*
General definition of an option monad + monadic notations.
Borrowed/tweaked from:  
https://github.com/uwplse/verdi/blob/master/core/StateMachineHandlerMonad.v

Author:  Adam Petz, ampetz@ku.edu
*)

(* Generalized Option Monad *)
Definition Opt (A : Type) : Type := (option A). (** S % type. *)

Definition ret {A : Type} (a : A) : Opt A := (Some a).

Definition bind {A B : Type} (m : Opt A) (f : A -> Opt B) : Opt B :=
    match m with
    | Some v => f v
    | _ => None
    end.

Definition failm {A : Type} : Opt A := None.

Definition runOpt {A} (h : Opt A) (default: A) : A :=
  match h with
    Some v => v
  | _ => default
  end.

Definition nop := ret tt.

Notation "a >> b" := (bind a (fun _ => b)) (at level 50).

Notation "x <- c1 ;; c2" := (@bind _ _ c1 (fun x => c2))
                              (at level 100, c1 at next level, right associativity).

Notation "e1 ;; e2" := (_ <- e1 ;; e2)
                         (at level 100, right associativity).


Notation "' pat <- c1 ;; c2" :=
    (@bind _ _ c1 (fun x => match x with pat => c2 end))
    (at level 100, pat pattern, c1 at next level, right associativity).

Definition when {A} (b : bool) (m : Opt A) : Opt unit :=
  if b then m ;; ret tt else nop.


Definition fromSome{A:Type} (default:A) (opt:Opt A): A :=
  match opt with
  | Some x => x
  | _ => default
  end.
(* Facts about lists *)

(* LICENSE NOTICE

Copyright (c) 2018 The MITRE Corporation.
All Rights Reserved.

This proof script is free software: you can redistribute it and/or
modify it under the terms of the BSD License as published by the
University of California.  See license.txt for details. *)

(** More facts about lists. *)

Require Import List PeanoNat Compare_dec Lia.
Import List.ListNotations.
Open Scope list_scope.

Set Implicit Arguments.

Section More_lists.

  Variable A: Type.

  (** This is the analog of [firstn_app] from the List library. *)

  Lemma skipn_app n:
    forall l1 l2: list A,
      skipn n (l1 ++ l2) = (skipn n l1) ++ (skipn (n - length l1) l2).
  Proof.
  induction n as [| n IH]; intros l1 l2.
  - simpl. reflexivity.
  - destruct l1 as [| a l1].
    + simpl. reflexivity.
    + simpl. rewrite IH. reflexivity.
Qed.    
 (** Proof. induction n as [|k iHk]; intros l1 l2.
    - now simpl.
    - destruct l1 as [|x xs].
      * unfold skipn at 2, length.
        repeat rewrite app_nil_l.
        rewrite <- Minus.minus_n_O.
        auto.
      * rewrite <- app_comm_cons. simpl. apply iHk.
  Qed.*)
  
  (*AI generated with GPT3.5*, removed rewrite Nat.sub_0_r *)
     (* however GPT3.5 added more noise .*)
  Lemma skipn_app5 n:
  forall l1 l2: list A,
    skipn n (l1 ++ l2) = (skipn n l1) ++ (skipn (n - length l1) l2).
Proof.
  induction n; intros l1 l2.
  - (* n = 0 *)
    reflexivity.
  - (* n > 0 *)
    destruct l1 as [|h1 t1].
    + (* l1 = [] *)
      simpl. reflexivity.
    + (* l1 = h1 :: t1 *)
      simpl. apply IHn.
Qed.
 
  (* (*AI generated - did not see original proof. 
       repair: proof removing one proof step works [rewrite Nat.sub_0_r *) *)
  Lemma skipn_app2 n:
    forall l1 l2: list A,
      skipn n (l1 ++ l2) = (skipn n l1) ++ (skipn (n - length l1) l2).
  Proof.
    (*this is removed for testing*)
    induction n; intros l1 l2.
    - simpl. reflexivity.
    - destruct l1.
      + simpl. reflexivity.
      + simpl. rewrite IHn. reflexivity.
  Qed.
(*start-here*)
  Lemma firstn_append:
    forall l l': list A,
      firstn (length l) (l ++ l') = l.
  Proof.
  induction l as [| a l IH]; intros l'.
  - simpl. reflexivity.
  - simpl. rewrite IH. reflexivity.
Qed.    
(**  Proof.
    induction l; intros; simpl; auto.
    rewrite IHl; auto.
  Qed.*)

  
(* 2 valid AI generated proofs.  
     did not see original proof.
     proof repair: correct with out modification *)  
  Lemma firstn_append2:
  forall l l': list A,
    firstn (length l) (l ++ l') = l.
Proof.
  (*induction l; intros l'; simpl.
  - reflexivity.
  - rewrite IHl. reflexivity.*)
  intros l l'.
  induction l as [|x xs IH]; simpl.
  - reflexivity.
  - rewrite IH. reflexivity.
Qed.
(*stop-here*)
  Lemma skipn_append:
    forall l l': list A,
      skipn (length l) (l ++ l') = l'.
  Proof.
  induction l as [| a l IH]; intros l'.
  - simpl. reflexivity.
  - simpl. apply IH.
Qed.    
 (** Proof.
    induction l; intros; simpl; auto.
  Qed.*)
  
(* AI generated. 
   did not see original proof. 
   prompt modifier : *using induction on l*
   *)
  Lemma skipn_append2:
  forall l l': list A,
    skipn (length l) (l ++ l') = l'.
Proof.
 induction l as [|x xs IH]; intros l'.
  - simpl. reflexivity.
  - simpl. apply IH.
Qed.

  Lemma skipn_all:
    forall l: list A,
      skipn (length l) l = [].
  Proof.
  induction l as [| a l IH].
  - simpl. reflexivity.
  - simpl. apply IH.
Qed.    
 (** Proof.
    induction l; intros; simpl; auto.
  Qed.*)
  
(* AI genrated - 
    did not see original proof
    proof repair: with no corrections *)  
  Lemma skipn_all2:
  forall l: list A,
    skipn (length l) l = [].
Proof.
  induction l as [|x xs IH]; simpl.
  - reflexivity.
  - apply IH.
Qed.

  Lemma skipn_nil:
    forall i,
      @skipn A i [] = [].
  Proof.
  induction i as [| i IH].
  - simpl. reflexivity.
  - simpl. reflexivity.
Qed.    
  (** Proof.
    destruct i; simpl; auto.
  Qed.
*)
(*AI generated - modified step2 from apply IH to rewrite <- IH and then reflexivity*)
  Lemma skipn_nil2:
  forall i,
    @skipn A i [] = [].
Proof.
  induction i as [|n IH]; simpl.
  - reflexivity.
  - rewrite <- IH. reflexivity.
Qed.

  Lemma firstn_all_n:
    forall (l: list A) n,
      length l <= n ->
      firstn n l = l.
  Proof.
  intros l n H.
  revert l H.
  induction n as [| n IH]; intros l H.
  - destruct l.
    + simpl. reflexivity.
    + simpl in H. lia.
  - destruct l.
    + simpl. reflexivity.
    + simpl. f_equal. apply IH. simpl in H. lia.
Qed.    
 (** Proof.
    induction l; intros; simpl.
    - rewrite firstn_nil. auto.
    - destruct n.
      simpl in H.
      lia.
      simpl in *.
      apply le_S_n in H.
      apply IHl in H.
      rewrite H; auto.
  Qed.*)
  
  (*AI generated - after proof training - diff proof but valid .*)
 Lemma firstn_all_n2:
  forall (l: list A) n,
    length l <= n ->
    firstn n l = l.
Proof.
  induction l as [|x xs IH]; intros n Hlen.
  - rewrite firstn_nil; reflexivity.
  - destruct n as [|n].
    + inversion Hlen.
    + simpl. f_equal. apply IH. simpl in Hlen. lia.
Qed.

  Lemma skipn_all_n:
    forall (l: list A) n,
      length l <= n ->
      skipn n l = [].
  Proof.
  intros l n H.
  revert l H.
  induction n as [| n IH]; intros l H.
  - destruct l.
    + simpl. reflexivity.
    + simpl in H. lia.
  - destruct l.
    + simpl. reflexivity.
    + simpl. apply IH. simpl in H. lia.
Qed.    
 (** Proof.
    induction l; intros; simpl.
    - rewrite skipn_nil. auto.
    - destruct n. simpl in *.
      lia.
      apply le_S_n in H.
      apply IHl. auto.
  Qed.*)

(*AI generated - after training on firstn_all_n, 
   modifier: induction on l. 
   repair: added induction n. auto to first goal's proof steps*)  
  Lemma skipn_all_n2:
  forall (l: list A) n,
    length l <= n ->
    skipn n l = [].
Proof.
induction l as [| x xs IH]; intros n Hlen.
  - simpl. induction n. auto. reflexivity.
  - destruct n.
    + simpl in Hlen. lia.
    + simpl. apply IH. simpl in Hlen. lia.
Qed.

Lemma firstn_in:
    forall x i (l: list A),
      In x (firstn i l) ->
      In x l.
  Proof.
    induction i; intros.
    - simpl in H; tauto.
    - destruct l.
      + simpl in H; tauto.
      + simpl in H.
        destruct H.
        subst; simpl; auto.
        apply IHi in H.
        simpl; auto.
  Qed.
(* AI generated after training *)  
  Lemma firstn_in2:
  forall x i (l: list A),
    In x (firstn i l) ->
    In x l.
Proof.
  induction i as [| i IH]; intros l H.
  - simpl in H; tauto.
  - destruct l as [| h t].
    + simpl in H; tauto.
    + simpl in H.
      destruct H as [H | H].
      * left; assumption.
      * right; apply IH; assumption.
Qed.

  Lemma skipn_in:
    forall x i (l: list A),
      In x (skipn i l) ->
      In x l.
 Proof.
  induction i as [| i IH]; intros l H.
  - simpl in H. exact H.
  - destruct l as [| a l].
    + simpl in H. contradiction.
    + simpl in H. right. apply IH. assumption.
Qed.     
     
 (*Dog-model: corrected two steps.  rewrite -> simpl in H, destruct l as i -> destruct as [|h t]
  Proof. induction i; intros; simpl.
         - simpl in H; tauto.
         - destruct l as [| h t].
           + simpl in *; auto.
           + simpl in *; auto. 
  Qed.*)
(** Proof. 
  intros x i l H.
  generalize dependent l.
  induction i as [|i' IHi']; intros l HIn.
  - simpl in HIn. assumption.
  - destruct l as [|a l'].
    + simpl in HIn. contradiction.
    + simpl in HIn. apply IHi' in HIn. right. assumption.
Qed.*)
  
(* AI generated, did not see the original proof. 
   Modifier: using induction on i and destruct l.*****************
   proof repair: last step to auto, instead of assumption.
   trained on firstn_in*)
  Lemma skipn_in2:
  forall x i (l: list A),
    In x (skipn i l) ->
    In x l.
Proof.
  induction i; intros l H.
  - simpl in H. assumption.
  - destruct l.
    + simpl in H. contradiction.
    + simpl in *. apply IHi in H. auto.
Qed.

(* AI GPT-4* no modifications correct directly *)
Lemma skipn_in3 :
  forall x i (l: list A),
    In x (skipn i l) ->
    In x l.
Proof.
  intros x i l H.
  revert l H.
  induction i as [| i' IH]; intros l H.
  - simpl in H. apply H.
  - destruct l as [| h t].
    + simpl in H. contradiction.
    + simpl in H. apply IH in H. right. apply H.
Qed.

  Lemma skipn_zero:
    forall l: list A,
      skipn 0 l = l.
  Proof.
  intros l.
  simpl. 
  reflexivity.
Qed.    
 (** Proof.
    destruct l; simpl; auto.
  Qed.*)
  
(*AI generated GPT-4 : no modification correct directly*)  
Lemma skipn_zero2 :
  forall l: list A,
    skipn 0 l = l.
Proof.
  intro l.
  simpl.
  reflexivity.
Qed. 

  Lemma in_skipn_cons:
    forall i x y (l: list A),
      In x (skipn i l) ->
      In x (skipn i (y :: l)).
Proof.
  induction i as [| i IH]; intros x y l H.
  - simpl. right. assumption.
  - destruct l as [| a l].
    + simpl in *. contradiction.
    + simpl in *. auto.
Qed.    
  (** Proof.
    induction i; intros; simpl.
    - rewrite skipn_zero in H; auto.
    - destruct l.
      + simpl in H; tauto.
      + simpl in H; auto.
  Qed.*)
  
(* AI generated GPT-4*)
Lemma in_skipn_cons3 :
  forall i x y (l: list A),
    In x (skipn i l) ->
    In x (skipn i (y :: l)).
Proof.
 induction i. intros. simpl.
    - rewrite skipn_zero in H; auto.
    - intros. simpl; destruct l.
      + simpl in IHi. contradiction. 
      + simpl in H; auto.
Qed.
 
Lemma in_skipn_cons4 :
  forall i x y (l: list A),
    In x (skipn i l) ->
    In x (skipn i (y :: l)).
Proof.
  induction i. intros. simpl.
    - rewrite skipn_zero in H; auto.
    - intros. simpl; destruct l.
      + simpl in IHi. contradiction. 
      + simpl in H; auto.
Qed.

  (** Do [l] and [l'] share no elements? *)

  Definition disjoint_lists (l l': list A): Prop :=
    forall x, In x l -> In x l' -> False.

  Lemma nodup_append:
    forall l l': list A,
      NoDup l -> NoDup l' ->
      disjoint_lists l l' ->
      NoDup (l ++ l').
  Proof.  
intros l l' Hnd_l Hnd_l' Hdisj.
induction Hnd_l as [| x l Hnotin_l Hnd_l IH].

    simpl. assumption.
    simpl. constructor.
        intro Hcontra.
        apply in_app_iff in Hcontra.
        destruct Hcontra as [Hin_l | Hin_l'].
            apply Hnotin_l. assumption.
            apply (Hdisj x); [simpl; left; reflexivity | assumption].
        apply IH.
        intros x' Hin_l Hin_l'.
        apply (Hdisj x'); [simpl; right; assumption | assumption].
        Qed.
   
  (** Proof.
    intros.
    induction H.
    - rewrite app_nil_l; auto.
    - rewrite <- app_comm_cons.
      apply NoDup_cons.
      + intro.
        apply in_app_iff in H3.
        destruct H3; intuition.
        apply H1 in H3; try tauto; simpl; auto.
      + apply IHNoDup. unfold disjoint_lists; intros.
        apply H1 in H4; try tauto.
        simpl; auto.
  Qed.**)
  (*AI generated using GPT-4 no correction required*)
    Lemma nodup_append_2:
    forall l l': list A,
      NoDup l -> NoDup l' ->
      disjoint_lists l l' ->
      NoDup (l ++ l').
  Proof.  
intros l l' Hnd_l Hnd_l' Hdisj.
induction Hnd_l as [| x l Hnotin_l Hnd_l IH].

    simpl. assumption.
    simpl. constructor.
        intro Hcontra.
        apply in_app_iff in Hcontra.
        destruct Hcontra as [Hin_l | Hin_l'].
            apply Hnotin_l. assumption.
            apply (Hdisj x); [simpl; left; reflexivity | assumption].
        apply IH.
        intros x' Hin_l Hin_l'.
        apply (Hdisj x'); [simpl; right; assumption | assumption].
        Qed.

  Lemma in_cons_app_cons:
    forall x y z (l: list A),
      In x (y :: l ++ [z]) <->
      x = y \/ In x l \/ x = z.
Proof.
  intros. rewrite app_comm_cons.
  rewrite in_app_iff; simpl.
  split; intros H; decompose [or] H; auto.
  intuition.
Qed.   
  (** Proof.
    intros.
    rewrite app_comm_cons.
    rewrite in_app_iff; simpl.
    intuition.
  Qed.*)

(*AI generated - missed -- on line 345, assumption used in palce of auto*)  
    Lemma in_cons_app_cons_2:
    forall x y z (l: list A),
      In x (y :: l ++ [z]) <->
      x = y \/ In x l \/ x = z.
  Proof.
intros x y z l.
split; intros H.

    simpl in H.
    destruct H as [Heq_y | Hin_app].
        left. auto.
        apply in_app_iff in Hin_app.
        destruct Hin_app as [Hin_l | Hin_singleton].
            right; left; assumption.
            right; right.
            destruct Hin_singleton as [Heq_z | Hcontra].
            -- auto.
            -- inversion Hcontra.
    -- destruct H as [Heq_y | [Hin_l | Heq_z]].
        simpl. left. auto.
        simpl. right. apply in_app_iff. left. auto.
        simpl. right. apply in_app_iff. right. simpl. left; auto.
        Qed.

  (** * Earlier *)

  (** Is [x] earlier than [y] in list [l]?  This definition is used in
      contexts in which [l] has no duplicates. *)

  Definition earlier (l: list A) (x y: A) :=
    exists n,
      In x (firstn n l) /\
      In y (skipn n l).

  Lemma earlier_in_left:
    forall l x y,
      earlier l x y -> In x l.
  Proof.
  intros l x y H.
  destruct H as [n [Hx _]].
  apply firstn_in in Hx.
  assumption.
Qed.    
(**  Proof.
    intros.
    destruct H as [i].
    destruct H.
    apply firstn_in in H; auto.
  Qed.*)

  Lemma earlier_in_right:
    forall l x y,
      earlier l x y -> In y l.
  Proof.
  intros l x y H.
  destruct H as [n [_ Hy]].
  apply skipn_in in Hy.
  assumption.
Qed.    
  (** Proof.
    intros.
    destruct H as [i].
    destruct H.
    apply skipn_in in H0; auto.
  Qed.*)

  (** [x] is earlier than [y] in [p ++ q] if [x] is earlier than [y]
      in [p].  *)

  Lemma earlier_left:
    forall p q x y,
      earlier p x y -> earlier (p ++ q) x y.
  Proof.
  intros p q x y [n [Hx Hy]].
  exists n. split.
  - rewrite firstn_app. apply in_or_app. left. assumption.
  - rewrite skipn_app. 
     apply in_or_app.
      left; auto.
Qed.
  
  (**Proof.
    intros.
    destruct H as [i].
    destruct H.
    exists i.
    split.
    - rewrite firstn_app.
      apply in_or_app.
      left; auto.
    - rewrite skipn_app.
      apply in_or_app.
      left; auto.
  Qed.*)

  (** [x] is earlier than [y] in [p ++ q] if [x] is earlier than [y]
      in [q].  *)

  Lemma earlier_right:
    forall p q x y,
      earlier q x y -> earlier (p ++ q) x y.
Proof.
  intros p q x y [i [Hx Hy]].
  exists (length p + i).
  assert (G: length p + i - length p = i).
  lia.
  split.
  - rewrite firstn_app. apply in_or_app. right. rewrite G. assumption.
  - rewrite skipn_app. apply in_or_app. right. rewrite G. assumption.
Qed.   
 (** Proof.
    intros.
    destruct H as [i].
    destruct H.
    exists (length p + i).
    assert (G: length p + i - length p = i).
    lia.
    split.
    - rewrite firstn_app.
      apply in_or_app.
      right.
      rewrite G; auto.
    - rewrite skipn_app.
      apply in_or_app.
      right.
      rewrite G; auto.
  Qed.*)

  Lemma earlier_append:
    forall p q x y,
      In x p -> In y q ->
      earlier (p ++ q) x y.
  Proof.
  intros p q x y Hx Hy.
  exists (length p).
  split.
  - rewrite firstn_append.
  exact Hx.
  - rewrite skipn_append. auto.
Qed.    
 (** Proof.
    intros.
    exists (length p).
    rewrite firstn_append.
    rewrite skipn_append.
    auto.
  Qed.*)

  Lemma earlier_append_iff:
    forall x y (l l': list A),
      earlier (l ++ l') x y <->
      earlier l x y \/ In x l /\ In y l' \/ earlier l' x y.
 Proof.
    split; intros.
    - destruct H as [i].
      destruct H.
      rewrite firstn_app in H.
      rewrite skipn_app in H0.
      pose proof (le_lt_dec i (length l)) as G.
      destruct G as [G|G].
      + rewrite <- Nat.sub_0_le in G; auto.
        rewrite G in *.
        simpl in *.
        rewrite app_nil_r in H.
        apply in_app_iff in H0.
        destruct H0.
        * left; exists i; auto.
        * right; left; split; auto.
          apply firstn_in in H; auto.
      + right.
        rewrite firstn_all_n in H; try lia.
        rewrite skipn_all_n in H0; try lia.
        rewrite app_nil_l in H0.
        apply in_app_iff in H.
        destruct H.
        * apply skipn_in in H0; auto.
        * right.
          exists (i - length l); auto.
    - destruct H.
      apply earlier_left; auto.
      destruct H.
      + destruct H.
        apply earlier_append; auto.
      + apply earlier_right; auto.
  Qed.
  
  
  Lemma earlier_cons:
    forall p x y,
      In y p ->
      earlier (x :: p) x y.
  Proof.
  intros p x y H.
  exists 1. simpl. split; auto.
Qed.
 (** Proof.
  
    intros; exists 1; simpl; auto.
  Qed.*)

  Lemma earlier_cons_shift:
    forall p x y z,
      earlier p x y ->
      earlier (z :: p) x y.
  Proof.
  intros p x y z [n [Hx Hy]].
  exists (S n). simpl. split; auto.
Qed.    
  Proof.
    intros.
    destruct H as [i].
    destruct H.
    exists (S i).
    simpl; auto.
  Qed.

End More_lists.

Unset Implicit Arguments.
Require Import AbstractedTypes EqClass Term_Defs.

Require Import StructTactics.

Require Import Coq.Program.Tactics.
Require Import PeanoNat.

(*
Set Nested Proofs Allowed.
 *)


Definition eqb_aspid `{H : EqClass ID_Type} (a1 a2 : ASP_ID)  : bool :=
  eqb a1 a2.

(** Admitted Lemmas relating boolean to propositional equality for 
   ASP ID and PARAMS *)
Lemma eqb_eq_aspid: forall `{H : EqClass ID_Type} i1 i2,
    eqb_aspid i1 i2 = true -> i1 = i2.
Proof.
  unfold eqb_aspid.
  destruct H. eapply eqb_leibniz.
Qed.

Definition eqb_asp_params `{H : EqClass ID_Type} `{H : EqClass (list ID_Type)} (ap1 ap2 : ASP_PARAMS) : bool :=
  match ap1, ap2 with
  | (asp_paramsC a1 la1 p1 t1), (asp_paramsC a2 la2 p2 t2) =>
      andb (eqb_aspid a1 a2) 
        (andb (eqb la1 la2)
          (andb (eqb p1 p2) 
                (eqb t1 t2)))
  end.

(** Decidable equality proofs for various Copland datatypes *)
Definition eq_asp_params_dec `{H : EqClass ID_Type} :
  forall x y: ASP_PARAMS, {x = y} + {x <> y}.
Proof.
  intros.
  decide equality; subst;
  eapply EqClass_impl_DecEq; eauto.
  eapply EqClass_extends_to_list; eauto.
Defined.

Lemma eqb_eq_asp_params: forall `{H : EqClass ID_Type} a a0 ,
    eqb_asp_params a a0 = true <->
    a = a0.
Proof.
  induction a; destruct a0; simpl;
  repeat (rewrite Bool.andb_true_iff);
  repeat split; eauto; try inv H0;
  try rewrite eqb_leibniz; eauto;
  try (eapply EqClass_extends_to_list; eauto).
  - intros; destruct_conjs; subst.
    repeat (rewrite eqb_leibniz in *); subst.
    eapply general_list_eqb_leibniz in H1; subst; eauto.
  - eapply eqb_leibniz; eauto.
Qed.

Global Instance EqClassASP_PARAMS `{H : EqClass ID_Type} : EqClass ASP_PARAMS := {
  eqb := eqb_asp_params ;
  eqb_leibniz := eqb_eq_asp_params
}.

Definition eq_evidence_dec : forall `{H : EqClass ID_Type},
  forall x y : Evidence, {x = y} + {x <> y}.
Proof.
  intros.
  decide equality; subst;
  try (try eapply EqClass_impl_DecEq; eauto;
  try eapply nat_EqClass; eauto; fail).
  - eapply eq_asp_params_dec.
  - destruct f, f0; eauto; right; intros HC; congruence.
Qed.

Definition eq_term_dec : forall `{H : EqClass ID_Type},
  forall x y : Term, {x = y} + {x <> y}.
Proof.
  intros.
  decide equality; subst;
  try (try eapply EqClass_impl_DecEq; eauto;
  try eapply nat_EqClass; eauto; fail).
  - destruct a, a0; eauto; try (right; intros HC; congruence).
    * destruct (eq_asp_params_dec a a0); subst; eauto;
      destruct s, s0, f, f0; eauto; try (right; intros HC; congruence).
    * destruct (@EqClass_impl_DecEq Plc H p p0); subst; eauto.
      right; intros HC; congruence.
  - destruct s, s0, s, s1, s0, s2; eauto; try (right; intros HC; congruence).
  - destruct s, s0, s, s1, s0, s2; eauto; try (right; intros HC; congruence).
Qed.

Definition eq_core_term_dec : forall `{H : EqClass ID_Type},
  forall x y : Core_Term, {x = y} + {x <> y}.
Proof.
  intros.
  decide equality; subst;
  try (try eapply EqClass_impl_DecEq; eauto;
  try eapply nat_EqClass; eauto; fail).
  - destruct a, a0; eauto; try (right; intros HC; congruence).
    * destruct (eq_asp_params_dec a a0); subst; eauto;
      destruct f, f0; eauto; try (right; intros HC; congruence).
  - eapply eq_term_dec.
Qed.

Definition eq_ev_dec: forall `{H : EqClass ID_Type},
  forall x y: Ev, {x = y} + {x <> y}.
Proof.
  intros;
  decide equality; subst;
  try (try eapply EqClass_impl_DecEq; eauto;
  try eapply nat_EqClass; 
  try eapply EqClassASP_Params; eauto; fail).
  repeat decide equality; subst;
  try (try eapply EqClass_impl_DecEq; eauto;
  try eapply nat_EqClass; eauto; fail).
  - eapply eq_asp_params_dec.
  - eapply eq_evidence_dec.
  - eapply eq_term_dec.
  - eapply eq_evidence_dec.
  - eapply eq_evidence_dec.
  - eapply eq_core_term_dec.
Qed.
#[local] Hint Resolve eq_ev_dec : core.

#[local] Hint Resolve eq_evidence_dec : core.


(** list equality Lemmas *)
Scheme Equality for list.

Lemma list_beq_refl {A:Type}: forall f y,
    (forall a b, f a b = true <-> a = b) ->
    list_beq A f y y = true.
 Proof.
   intros.
   generalizeEverythingElse y.
   induction y; intros.
   -
     cbn.
     tauto.
   -
     cbn.
     eapply andb_true_intro.
     split.
     +
       eapply H; eauto.
     +
       eauto.
 Defined.

Lemma eqb_eq_list {A:Type}:
  forall x y f,
    (forall a b, f a b = true <-> a = b) ->
    list_beq A f x y = true <-> x = y.
Proof.
  intros.
  generalizeEverythingElse x.
  induction x; destruct y; intros.
  -
    cbn in *.
    split; tauto.
  -
    cbn in *.
    split;
      intros;
      solve_by_inversion.
  -
    cbn in *.
    split; intros;
      solve_by_inversion.
  -
    cbn in *.
    split; intros.
    +
      assert (f a a0 = true /\ list_beq A f x y = true).
      {
        eapply Bool.andb_true_iff.
        eassumption.
      }
      destruct_conjs.
      
      edestruct IHx with (y:= y).
      assert (x = y).
      {
        eapply IHx.
        split; intros.
        eapply H.
        eassumption.
        specialize H with (a:=a1) (b:=b).
        inversion H.
        eapply H5. eassumption.
        eassumption.
      }
      intros.
      split; intros.
      specialize H with (a:=a1) (b:=b).
      invc H.
      eapply H5; eauto.
      subst.
      specialize H with (a:=b) (b:=b).
      invc H.
      eapply H4; eauto.
      

      assert (a = a0).
      {
        
      
        concludes.
        eapply H.
        eassumption.
      }
      subst.
      assert (x = y).
      {
        eapply IHx.
        eassumption.
        eassumption.
      }
      congruence.
    +
      invc H0.
      eapply andb_true_intro.
      split.
      eapply H.
      reflexivity.
      eapply list_beq_refl; eauto.
Defined.

Definition eqb_fwd (fwd1 fwd2 : FWD) : bool.
Admitted.

Lemma eqb_eq_fwd: forall f1 f2,
    eqb_fwd f1 f2 = true <->
    f1 = f2.
Proof.
Admitted.

(** Boolean equality for Evidence Types *)
Fixpoint eqb_evidence `{H : EqClass ID_Type} (e:Evidence) (e':Evidence): bool :=
  match (e,e') with
  | (mt,mt) => true
                (*
  | (gg p params e1, gg p' params' e2) =>
    (Nat.eqb p p') && (eqb_asp_params params params') && (eqb_evidence e1 e2)
  | (hh p params e1, hh p' params' e2) =>
    (Nat.eqb p p') && (eqb_asp_params params params') && (eqb_evidence e1 e2)
                 *)
  | (uu p fwd params e1, uu p' fwd' params' e2) =>
    (eqb p p') && (eqb_fwd fwd fwd') && (eqb_asp_params params params') && (eqb_evidence e1 e2)
  | (nn i, nn i') => (eqb i i')
  | (ss e1 e2, ss e1' e2') =>
    (eqb_evidence e1 e1') && (eqb_evidence e2 e2')
  | _ => false
  end.


(**  Lemma relating boolean to propositional equality for Evidence Types *)
Lemma eqb_eq_evidence: forall e1 e2,
    eqb_evidence e1 e2 = true <-> e1 = e2.
Proof.
  
  intros.
  split.
  -
    generalizeEverythingElse e1.
    induction e1; destruct e2; intros;
      try (cbn in *; repeat break_match; try solve_by_inversion; eauto).
    + rewrite Nat.eqb_eq in H; eauto.
    + cbn in *.
      rewrite Bool.andb_true_iff in H.
      rewrite Bool.andb_true_iff in H.
      rewrite Bool.andb_true_iff in H.
      destruct_conjs.
      rewrite eqb_leibniz in H.
      specialize IHe1 with e2.
      concludes.
      rewrite eqb_eq_asp_params in H1.
      rewrite eqb_eq_fwd in H2.
      congruence.


(*
      
    +
      cbn in *.
      rewrite Bool.andb_true_iff in H.
      rewrite Bool.andb_true_iff in H.
      destruct_conjs.
      apply EqNat.beq_nat_true in H.
      subst.
      specialize IHe1 with e2.
      concludes.
      assert (a = a0).
      {
        erewrite <- eqb_eq_asp_params.
        eassumption.
      }       
      congruence.  
      
    +
      cbn in *.
      rewrite Bool.andb_true_iff in H.
      rewrite Bool.andb_true_iff in H.
      destruct_conjs.
      apply EqNat.beq_nat_true in H.
      specialize IHe1 with e2.
      concludes.
      rewrite eqb_eq_asp_params in H1.
      congruence.
*)


    +
      cbn in *.
      rewrite Bool.andb_true_iff in H.
      destruct_conjs.
      specialize IHe1_1 with e2_1.
      specialize IHe1_2 with e2_2.
      concludes.
      concludes.
      congruence.
  -
    generalizeEverythingElse e1.
    induction e1; destruct e2; intros;
      try (cbn in * ; repeat break_match; try solve_by_inversion; eauto).
    + invc H. rewrite Nat.eqb_eq; eauto.
    + invc H.
      cbn in *.
      repeat rewrite Bool.andb_true_iff.
      split. split. split. 
      * eapply eqb_leibniz; eauto.
      * rewrite eqb_eq_fwd. tauto.
      * erewrite eqb_eq_asp_params. tauto.
      * eauto.
      (*
    +
      invc H.
      cbn in *.
      repeat rewrite Bool.andb_true_iff.
      split. split.
      apply Nat.eqb_refl.
      erewrite eqb_eq_asp_params. tauto.
      eauto. *)
    +
      invc H.
      cbn in *.
      repeat rewrite Bool.andb_true_iff.
      split;
        eauto.
Defined.
(*
Axioms and lemmas that capture the semantics of external CVM instances.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import Term_Defs Anno_Term_Defs Cvm_St Cvm_Impl Axioms_Io Helpers_CvmSemantics Cvm_Monad AbstractedTypes.

Require Import List.
Import ListNotations.


Axiom build_cvm_external' : forall (t : Core_Term) (e : EvC) (n : ID_Type) (tr:list Ev) (i:Event_ID),
    runSt 
      (build_cvm t)
      {| st_ev := e;
         st_trace := tr;
         st_pl := n;
         st_evid := i |} =
    (Some tt,
     {| st_ev := cvm_evidence_core t n e;
        st_trace := tr ++ (cvm_events_core t n (get_et e));
        st_pl :=
          st_pl
            (
              execSt (build_cvm t)
                     {| st_ev := e;
                        st_trace := [];
                        st_pl := n;
                        st_evid := i |});
        st_evid := (i + event_id_span t)
     |}).

Lemma build_cvm_external : forall (t : Core_Term) (e : EvC) (n : ID_Type) i,
    build_cvm t
                    {| st_ev := e;
                       st_trace := [];
                       st_pl := n;
                       st_evid := i|} =
    (Some tt,
     {| st_ev := cvm_evidence_core t n e;
        st_trace := cvm_events_core t n (get_et e);
        st_pl := n;
        st_evid := (i + event_id_span t)
     |}).
Proof.
  intros.
  assert ([] ++ (cvm_events_core t n (get_et e)) = (cvm_events_core t n (get_et e))) by eauto.
  assert (n = st_pl
            (
              execSt
                (build_cvm t)
                {| st_ev := e;
                     st_trace := [];
                     st_pl := n; st_evid := i |})) as H0'.
  {
    rewrite pl_immut;
    tauto. 
  }
  rewrite H0' at 4.
  eapply build_cvm_external'.
Defined.
(*
Helper lemmas for proofs about the CVM semantics.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import Anno_Term_Defs Cvm_Monad Cvm_Impl Term_Defs Auto StructTactics AutoApp.

Require Import Coq.Program.Tactics Coq.Program.Equality.

Require Import List.
Import ListNotations.

(*
Set Nested Proofs Allowed.
*)

(* Lemma stating the CVM st_pl parameter ends up where it started execution *)
Lemma pl_immut : forall t e tr p i,
    st_pl
      (execSt
         (build_cvm t)
         {|
           st_ev := e;
           st_trace := tr;
           st_pl := p;
           st_evid := i|}) = p.
Proof.
  induction t; intros.
  -
    destruct a; (* asp *)
      try destruct a; (* asp params *)    
      try reflexivity.
  -
    df.
    reflexivity.
  -
    simpl in *.
    monad_unfold.
    repeat break_match;
      try solve_by_inversion.
    df.
    annogo.
    simpl.  
    assert (p = st_pl0).
    {
      edestruct IHt1.
      jkjke.
    }
    assert (st_pl0 = st_pl).
    {
      edestruct IHt2.
      jkjk_s.
    }
    congruence.
  -
    (*
    do_wf_pieces. *)
    annogo.
    df.
    
    repeat break_match;
      try solve_by_inversion;
    repeat find_inversion;
    repeat dunit;
    simpl in *; vmsts; simpl in *.
    +
    assert (p = st_pl0).
    {
      edestruct IHt1.
      jkjk_s; eauto.     
    }

    assert (st_pl0 = st_pl).
    {     
      edestruct IHt2.
      jkjk_s; eauto.
    }

    congruence.
    +
      assert (p = st_pl).
      {
        edestruct IHt1.
        jkjk_s; eauto.
      }

      assert (st_pl = st_pl0).
      {
        edestruct IHt2.
        jkjk_s; eauto.
      }

      congruence.
    +
      symmetry.
      edestruct IHt1.
      jkjk_s; eauto.
    +
      symmetry.
      edestruct IHt1.
      jkjk_s; eauto.

  -
    annogo.
    df.

    repeat break_let.

    repeat break_match;
      try solve_by_inversion;
    repeat find_inversion;
    repeat dunit;
    simpl in * ; vmsts; simpl in *.
    +
    assert (p = st_pl).
    {
      edestruct IHt1.
      jkjke. 
    }
    congruence.   

    +
    assert (p = st_pl).
    {
      edestruct IHt1.
      jkjke.    
    }
    congruence. 
Defined.

Ltac do_pl_immut :=
  let tac H :=
       erewrite <- pl_immut;
        [ unfold execSt;
          rewrite H;
          reflexivity (*| 
          apply H2*)] in
      match goal with
      | [H: build_cvm ?t
                            {| st_ev := _;
                        st_trace := _;
                                    st_pl := ?p;
                            st_evid := _|} =
            (_,
             {| st_ev := _;
                         st_trace := _;
                         st_pl := ?p'; st_evid := _ |})
         (*H2: well_formed_r ?t*) |- _] =>
        assert_new_proof_by (p' = p) ltac:(tac H)  
      end.

Lemma st_congr :
  forall st tr e p i,
    st_ev st = e ->
    st_trace st = tr ->
    st_pl st = p ->
    st_evid st = i ->
    st =  {| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |}.
Proof.
  intros.
  subst; destruct st; auto.
Defined.

(* Hack to apply a specific induction hypothesis in some proofs *)
Ltac anhl :=
  annogo;
  match goal with
  | [H2: build_cvm ?a _ = _,
     H3: build_cvm ?a _ = _,
     IH: context[ _ -> _] |- _] =>
    edestruct IH;
    [ apply H2 | apply H3 | idtac]; clear H2; clear H3;
    destruct_conjs; subst
  end.

(* Lemma stating the following:  If all starting parameters to the cvm_st are the same, except 
   for possibly the trace, then all of those final parameters should also be equal. *)
Lemma st_trace_irrel : forall t e e' e'' x x' y y' p p' p'' i i' i'',
    build_cvm t {| st_ev := e; st_trace := x; st_pl := p; st_evid := i |} =
    (Some tt, {| st_ev := e'; st_trace := x'; st_pl := p'; st_evid := i' |}) ->
    build_cvm t {| st_ev := e; st_trace := y; st_pl := p; st_evid := i |} =
    (Some tt, {| st_ev := e''; st_trace := y'; st_pl := p''; st_evid := i'' |}) ->
    (e' = e'' /\ p' = p'' /\ i' = i'').
Proof.
  induction t; intros.
  - destruct a; (* asp *)
      try destruct a; (* asp params *)
      df; eauto.
  -
    repeat (df; try dohtac; df).
    tauto.
  -
    df;
    repeat break_match;
    try (repeat find_inversion);
    simpl in *.
    df.
    anhl.
    eauto. 
  -
    df;
    repeat break_match;
    try (repeat find_inversion);
    simpl in *.
    df.
    repeat anhl.
    repeat find_inversion.
    eauto.
  -
    cbn in *.
    monad_unfold.
    repeat break_let.
    simpl in *.

    dosome.
    df.
    dosome.
    dosome.
    df.

    annogo.
    simpl in *.

    repeat anhl.
    repeat (find_inversion).
    repeat find_rewrite.
    df.
    tauto.
Defined.


Ltac dohi'' :=
  annogo;
  let tac H H' := eapply st_trace_irrel; [apply H | apply H'] in
  match goal with
  | [H : build_cvm ?t1 {| st_ev := ?e; st_trace := _; st_pl := ?p; st_evid := ?i |} =
         (?opt, {| st_ev := ?e'; st_trace := _; st_pl := ?p'; st_evid := ?i' |}),
         H' : build_cvm ?t1 {| st_ev := ?e; st_trace := _; st_pl := ?p; st_evid := ?i |} =
              (?opt, {| st_ev := ?e''; st_trace := _; st_pl := ?p''; st_evid := ?i'' |})
     |- _] =>
    assert_new_proof_by (e' = e'' /\ p' = p'' /\ i' = i'') ltac:(tac H H')
  end.

Ltac dohi :=
  do 2 (repeat dohi''; destruct_conjs; subst);
  repeat clear_triv.





(* States that the resulting place (st_pl) is unaffected by the initial trace.
   This is a simple corollary of the Lemma hihi above. *)
Lemma trace_irrel_pl : forall t tr1 tr1' tr2 e e' p1' p1 i i',
    build_cvm t
           {| st_ev := e; st_trace := tr1; st_pl := p1; st_evid := i |} =
    (Some tt, {| st_ev := e'; st_trace := tr1'; st_pl := p1'; st_evid := i' |}) ->
    
    st_pl
      (execSt (build_cvm t)
           {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) = p1'.
Proof.
  intros.
  destruct (build_cvm t {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) eqn:ff.
  simpl.
  vmsts.
  simpl.
  do_asome.
  subst.
  dohi.
  df.
  tauto.
Defined.

(* States that the resulting evidence (st_ev) is unaffected by the initial trace.
   This is a simple corollary of the Lemma hihi above. *)
Lemma trace_irrel_ev : forall t tr1 tr1' tr2 e e' p1' p1 i i',
    build_cvm t
           {| st_ev := e; st_trace := tr1; st_pl := p1; st_evid := i|} =
    (Some tt, {| st_ev := e'; st_trace := tr1'; st_pl := p1'; st_evid := i' |}) ->
    
    st_ev
      (execSt (build_cvm t)
           {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) = e'.
Proof.
  intros.
  destruct (build_cvm t {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) eqn:ff.
  simpl.
  vmsts.
  simpl.
  do_asome.
  subst.
  dohi.
  df.
  tauto.
Defined.

(* States that the resulting event id counter (st_evid) is unaffected by the initial trace.
   This is a simple corollary of the Lemma hihi above. *)
Lemma trace_irrel_evid : forall t tr1 tr1' tr2 e e' p1' p1 i i',
    build_cvm t
           {| st_ev := e; st_trace := tr1; st_pl := p1; st_evid := i|} =
    (Some tt, {| st_ev := e'; st_trace := tr1'; st_pl := p1'; st_evid := i' |}) ->
    
    st_evid
      (execSt (build_cvm t)
           {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) = i'.
Proof.
  intros.
  destruct (build_cvm t {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) eqn:ff.
  simpl.
  vmsts.
  simpl.
  do_asome.
  subst.
  dohi.
  df.
  tauto.
Defined.


Ltac do_st_trace :=
  match goal with
  | [H': context[{| st_ev := ?e; st_trace := ?tr; st_pl := ?p; st_evid := ?i |}]
     |- context[?tr]] =>
    assert_new_proof_by
      (tr = st_trace {| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |} )
      tauto
  end.

Ltac do_st_trace_assumps :=
  match goal with
  | [H': context[{| st_ev := ?e; st_trace := ?tr; st_pl := ?p; st_evid := ?i |}]
     |- _] =>
    assert_new_proof_by
      (tr = st_trace {| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |} )
      tauto
  end.

Ltac find_rw_in_goal :=
  match goal with
  | [H': context[?x = _]
     |- context[?x]] =>
    rewrite H'; clear H'
  end.

Inductive build_cvmP :
  Core_Term -> cvm_st -> (option unit) -> cvm_st ->  Prop :=
| ccp: forall t st st' res,
    build_cvm t st = (res, st') ->
    build_cvmP t st res st'.

Lemma ccp_implies_cc: forall t st st' res,
  build_cvmP t st res st' ->
  build_cvm t st = (res,st').
Proof.
  intros.
  solve_by_inversion.
Defined.

Lemma cc_implies_ccp: forall t st st' res,
  build_cvm t st = (res,st') -> 
  build_cvmP t st res st'.
Proof.
  intros.
  econstructor.
  tauto.
Defined.

Lemma ccp_iff_cc: forall t st st' res,
  build_cvm t st = (res,st') <-> 
  build_cvmP t st res st'.
Proof.
  intros.
  split; intros;
    try (eapply cc_implies_ccp; eauto);
    try (eapply ccp_implies_cc; eauto).
Defined.

Ltac inv_term_coreP :=
  match goal with
  | [H: term_to_coreP _ _ (* ?t (?c _) *)
     |- _ ] =>
    inversion H; subst
  end.

Lemma term_to_coreP_redo: forall t t',
    copland_compile t = t' ->
    term_to_coreP t t'.
Proof.
  intros.
  econstructor.
  eauto.
Defined.

Ltac do_term_to_core_redo :=
  match goal with
  | [H: copland_compile ?t = ?t'
     |- _ ] =>
    eapply term_to_coreP_redo in H
  end.



Lemma annoP_redo: forall t annt n n',
    anno t n = (n', annt) ->
    annoP annt t.
Proof.
  intros.
  econstructor.
  eexists.
  jkjke.
Defined.

Ltac do_anno_redo :=
  match goal with
  | [H: anno ?t ?n = (_,?annt)
     |- _ ] =>
    eapply annoP_redo in H
  end.

Ltac inv_annoP :=
  match goal with
  | [H: annoP _ _ (*_ (?c _) *)
     |- _ ] =>
    inversion H; subst
  end;
  destruct_conjs.

Lemma annoP_indexed_redo: forall t annt n n',
    anno t n = (n', annt) ->
    annoP_indexed annt t n n'.
Proof.
  intros.
  econstructor.
  jkjke.
Defined.

Ltac do_anno_indexed_redo :=
  match goal with
  | [H: anno _ _ = (_,_)
     |- _ ] =>
    eapply annoP_indexed_redo in H
  end.

Ltac inv_annoP_indexed :=
  match goal with
  | [H: annoP_indexed _ _ _ _(*_ (?c _) _*)
     |- _ ] =>
    inversion H; subst
  end;
  destruct_conjs.

Ltac wrap_annopar :=
  inv_term_coreP;
  dd;
  repeat do_term_to_core_redo.

Ltac wrap_anno :=
  inv_annoP;
  dd;
  repeat do_anno_redo.

Ltac wrap_anno_indexed :=
  inv_annoP_indexed;
  dd;
  repeat do_anno_indexed_redo.

Ltac wrap_ccp :=
  
  try rewrite <- ccp_iff_cc in *;
  dd;
  repeat do_pl_immut;
  dd;
  try rewrite ccp_iff_cc in *.

Ltac wrap_ccp_anno :=
  
  try rewrite <- ccp_iff_cc in *;
  try wrap_annopar;
  try wrap_anno;
  try wrap_anno_indexed;
  repeat do_pl_immut;
  try (unfold OptMonad_Coq.ret in * );
  try (unfold OptMonad_Coq.bind in * );
  dd;
  try rewrite ccp_iff_cc in *.



Ltac cumul_ih :=
  match goal with
  | [H: context[(st_trace _ = _ ++ st_trace _)],
        H': build_cvmP ?t1 {| st_ev := _; st_trace := ?m ++ ?k; st_pl := _; st_evid := _ |}
                             (Some tt)
                             ?v_full,
            H'': build_cvmP ?t1 {| st_ev := _; st_trace := ?k; st_pl := _; st_evid := _ |}
                                  (Some tt)
                                  ?v_suffix
     |- _] =>
    assert_new_proof_by (st_trace v_full = m ++ st_trace v_suffix) eauto
  end.

Ltac wrap_ccp_dohi :=
  rewrite <- ccp_iff_cc in *;
  dd;
  dohi;
  rewrite ccp_iff_cc in *.
(* Misc automation tactics.  Some of these might be repeats or overlap. *)

Require Import StructTactics Auto (* Helpers_CvmSemantics *) Cvm_St Cvm_Monad StMonad_Coq Cvm_Impl.
Require Import List.

Ltac dosome_eq y :=
  match goal with
  | [H: match ?x with _ => _ end = (Some _, _)  |- _] =>
    destruct x eqn:y; try solve_by_inversion
  end.

Ltac do_pair :=
  match goal with
  | [H: (_,_) = (Some _,_) |- _] => invc H
  | [H: (Some _,_) = (_,_) |- _] => invc H
  end.

Ltac dosome_eqj :=
  let y := fresh in 
  match goal with
  | [H: match ?x with _ => _ end = (Some _, _)  |- _] =>
    destruct x eqn:y; try solve_by_inversion
  end.

Ltac dosome'' :=
  match goal with
  | [H: (_,_) = (Some _, _) |- _] => invc H
  end.

Ltac domap :=
  let n := fresh in
  match goal with
  | [H: match ?X with _ => _ end _ = (Some _, _) |- _] =>
    destruct X eqn:n; try solve_by_inversion
  end.


Ltac doit' := repeat dosome_eqj;
              repeat break_let;
              repeat do_pair;
              repeat break_let;
              repeat do_pair;
              repeat dosome''.

Ltac doit := repeat doit'.

Ltac haaa :=
  let x:= fresh in
  match goal with
  | [H: context[match ?ee with | Some _ => _ | _ => _ end] |- _] =>
    destruct ee eqn:x;
    try solve_by_inversion
  end; df; eauto.

Ltac stt :=
  cbn in *;
  monad_unfold;
  try solve_by_inversion;
  repeat break_let;
  dosome;
  try haaa.

Ltac dosome_eq' y :=
  match goal with
  | H:match ?x with
      | _ => _
      end _ = (Some _, _) |- _ => destruct x eqn:y; try solve_by_inversion
  end.

Ltac dothat :=
  unfold Cvm_St.st_ev, Cvm_St.st_pl, Cvm_St.st_trace in *;
  try unfold st_ev in *;
  try unfold st_pl in *;
  try unfold st_trace in * .

Ltac ff' :=
  repeat break_match; try solve_by_inversion.

Ltac do_inv_head :=
  let tac := (eapply app_inv_head; eauto) in
  repeat
    match goal with
    | [H: ?ls ++ ?xs = ?ls ++ ?ys |- _] => assert_new_proof_by (xs = ys) tac
    end.


(* CVM execution always succeeds.  
   Note:  This may need revisiting if we consider more robust models of CVM failure. *)
Lemma always_some : forall t vm_st vm_st' op,
    build_cvm t vm_st = (op, vm_st') ->
    op = Some tt.
Proof.
  induction t; intros.
  -
    destruct a; (* asp *)
      try destruct a; (* asp params *)
      try (df; tauto).
  -
    repeat (df; try dohtac; df).
    tauto.
  -
    df.
    
    destruct o eqn:hhh;
      try (df; eauto).
  -
    df.

    repeat break_match;
      try (
          df; eauto).
  -
    df.
    dohtac.
    df.
    simpl.

    assert (o = Some tt) by eauto.
    subst.
    vmsts.
    df.
    tauto.
Defined.

Ltac do_somett :=
  match goal with
  | [H: build_cvm ?t _ = (?o, _)
     |- _] =>
    assert_new_proof_by (o = Some tt) ltac:(eapply always_some; [apply H])
  end.


Ltac clear_triv :=
  match goal with
  | [H: ?x = ?x |- _] => clear H
  end.

Ltac do_asome := repeat do_somett; repeat clear_triv.

Ltac dd :=
  repeat (
      df;
      annogo;
      dosome;
      do_asome;
      subst).
(*
Implementation of the Copland Virtual Machine (CVM).

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import Term_Defs Anno_Term_Defs Cvm_Monad.

Require Import List.
Import ListNotations.

(** Monadic CVM implementation (top-level) *)
Fixpoint build_cvm (t:Core_Term): CVM unit :=
  match t with
  | aspc a =>
      e <- do_prim a ;;
      put_ev e
  | attc q t' =>
    e <- get_ev ;;
    e' <- doRemote t' q e ;;
    put_ev e'
  | lseqc t1 t2 =>
      build_cvm t1 ;;
      build_cvm t2
  | bseqc t1 t2 =>
    split_ev ;;
    e <- get_ev ;;
    build_cvm t1 ;;
    e1r <- get_ev ;;
    put_ev e ;;
    build_cvm t2 ;;
    e2r <- get_ev ;;
    join_seq e1r e2r
  | bparc loc t1 t2 =>
    split_ev ;;
    e <- get_ev ;;
    start_par_thread loc t2 e ;;
    build_cvm t1 ;;
    e1r <- get_ev ;;
    e2r <- wait_par_thread loc t2 e ;;
    join_seq e1r e2r
  end.
(*
Automation scripts.  Some generic, but most specific to this development.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import StructTactics Cvm_Monad Term_Defs Term.
Require Import Coq.Arith.Peano_dec Lia.

Require Export Defs.

(* destruct unit-typed hyps *)
Ltac dunit :=
  match goal with
  | [H:unit |- _] => destruct H
  end.

(* destruct cvm_st hyps + unit-typed hyps *)
Ltac annogo := vmsts; repeat dunit.

(* Run a collection of conservative built-in simplifications and 
   custom unfolders.  *)
Ltac df :=
  repeat (
      cbn in *;
      unfold runSt in *;
      repeat break_let;
      repeat (monad_unfold; cbn in *; find_inversion);
      monad_unfold;
      repeat dunit;
      unfold snd in * ).

(* Common "first swipe" automation tactic throughout this development.  
   Breaks match statements if found, then either solves or simplifies.  *)
Ltac ff := repeat break_match; try solve_by_inversion; df.

(* Destruct specific matches on Option types *)
Ltac dosome :=
  repeat (
      match goal with
      | [H: match ?o with
            | Some _ => _
            | _ => _
            end
            =
            (Some _, _) |- _] =>
        destruct o; try solve_by_inversion
      end; df).

(* Smarter rewriter *)
Ltac subst' :=
  match goal with
  | [H: ?A = _, H2: context[?A] |- _] => rewrite H in *; clear H
  | [H: ?A = _ |- context[?A]] => rewrite H in *; clear H
  end.

(* Same as subst', but does NOT clear hyps after rewriting *)
Ltac subst'' :=
  match goal with
  | [H:?A = _, H2: context [?A] |- _] => rewrite H in *
  | [H:?A = _ |- context [?A]] => rewrite H in *
  end.

Ltac assert_new_proof_as_by H tac n := 
  fail_if_in_hyps_type H;
  assert H as n by tac.

(* Slight (non-existential) variation of `jkjke` from Defs.v *)
Ltac jkjk_s :=
  match goal with
  | H: _ |- _ => rewrite H; reflexivity
  end.

Ltac fail_no_match :=
  match goal with
  | [H: context [match _ with _ => _ end] |- _] => idtac
  | [ |- context [match _ with _ => _ end]] => idtac
  | _ => fail
  end.

Ltac fail_no_match_some :=
  match goal with
  | [H: context [match _ with | Some _ => _ | None => _ end] |- _] => idtac
  | [ |- context [match _ with | Some _ => _ | None => _ end] ] => idtac
  | _ => fail
  end.

Ltac dohtac := fail_no_match_some;
               (*try htac''; *)
               try rewrite PeanoNat.Nat.eqb_refl in *;
               try rewrite PeanoNat.Nat.eqb_eq in *.
 and
 
Lemma es_injective_events : forall es ev0 ev1, well_structured es -> ev_in ev0 es -> ev_in ev1 es -> ev ev0 = ev ev1 -> ev0 = ev1.
Distance: 0.127
 Proof.
intros. revert H2. revert H1. revert H0. revert ev1. revert ev0. induction H; intros; simpl in *. - inv H1; inv H2; auto. - inv H3; inv H4. + eapply IHwell_structured1 in H8; eauto. + apply ws_evsys_range in H8; auto. apply ws_evsys_range in H6; auto. lia. + apply ws_evsys_range in H8; auto. apply ws_evsys_range in H6; auto. lia. + eapply IHwell_structured2 in H8; eauto. - inv H3; inv H4. + eapply IHwell_structured1 in H8; eauto. + apply ws_evsys_range in H8; auto. apply ws_evsys_range in H6; auto. lia. + apply ws_evsys_range in H8; auto. apply ws_evsys_range in H6; auto. lia. + eapply IHwell_structured2 in H8; eauto. Qed.
 
Lemma prec_in_left : forall es ev1 ev2, prec es ev1 ev2 -> ev_in ev1 es.
Distance: 0.134
 Proof.
intros; induction H; auto. Qed.
 
Lemma prec_in_right : forall es ev1 ev2, prec es ev1 ev2 -> ev_in ev2 es.
Distance: 0.135
 Proof.
intros; induction H; auto. Qed.
, and 
 prove that ### Lemma inv_recon_mt: forall ls et,
    reconstruct_evP (evc ls et) mtc ->
    (et = mt). ### 
 - rememberto use any previously proved lemmas in the context to prove the lemma when applicable.

CoqDog: ```coq
Lemma inv_recon_mt: forall ls et,
    reconstruct_evP (evc ls et) mtc ->
    (et = mt).
Proof.
  intros.
  invc H.
  destruct et;
    repeat ff;
    try (unfold OptMonad_Coq.bind in *);
         repeat ff;
         try solve_by_inversion.
                    
         -
           eauto.
Defined.
```

User: Given the context 
 
Lemma inv_recon_mt : forall ls et, reconstruct_evP (evc ls et) mtc -> (et = mt) .
Distance: 0.054
 Proof.
intros. econstructor. eapply peel_fact'; eauto. lia. Qed.
 
Lemma es_injective_events : forall es ev0 ev1, well_structured es -> ev_in ev0 es -> ev_in ev1 es -> ev ev0 = ev ev1 -> ev0 = ev1.
Distance: 0.115
 
Lemma step_pl_eq : forall st0 ev st1, step st0 ev st1 -> pl st0 = pl st1.
Distance: 0.126
 Proof.
intros. induction H; simpl; auto. Qed.
, 
 also use this context """ Ltac do_inv_recon_mt :=
  match goal with
  | [H: reconstruct_evP (evc _ ?et) mtc

     |- _] =>
    assert_new_proof_by (et = mt (* \/ (exists p ps et', et = uu p KILL ps et') \/ (exists p ps et', et = uu p KEEP ps et') *) ) ltac:(eapply inv_recon_mt; apply H)
  end;
  (* door; *)
  subst.

Lemma inv_recon_mt': forall ls e,
    reconstruct_evP (evc ls mt) e ->
    e = mtc.
Proof.
  intros.
  invc H.
  repeat ff; try solve_by_inversion; eauto.
Defined.

Ltac do_inv_recon_mt' :=
  match goal with
  | [H: reconstruct_evP (evc _ mt) ?e

     |- _] =>
    assert_new_proof_by (e = mtc) ltac:(eapply inv_recon_mt'; apply H)
  end;
  subst.
"""  to prove ### Lemma inv_recon_nn: forall ls et n n0,
    reconstruct_evP (evc ls et) (nnc n n0) ->
    ((et = nn n /\ ls = [n0])). ### 
 - remember to use any previously proved lemmas in the context to prove the lemma when applicable.

CoqDog: ```coq
Lemma inv_recon_nn: forall ls et n n0,
    reconstruct_evP (evc ls et) (nnc n n0) ->
    ((et = nn n /\ ls = [n0])).
Proof.
  intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; destruct ls; try solve_by_inversion.
Defined.
```

User: Given the context 
 
Lemma inv_recon_nn : forall ls et n n0, reconstruct_evP (evc ls et) (nnc n n0) -> ((et = nn n /\ ls = [n0]) ).
Distance: 0.053
 Proof.
intros. invc H. destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; try solve_by_inversion. - eauto. Qed.
 
Lemma inv_recon_mt : forall ls et, reconstruct_evP (evc ls et) mtc -> (et = mt) .
Distance: 0.077
 
Lemma es_injective_events : forall es ev0 ev1, well_structured es -> ev_in ev0 es -> ev_in ev1 es -> ev ev0 = ev ev1 -> ev0 = ev1.
Distance: 0.136
, 
 use the following context too """ Ltac do_inv_recon_nn :=
  match goal with
  | [H: reconstruct_evP (evc ?ls ?et) (nnc ?n ?nval)

     |- _] =>
    assert_new_proof_by (et = nn n /\ ls = [nval] ) ltac:(eapply inv_recon_nn; apply H)
  end;
  destruct_conjs;
  subst.""" to prove ### Lemma inv_recon_gg: forall p ps ls et n ec,
    reconstruct_evP (evc ls et) (ggc p ps n ec) ->
    (exists ls' et', et = uu p EXTD ps et' /\
                ls = n :: ls'). ###  
 - remember to use any previously proved lemmas in the context to prove the lemma when applicable.

CoqDog: ```coq
Lemma inv_recon_gg: forall p ps ls et n ec,
    reconstruct_evP (evc ls et) (ggc p ps n ec) ->
    (exists ls' et', et = uu p EXTD ps et' /\
                ls = n :: ls').
Proof.
  intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; try solve_by_inversion.
  -
    repeat eexists.
    destruct ls; ff.
Defined.
```

GPT-4o multi-modal (128k tk)
GPT-4-Turbo (128k tk)
GPT-4 (8k tk)
GPT-3.5 (16K tk)
Full History
Last Response
Use Copland Customized Recommendation SystemDon't Use Recommendation System
Tokens used : 72512
