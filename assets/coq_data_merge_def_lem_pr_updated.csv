item-name,item-body,label_int,label
AM,:= St AM_St,2,Definition
am_newNonce,"(bs:BS) : AM nat :=
  oldSt <- get ;;
  let oldMap := am_nonceMap oldSt in
  let oldId := am_nonceId oldSt in
  let newMap := map_set oldMap oldId bs in
  let newId := oldId + 1 in
  put (mkAM_St newMap newId) ;;
  ret oldId",2,Definition
am_getNonce,"(nid:nat) : AM BS :=
  oldSt <- get ;;
  let oldMap := am_nonceMap oldSt in
  let resopt := map_get oldMap nid in
  match resopt with
  | Some res => ret res
  | None => failm
  end",2,Definition
am_runCvm_nonce,"(t:Term) (p:Plc) (bs:BS) : AM (nat * RawEv) :=
  nid <- am_newNonce bs ;;
  ret (nid, run_cvm_rawEv t p [bs])",2,Definition
empty_amst,":=
  mkAM_St map_empty 0 (* [] [] *)",2,Definition
termsub_transitive,"forall t t' t'',
    term_sub t t' ->
    term_sub t' t'' ->
    term_sub t t''",1,Lemma
termsub_transitive_proof,"generalizeEverythingElse t''.
  induction t'';
    intros H H0; ff.",0,Proof
anno_unanno,"forall t i,
    unanno (snd (anno t i)) = t",1,Lemma
anno_unanno_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros.
  -
    destruct a; ff.
  -
    ff.
    erewrite <- IHt.
    jkjke.
  -
    ff.
    erewrite <- IHt1.
    erewrite <- IHt2.
    jkjke.
    jkjke.
  -
    ff.
    erewrite <- IHt1.
    erewrite <- IHt2.
    jkjke.
    jkjke.
  -
    ff.
    erewrite <- IHt1.
    erewrite <- IHt2.
    jkjke.
    jkjke.",0,Proof
eval_aeval,"forall t p e i,
    eval t p e = aeval (snd (anno t i)) p e",1,Lemma
eval_aeval_proof,"induction t; intros; simpl; auto;
    repeat expand_let_pairs; simpl;
      try (repeat jkjk; auto;congruence);
      try (repeat jkjk'; auto).",0,Proof
same_anno_range,"forall t i a b n n',
    anno t i = (n,a) ->
    anno t i = (n',b) ->
    n = n'",1,Lemma
same_anno_range_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros;
    try destruct a;
    ff.",0,Proof
anno_mono,"forall (t:Term) (i j:nat) (t':AnnoTerm),
  anno t i = (j,t') ->
  j > i",1,Lemma
anno_mono_proof,"induction t; intros; (*i j t' ls b H; *)
    ff;
    repeat find_apply_hyp_hyp;
    lia.",0,Proof
anno_range,"forall x i j t',
     anno x i = (j,t') ->
    range (t') = (i, j)",1,Lemma
anno_range_proof,induction x; intros; ff.,0,Proof
anno_well_formed_r,"forall t i j t',
    anno t i = (j, t') ->
    well_formed_r_annt t'",1,Lemma
anno_well_formed_r_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros.
  -
    destruct a;
      ff.
  -
    ff.
    +
      econstructor.
      eauto.
      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

      simpl.
      assert (n > S i) by (eapply anno_mono; eauto).
      lia.
  -
    ff.
    econstructor.
    eauto.
    eauto.

    simpl.
    erewrite anno_range.
    2: {
        eassumption.
      }
    tauto.

    simpl.
    erewrite anno_range.
    2: {
        eassumption.
      }
    erewrite anno_range.
    2: {
        eassumption.
      }
    tauto.

    simpl.
    erewrite anno_range.
    2: {
        eassumption.
      }
    tauto.
      
  -
    ff.
    econstructor.
    eauto.
    eauto.

     simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

  -
    ff.
    econstructor.
    eauto.
    eauto.

     simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.

      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      erewrite anno_range.
      2: {
        eassumption.
      }
      
      tauto.
      
      simpl.
      erewrite anno_range.
      2: {
        eassumption.
      }
      tauto.",0,Proof
event_id_works,"forall t,
  event_id_span' t = event_id_span (copland_compile t)",1,Lemma
event_id_works_proof,"ith (simpl in *; eauto).
  induction t...
  - destruct a... destruct s...
  - destruct s, s, s0...
  - destruct s, s, s0...",0,Proof
span_range,"forall t i j t',
  anno t i = (j, t') ->
  event_id_span' t = (j - i)",1,Lemma
span_range_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros.
  -
    destruct a;
    try 
    cbn in *;
    find_inversion;
    lia.
  -
    cbn in *.
    repeat break_let.
    find_inversion.
    assert (event_id_span' t = n - (S i)).
    { eauto. }
    rewrite H.
    assert (n > (S i)).
    {
      eapply anno_mono.
      eassumption.
    }
    lia.
  -
    cbn in *.
    repeat break_let.
    repeat find_inversion.
    assert (event_id_span' t1 = (n - i)) by eauto.
    assert (event_id_span' t2 = (j - n)) by eauto.
    repeat jkjke.
    assert (n > i /\ j > n). {
      split; eapply anno_mono; eauto.
    }
    lia.
  -
    cbn in *.
    repeat break_let.
    repeat find_inversion.
    assert (event_id_span' t1 = (n - (S i))) by eauto.
    assert (event_id_span' t2 = (n0 - n)) by eauto.
    repeat jkjke.
    assert (n > S i /\ n0 > n). {
      split; eapply anno_mono; eauto.
    }
    lia.
  -
        cbn in *.
    repeat break_let.
    repeat find_inversion.
    assert (event_id_span' t1 = (n - (S i))) by eauto.
    assert (event_id_span' t2 = (n0 - n)) by eauto.
    repeat jkjke.
    assert (n > S i /\ n0 > n). {
      split; eapply anno_mono; eauto.
    }
    lia.",0,Proof
Range,: Set := nat * nat,2,Definition
range,"x :=
  match x with
  | aasp r _ => r
  | aatt r _ _ => r
  | alseq r _ _ => r
  | abseq r _ _ _ => r
  | abpar r _ _ _ => r
  end",2,Definition
annotated,"x :=
  snd (anno x 0)",2,Definition
ggc_app,"forall p0 sigbs H4 e',
    EvSub (ggc p0 sigbs H4) e' ->
    exists e'',
      EvSub
        (ggc p0 (checkSigF H4 p0 sigbs) e'')
        (build_app_comp_evC e')",1,Lemma
ggc_app_proof,"Allowed.
 *)

Lemma ggc_app: forall p0 sigbs H4 e',
    EvSub (ggc p0 sigbs H4) e' ->
    exists e'',
      EvSub
        (ggc p0 (checkSigF H4 p0 sigbs) e'')
        (build_app_comp_evC e').
Proof.
  intros.
  generalizeEverythingElse e'.
  induction e'; intros;
    ff.
  -
    evSubFacts.
    edestruct IHe'; eauto.
  -
    ff.
    invc H.
    +
      exists ((build_app_comp_evC e')).
      econstructor.
    +
      edestruct IHe'; eauto.
    
  -
    evSubFacts.
    +
      edestruct IHe'1; eauto.
    +
      edestruct IHe'2; eauto.
  -
    evSubFacts.
    +
      edestruct IHe'1; eauto.
    +
      edestruct IHe'2; eauto.",0,Proof
appraisal_correct_sig,"forall t annt e e' p ev,
    annoP annt t ->
    not_none_none t ->
    not_hash_sig_term_ev t e ->
    cvm_evidence_denote annt p e = e' ->

    sigEvent annt p (et_fun e) ev ->
    appEvent_Sig_EvidenceC ev (build_app_comp_evC e')",1,Lemma
appraisal_correct_sig_proof,"intros.
  sigEventFacts.
  sigEventPFacts.

  edestruct gg_preserved'.
  2: { eassumption. }
  2: { eassumption. }
  eassumption.
  eassumption.
  reflexivity.

  destruct_conjs.

  edestruct ggc_app.
  eassumption.

  econstructor.
  dd.
  eassumption.",0,Proof
appraisal_correct,"forall t annt e' p ev e,
    annoP annt t ->
    not_none_none t ->
    cvm_evidence_denote annt p e = e' ->
    measEvent annt p (et_fun e) ev ->
    appEvent_EvidenceC ev (build_app_comp_evC e')",1,Lemma
appraisal_correct_proof,"intros.
  measEventFacts.
  evEventFacts.
  edestruct uu_preserved'.
  eassumption.
  eassumption.
  eassumption.
  reflexivity.

  destruct_conjs.
    (*
    assert (e0 = et_fun H2).
    {
      Search (_ = et_fun _).
      eapply etfun_reconstruct; eauto.
    }
    subst.
     *)

  apply uuc_app in H5.

  assert (e0 = et_fun H2).
  {
    eapply etfun_reconstruct; eauto.
  }
  subst.
  assert (H1 = encodeEv H2).
  {
    
    eapply recon_encodeEv.
    eapply wf_recon.
    eassumption.
    eassumption.
  }
  rewrite H6 in *.

  eapply aeuc.
  eassumption.
  destruct_conjs.

   eapply ahuc.
    eassumption.
    eapply hhc_app.
    eassumption.",0,Proof
appraisal_correct_sig_alt,"forall t annt pt e e' tr tr' p p' bits' et' ev ee i i',
    anno_parP pt t ->
    annoP_indexed annt t i i' -> 
    well_formed_r_annt annt ->
    not_none_none t ->
    not_hash_sig_term_ev t e ->
    wf_ec ee ->
    reconstruct_evP ee e ->
    copland_compile pt
                    {| st_ev := ee; st_trace := tr; st_pl := p; st_evid := i |} =
    (Some tt, {| st_ev := (evc bits' et');
                 st_trace := tr';
                 st_pl := p';
                 st_evid := i'|}) ->

    sigEvent annt p (get_et ee) ev ->
    Some e' = Impl_appraisal",1,Lemma
appraisal_correct_sig_alt_proof,"intros.
  wrap_ccp.
  do_wfec_preserved.
  do_somerecons.
  destruct ee.
  assert (et_fun e = e0).
  {
    symmetry.
    eapply etfun_reconstruct.
    eauto.
  }
  subst.
  
  erewrite appraisal_alt.
  eapply appraisal_correct_sig.
  econstructor. repeat eexists. invc H0. eassumption.
  eassumption.
  eassumption.

 
  eapply cvm_raw_evidence_denote_fact; eauto.
  eassumption.
  eassumption.
  eassumption.
  reflexivity.",0,Proof
appraisal_correct_sig_alt_et,"forall t annt pt bits et et' et'' e e' tr tr' p p' bits' ev i i',
    anno_parP pt t ->
    annoP_indexed annt t i i' ->
    well_formed_r_annt annt ->
    not_none_none t ->
    not_hash_sig_term_ev t e ->
    wf_ec (evc bits et) ->
    et' = aeval annt p et ->
    reconstruct_evP (evc bits et) e ->
    copland_compile pt
                    {| st_ev := (evc bits et); st_trace := tr; st_pl := p; st_evid := i |} =
    (Some tt, {| st_ev := (evc bits' et'');
                 st_trace := tr';
                 st_pl := p';
                 st_evid := i'|}) ->

    sigEvent annt p et ev ->
    Some e' = Impl_appraisal",1,Lemma
appraisal_correct_sig_alt_et_proof,"intros.
  wrap_ccp.
  assert (et'' =  (aeval annt p et)).
  {
    rewrite <- eval_aeval'.
    
    assert (t = unanno annt).
    {
      invc H0.
      erewrite <- anno_unanno at 1.
      rewrite H5.
      tauto.
    }
    subst.
    
    eapply cvm_refines_lts_evidence.
    eassumption.
    eassumption.
  }

  subst.
  invc H7.
  eapply appraisal_correct_sig_alt; eauto.",0,Proof
appraisal_correct_alt,"forall t annt pt e' tr tr' p p' bits' et' ev ee i i',
    anno_parP pt t ->
    annoP_indexed annt t i i' ->
    well_formed_r_annt annt ->
    not_none_none t ->
    wf_ec ee ->
    copland_compile pt
                    {| st_ev := ee; st_trace := tr; st_pl := p; st_evid := i |} =
    (Some tt, {| st_ev := (evc bits' et');
                 st_trace := tr';
                 st_pl := p'; st_evid := i' |}) ->

    measEvent annt p (get_et ee) ev ->
    Some e' = Impl_appraisal",1,Lemma
appraisal_correct_alt_proof,"intros.
  wrap_ccp.
  do_wfec_preserved.
  do_somerecons.
  destruct ee.
  assert (e = et_fun H9).
  {
    eapply etfun_reconstruct.
    eauto.
  }
  subst.
    
  erewrite appraisal_alt.
  eapply appraisal_correct.
  econstructor. repeat eexists. invc H0. eassumption.
  eassumption.
  eapply cvm_raw_evidence_denote_fact; eauto.

  eassumption.
  eassumption.
  eassumption.
  reflexivity.",0,Proof
appraisal_correct_alt_et,"forall t annt pt e' tr tr' p p' bits bits' et et' et'' ev i i',
    anno_parP pt t ->
    annoP_indexed annt t i i' ->
    well_formed_r_annt annt ->
    not_none_none t ->
    wf_ec (evc bits et) ->
    et' = aeval annt p et ->
    copland_compile pt
                    {| st_ev := (evc bits et); st_trace := tr; st_pl := p; st_evid := i |} =
    (Some tt, {| st_ev := (evc bits' et'');
                 st_trace := tr';
                 st_pl := p';
                 st_evid := i'|}) ->

    measEvent annt p et ev ->
    Some e' = Impl_appraisal",1,Lemma
appraisal_correct_alt_et_proof,"intros.
  wrap_ccp.
  assert (et'' = (aeval annt p et)).
  {
    assert (t = unanno annt).
    {
      invc H0.
      erewrite <- anno_unanno at 1.
      rewrite H4.
      tauto.
    }
    subst.

    erewrite <- eval_aeval'.
    eapply cvm_refines_lts_evidence.
    eassumption.
    eassumption.
  }
  
  subst.

  eapply appraisal_correct_alt.
  6: {
    wrap_ccp.
    eassumption.
  }
  eauto.
  eauto.
  eauto.
  eauto.
  eauto.
  eauto.
  eauto.",0,Proof
appraisal_alt,"forall ec1 ec2 ec2' ls et,

  Some ec1 = Impl_appraisal",1,Lemma
appraisal_alt_proof,"intros.
  generalizeEverythingElse ec2.
  induction ec2; intros.
  -
    do_inv_recon.
    ff.
  -
    do_inv_recon.
    repeat ff.
    unfold OptMonad_Coq.bind in *.
    unfold OptMonad_Coq.ret in *.
    repeat ff.
    unfold checkNonceF.
    jkjke.
  -
    do_inv_recon.
    repeat ff.
    unfold OptMonad_Coq.bind in *.
    unfold OptMonad_Coq.ret in *.
    repeat ff.
    
    repeat ff.

    assert (e = (Impl_appraisal_alt.build_app_comp_evC ec2)).
    {
      eapply IHec2.
      jkjke.
      invc H0.
      repeat ff.
      unfold OptMonad_Coq.bind in *.
      unfold OptMonad_Coq.ret in *.
      repeat ff.
      econstructor.
      ff.
      tauto.
    }
    subst.
    unfold checkASPF.
    jkjke.
  -
    do_inv_recon.
    do_recon_inv.
    
    repeat ff.
    unfold OptMonad_Coq.bind in *.
    unfold OptMonad_Coq.ret in *.
    repeat ff.

    assert (e = (Impl_appraisal_alt.build_app_comp_evC ec2)) by eauto.
    subst.
    unfold checkSig.
    unfold checkSigF.
    unfold checkSig.
    assert (checkSigBits H2 p b =
            checkSigBits (encodeEv ec2) p b).
    {
      assert (H2 = encodeEv ec2).
      {
        eapply recon_encodeEv.
        eapply wf_recon.
        eassumption.
        eassumption.
      }
      subst.
      tauto.
    }
    rewrite <- H.
    rewrite Heqo0.
    cbn in *.
    tauto.
  -
    do_inv_recon.
    repeat ff.
    unfold OptMonad_Coq.bind in *.
    unfold OptMonad_Coq.ret in *.
    repeat ff.
    unfold checkHashF.
    jkjke.
  -
    do_inv_recon.
    do_recon_inv. 
    repeat ff.
    unfold OptMonad_Coq.bind in *.
    unfold OptMonad_Coq.ret in *.
    repeat ff.
    assert (e = (Impl_appraisal_alt.build_app_comp_evC ec2_1)) by eauto.
    assert (e0 = (Impl_appraisal_alt.build_app_comp_evC ec2_2)) by eauto. 
    congruence.

  -
    do_inv_recon.
    do_recon_inv.
    repeat ff.
    unfold OptMonad_Coq.bind in *.
    unfold OptMonad_Coq.ret in *.
    repeat ff.
    assert (e = (Impl_appraisal_alt.build_app_comp_evC ec2_1)) by eauto.   
    assert (e0 = (Impl_appraisal_alt.build_app_comp_evC ec2_2)) by eauto.
    congruence.",0,Proof
checkASP,"(params:ASP_PARAMS) (bs:BS) : Opt BS :=
  Some (checkASP' params bs)",2,Definition
checkHH,"(params:ASP_PARAMS) (bs:BS) (e:Evidence) : Opt BS :=
  Some (checkHH' params bs e)",2,Definition
checkEE,"(params:ASP_PARAMS) (bs:BS) : Opt BS := 
Some (checkEE' params bs)",2,Definition
decrypt_bs_to_rawev,"' (bs:BS) (params:ASP_PARAMS) : AM RawEv :=
  ret (decrypt_bs_to_rawev bs params)",2,Definition
check_asp_EXTD,"' (params:ASP_PARAMS) (p:Plc) (sig:BS) (ls:RawEv) : AM BS :=
  ret (check_asp_EXTD params p sig ls)",2,Definition
checkNonce,"' (nid:nat) (nonceCandidate:BS) : AM BS :=
  nonceGolden <- am_getNonce nid ;;
  ret (checkNonce nonceGolden nonceCandidate)",2,Definition
firstn_long,"forall (e:list BS) x,
    length e >= x ->
    length (firstn x e) = x",1,Lemma
firstn_long_proof,"intros.
  eapply firstn_length_le.
  lia.",0,Proof
skipn_long,"forall (e:list BS) x y,
    length e = x + y ->
    length (skipn x e) = y",1,Lemma
skipn_long_proof,"intros.
  assert (length (skipn x e) = length e - x).
  { eapply skipn_length. }
  lia.",0,Proof
peel_fact,"forall e x y H et,
    length e = S x ->
    peel_bs e = Some (y, H) ->
    et_size et = x ->
    wf_ec (evc H et)",1,Lemma
peel_fact_proof,"intros.
  destruct e;
    ff; eauto.",0,Proof
inv_recon_mt,"forall ls et,
    reconstruct_evP (evc ls et) mtc ->
    (et = mt) (* \/ (exists p ps et', et = uu p KILL ps et')
    \/ (exists p ps et', et = uu p KEEP ps et')) *)",1,Lemma
inv_recon_mt_proof,"intros.
  econstructor.
  eapply peel_fact'; eauto.
  lia.",0,Proof
inv_recon_nn,"forall ls et n n0,
    reconstruct_evP (evc ls et) (nnc n n0) ->
    ((et = nn n /\ ls = [n0]) (* \/ (exists p ps et', et = uu p KEEP ps et') *) )",1,Lemma
inv_recon_nn_proof,"intros.
  invc H.
  destruct et;
    repeat ff;
    try (unfold OptMonad_Coq.bind in *);
         repeat ff;
         try solve_by_inversion.
                    
         -
           eauto.
           (*
         -
           right.
           right.
           eauto. *)",0,Proof
inv_recon_gg,"forall p ps ls et n ec,
    reconstruct_evP (evc ls et) (ggc p ps n ec) ->
    (exists ls' et', et = uu p EXTD ps et' /\
                ls = n :: ls') (* \/ (exists p ps et', et = uu p KEEP ps et') *)",1,Lemma
inv_recon_gg_proof,"intros.
  invc H.
  repeat ff; try solve_by_inversion; eauto.",0,Proof
inv_recon_hh,"forall p ps ls et n et',
    reconstruct_evP (evc ls et) (hhc p ps n et') ->
    ((et = uu p COMP ps et' ) /\ ls = [n]) (* \/ (exists p ps et', et = uu p KEEP ps et') *)",1,Lemma
inv_recon_hh_proof,"intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; destruct ls; try solve_by_inversion.

                               (*
                               -
                                 eauto.
                               -
                                 eauto. *)",0,Proof
inv_recon_ee,"forall p ps ls et (*et'*) n ec',
    reconstruct_evP (evc ls et) (eec p ps n (*et'*) ec') ->
    (* (exists et', et = uu p ENCR ps et' ) /\ ls = [n]",1,Lemma
inv_recon_ee_proof,"intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; try solve_by_inversion.
                               -
                                 (*
                                 left. *)
                                 repeat eexists.
                                 destruct ls; ff.
                                 (*
                               -
                                 right.
                                 eauto. *)",0,Proof
inv_recon_kk,"forall p ps ls et et',
    reconstruct_evP (evc ls et) (kkc p ps et') ->
    (et = uu p KILL ps et' ) /\ ls = []",1,Lemma
inv_recon_kk_proof,"intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; destruct ls; try solve_by_inversion.
                               (*
                               -
                                 right. eauto.
                               -
                                 right. eauto. *)",0,Proof
inv_recon_ss,"forall ls et ec1 ec2,
    reconstruct_evP (evc ls et) (ssc ec1 ec2) ->
    (exists et1 et2, et = ss et1 et2) (* \/ (exists p ps et', et = uu p KEEP ps et') *)",1,Lemma
inv_recon_ss_proof,"intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; destruct ls; try solve_by_inversion.
                               -
                                 (*
                                 left. *)
                               repeat eexists.
                               ff.
                               (*
                               -
                                 right. eauto.
                               -
                                 right. eauto. *)",0,Proof
recon_inv_gg,"forall sig ls p ps et e,
    reconstruct_evP
      (evc (sig :: ls) (uu p EXTD ps et))
      (ggc p ps sig e) ->
    reconstruct_evP (evc ls et) e",1,Lemma
recon_inv_gg_proof,"intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff; destruct ls; try solve_by_inversion.",0,Proof
recon_inv_ss,"forall ls H1 H2 ec1 ec2,
    reconstruct_evP (evc ls (ss H1 H2)) (ssc ec1 ec2) ->
    reconstruct_evP (evc (firstn (et_size H1) ls) H1) ec1 /\
    reconstruct_evP (evc (skipn (et_size H1) ls) H2)  ec2",1,Lemma
recon_inv_ss_proof,"intros.
  invc H.
  destruct et; repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff; try solve_by_inversion.
                               -
                                 (*
                                 right. *)  eauto.
                                            (* 
                               -
                               left. eauto.
                                             *)",0,Proof
wrap_reconP,"forall ec e,
    reconstruct_ev ec = Some e ->
    reconstruct_evP ec e",1,Lemma
wrap_reconP_proof,"intros.
  invc H.
  repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff;
  econstructor.
  symmetry.
  tauto.",0,Proof
fold_recev,"forall e0 e1,
    reconstruct_ev' e0 e1 = reconstruct_ev (evc e0 e1)",1,Lemma
fold_recev_proof,"intros.
  invc H.
  repeat ff; try (unfold OptMonad_Coq.bind in *); repeat ff;
  split;
    econstructor;
    try 
      symmetry; eassumption.",0,Proof
etfun_reconstruct,"forall e e0 e1,
    reconstruct_evP (evc e0 e1) e ->
    e1 = et_fun e (* \/ (exists p ps et', e1 = uu p KEEP ps et' /\ et' = et_fun e) *)",1,Lemma
etfun_reconstruct_proof,"intros.
  econstructor.
  congruence.",0,Proof
wfec_split,"forall e s,
    wf_ec e ->
    wf_ec (splitEv_l s e) /\ wf_ec (splitEv_r s e)",1,Lemma
wfec_split_proof,"ff.
  tauto.",0,Proof
recon_encodeEv,"forall bits et ec,
    reconstruct_evP (evc bits et) ec ->
    encodeEv ec = bits",1,Lemma
recon_encodeEv_proof,"intros.
  generalizeEverythingElse e1.

  (*
  induction e1; intros e e0 H;
    do_inv_recon;
    ff.
  -
    invc H.
    repeat ff;
      try (unfold OptMonad_Coq.bind in * );
           repeat ff.
  -
    invc H;
      ff;
      try (unfold OptMonad_Coq.bind in * );
      destruct f;    try (unfold OptMonad_Coq.bind in * );
      try (ff; tauto).
    +
      ff.
      assert (e1 = et_fun e2).
      eapply IHe1.
      econstructor; eauto.
      subst.
      tauto.
    +
      ff.
      
      
      
      
      
      eauto.
      tauto.
    ff.
    repeat ff;
      try (unfold OptMonad_Coq.bind in * );
           repeat ff.
           +
             assert (e1 = et_fun e2).
             eapply IHe1.
             econstructor; eauto.
             subst.
             tauto.
           +

             Locate et_fun.
             Locate reconstruct_ev.
             
 *)
             
             
                      
   


  
  induction e1; intros e e0 H.
  - (* mt case *)
    invc H.
    ff.
    tauto.
  - (* nn case *)
    invc H.
    repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    
    
    

  (* 
    try (
    do_inv_recon;
    ff;
    invc H;
    repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff;
    rewrite fold_recev in *;
    do_wrap_reconP;
    repeat jkjke).
   *)
  
  - (* uu case *)
    destruct f; ff.
    + (* COMP case *)
      invc H.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    + (* ENCR case *)
      (*
      Print et_fun.
      Print do_inv_recon_ee.
      Print do_inv_recon_ee.
      Locate reconstruct_ev.
       *)
      
      invc H.
      unfold reconstruct_ev in *.
      unfold reconstruct_ev' in *.
      unfold OptMonad_Coq.bind in *.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
           
    + (* EXTD case *)
      (* left. *)
      invc H.
      ff.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
      assert (e1 = et_fun e2 (* \/ (exists (p : Plc) (ps : ASP_PARAMS) (et' : Evidence),
                                   e1 = uu p KEEP ps et' /\ et' = et_fun e2) *) ).
      {
      eapply IHe1.
      econstructor.
      ff.
      }
      (*
      door.
      ++ *)
        
      congruence.
      (*
      ++
        
        
      subst.
      
      
      congruence. *)
    + (* KILL case *)
      invc H.
      unfold reconstruct_ev in *.
      ff.
    + (* KEEP case *)
      invc H.
      unfold reconstruct_ev in *.
      ff.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
      assert (e1 = et_fun e2).
      { eapply IHe1.
        econstructor.
        unfold reconstruct_ev.
        symmetry.
        eassumption.
      }
      subst.
      tauto.
  - (* ss case *)
    invc H.
    ff.
    repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    assert (e1_1 = et_fun e1).
    {
      eapply IHe1_1.
      econstructor.
      symmetry.
      eassumption.
    }
    assert (e1_2 = et_fun e2).
    {
      eapply IHe1_2.
      econstructor.
      symmetry.
      eassumption.
    }
    congruence.",0,Proof
recon_encodeEv_Raw,"forall ec bits et,
    reconstruct_evP (evc bits et) ec ->
    encodeEvRaw (encodeEv ec) = encodeEvBits (evc bits et)",1,Lemma
recon_encodeEv_Raw_proof,"intros.
  split;
    destruct s; ff; try unfold mt_evc; ff;
      econstructor; ff.",0,Proof
wfec_recon,"forall (ee:EvC) (ec:EvidenceC),
    reconstruct_evP ee ec ->
    wf_ec ee",1,Lemma
wfec_recon_proof,"intros.
  generalizeEverythingElse ec.
  induction ec; intros.
  -
    dd.
    do_inv_recon.
    invc H.
    repeat ff.
    (*
    invc H.
    repeat ff. *)
  - (* nnc case *)
    do_inv_recon.
    ff.
  - (* ggc case *)
    do_inv_recon.
    ff.
    invc H.
    repeat ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    assert (reconstruct_evP (evc H0 H1) e).
    {
      econstructor; eauto.
    }
    assert (encodeEv e = H0) by eauto.
    congruence.
  - (* hhc case *)
    do_inv_recon.
    ff.
  - (* eec case *)
    
    do_inv_recon.
    ff.

    (*
  -
    do_inv_recon.
    ff. 
     *)

  - (* kkc case *)
    do_inv_recon.
    ff.
    invc H.
    ff.
    unfold reconstruct_ev' in *.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    rewrite fold_recev in *.
    unfold reconstruct_ev in *.
    unfold reconstruct_ev' in *.
    destruct et; try solve_by_inversion.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.


  - (* kpc case *)
    ff.

    assert (exists et', et = uu p KEEP a et').
    {
      destruct et; try solve_by_inversion.
      +
        invc H.
        ff.
      +
        invc H.
        ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
      +
        invc H.
        ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
        eexists.
        tauto.
      +
        invc H.
        ff.
        repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    }
    
    destruct_conjs.
    subst.

    invc H.
    ff.
    repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    eapply IHec.
    econstructor.
    ff.
    
    
    
    
    
    
  - (* ssc case *)
    do_inv_recon.
    ff.
    invc H.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    rewrite fold_recev in *.
    do_wrap_reconP.
    
    
    assert (encodeEv e =  (firstn (et_size H0) bits)) by eauto.
    assert (encodeEv e0 = (skipn (et_size H0) bits)) by eauto.

    assert (bits = firstn (et_size H0) bits ++ skipn (et_size H0) bits).
    {
      symmetry.
      eapply firstn_skipn.
    }
    rewrite H3 at 1.
    congruence.",0,Proof
reconP_determ,"forall ec e e',
    reconstruct_evP ec e ->
    reconstruct_evP ec e' ->
    e = e'",1,Lemma
reconP_determ_proof,"intros.
  unfold encodeEvBits.
  erewrite recon_encodeEv.
  tauto.
  eauto.",0,Proof
some_recons,"forall (e:EvC),
    wf_ec e ->
    exists (ee:EvidenceC), Some ee = reconstruct_ev e",1,Lemma
some_recons_proof,"intros.
  generalizeEverythingElse ec.
  induction ec; intros; destruct ee.
  - (* mtc case *)
    do_inv_recon.
    dd.
    invc H.
    dd.
    ff.
    econstructor. tauto.
    (* 
    invc H.
    repeat ff. *)
    (*
    econstructor. tauto. *)
  - (* nnc case *)
    do_inv_recon.
    invc H.
    dd.
    econstructor; tauto.
  - (* ggc case *)
    do_inv_recon.
    invc H.
    dd.
    ff.
    unfold OptMonad_Coq.bind in *.
    ff.
    assert (wf_ec (evc H0 H1)).
    {
      apply IHec.
      econstructor.
      eauto.
    }
    econstructor.
    dd.
    invc H.
    lia.

  - (* hhc case *)
    do_inv_recon.
    invc H.
    dd.
    econstructor; tauto.
  - (* eec case *)
    do_inv_recon.
    invc H.
    dd.
    econstructor; tauto.
    (*
  -
    do_inv_recon.
    invc H.
    econstructor; tauto.   
     *)

  - (* kkc case *)
    invc H.
    unfold reconstruct_ev in *.
    unfold reconstruct_ev' in *.
    destruct e0; try solve_by_inversion.
    ff.
    unfold OptMonad_Coq.bind in *. ff.
    unfold OptMonad_Coq.bind in *. ff.
    econstructor.
    ff.
    unfold OptMonad_Coq.bind in *. ff.
  - (* kpc case *)
    invc H.
    destruct e; try solve_by_inversion.
    +
      ff.
    +
      ff.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
    +
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
      assert (wf_ec (evc r e)).
      {
        eapply IHec. econstructor.
        symmetry. eassumption. }
      econstructor.
      ff.
    +
      ff.
      repeat ff; try (unfold OptMonad_Coq.bind in * ); repeat ff.
   
  -
    do_inv_recon.
    invc H.
    dd.
    ff.
    unfold OptMonad_Coq.bind in *.
    
    ff.

    assert (wf_ec (evc (firstn (et_size H0) r) H0)).
    {
      apply IHec1.
      econstructor.
      eauto.
    }
    assert (wf_ec (evc (skipn (et_size H0) r) H1)).
    {
      apply IHec2.
      econstructor.
      eauto.
    }
    
    econstructor.
    dd.
    invc H.
    invc H2.
    rewrite <- H4.
    rewrite <- H3.
    assert (r = firstn (et_size H0) r ++ skipn (et_size H0) r).
    {
      symmetry.
      eapply firstn_skipn.
    }
    rewrite H at 1.
    eapply app_length.",0,Proof
some_reconsP,"forall e,
    wf_ec e ->
    exists ee, reconstruct_evP e ee",1,Lemma
some_reconsP_proof,"intros.
  invc H; invc H0.
  repeat jkjke'.
  ff.",0,Proof
event_id_spans_same,"forall t,
    event_id_span' t = event_id_span (copland_compile t)",1,Lemma
event_id_spans_same_proof,"intros.
  destruct e;
    ff; eauto.",0,Proof
cvm_spans,"forall t pt e tr p i e' tr' p' i',
    term_to_coreP t pt ->
    build_cvmP
      pt
      {| st_ev := e;
         st_trace := tr;
         st_pl := p;
         st_evid := i |}
      (Some tt)
      {|
        st_ev := e';
        st_trace := tr';
        st_pl := p';
        st_evid := i'
      |} ->
    i' = i + event_id_span' t",1,Lemma
cvm_spans_proof,"intros.
  destruct e.
  generalizeEverythingElse e.
  induction e; intros.
  -
  try (repeat ff; eauto; tauto).
    try
      ( inv_wfec; ff;
        do_some_recons');
    try (
        repeat do_rcih;
        destruct_conjs;
        repeat jkjke');
    try ( inv_wfec; ff;
          repeat do_rcih;
          destruct_conjs;
          repeat jkjke';
          repeat ff; eauto).

  - (* nn case *)
    repeat ff.
    (unfold OptMonad_Coq.bind in * ).
     repeat ff.
     +
     eauto.
     +
       inv_wfec.
       ff.
       destruct r; try solve_by_inversion.
       ff.
       unfold OptMonad_Coq.ret in *.
       repeat ff.
       

     +
       destruct r; try solve_by_inversion.
       ff.
       invc H.
       ff.


    
  - (* uu case *)

    destruct f.
    
    + (* COMP case *)

      inv_wfec.
      ff.
      repeat ff;
    (unfold OptMonad_Coq.bind in * );
    repeat ff; eauto.

      ++
       ff.
       assert (exists v, r = [v]).
       {
         destruct r; ff.
         destruct r; ff. }
       destruct_conjs. subst.
       ff.
      ++
       assert (exists v, r = [v]).
       {
         destruct r; ff. }
       destruct_conjs. subst.
       ff.
    + (* ENCR case *)

      inv_wfec.
      ff.
      repeat ff;
    (unfold OptMonad_Coq.bind in * );
    repeat ff; eauto.
      ++
         ff.
       assert (exists v, r = [v]).
       {
         destruct r; ff.
         destruct r; ff. }
       destruct_conjs. subst.
       ff.
      ++
       assert (exists v, r = [v]).
       {
         destruct r; ff. }
       destruct_conjs. subst.
       ff.
    + (* EXTD case *)
      inv_wfec.
      ff.
      unfold OptMonad_Coq.bind in * ;
        repeat ff; eauto.
      ++
        assert (wf_ec (evc r0 e)).
        {
          eapply peel_fact.
          eassumption.
          eassumption.
          tauto.
        }
       
          
          
        assert (exists ee, Some ee = reconstruct_ev' r0 e).
        {
          invc H.
          eapply IHe.
         econstructor. eassumption. }
        destruct_conjs.
        ff.
      ++
         inv_wfec.
       ff.
       assert (r = []).
       {
         destruct r; ff.
       }
       subst.
       ff.
    + (* KILL case *)
      inv_wfec.
      ff.
      eauto.
    + (* KEEP case *)
      inv_wfec.
      simpl in H1.
      ff.

    repeat ff;
    (unfold OptMonad_Coq.bind in * );
    repeat ff; eauto.
    assert (exists ee, Some ee = reconstruct_ev' r e).
    { eapply IHe.
      econstructor.
      eassumption.
    }
    destruct_conjs.
    congruence.




    (*



    
     +
       inv_wfec.
       ff.
       assert (exists v, r = [v]).
       {
         destruct r; ff.
         destruct r; ff. }
       destruct_conjs. subst.
       ff.
     +
       inv_wfec.
       assert (r = []).
       {
         destruct r; ff. }
       subst.
       ff.
     +
       inv_wfec.
       ff.
       assert (exists v, r = [v]).
       { destruct r; ff.
       destruct r; ff. }
       destruct_conjs.
       subst.
       ff.
     +
       inv_wfec.
       ff.
       assert (exists v, r = [v]).
       { destruct r; ff. }
       destruct_conjs.
       subst.
       ff.
     +
       inv_wfec.
       ff.
       destruct r; ff.
       unfold OptMonad_Coq.ret in *.
       ff.
       assert (exists ee, Some ee = reconstruct_ev' r0 e).
       { eapply IHe.
         econstructor. eassumption. }
       destruct_conjs.
       rewrite <- H1 in *.
       solve_by_inversion.
     +
       inv_wfec.
       ff.
       assert (r = []).
       {
         destruct r; ff.
       }
       subst.
       ff.
     +
       inv_wfec.
       ff.
       
       
       
       
       
       
      (* 
       
       
     
     +
       inv_wfec.
       ff.
       eapply peel_fact.
     eauto.
     +
       inv_wfec.
       assert (wf_ec (evc r0 e)).
       {
         eapply peel_fact; eauto.
       }
       ff.
     +
       destruct r; try solve_by_inversion.
       ff.
       invc H.
       ff.

         -
    repeat ff.
    (unfold OptMonad_Coq.bind in * ).
     repeat ff.
     +
     eauto.
     +
       inv_wfec.
       ff.
       destruct r; try solve_by_inversion.
       ff.
       unfold OptMonad_Coq.ret in *.
       repeat ff.
       

     +
       destruct r; try solve_by_inversion.
       ff.
       invc H.
       ff.
       *)
     +
       inv_wfec.
       ff.
       edestruct IHe.
       econstructor.
       eassumption.
       asdf
       
       *)
         
       
    
     - (* ss case *)
       try (ff; eauto; tauto).
       inv_wfec; ff.
    do_rcih.
    do_rcih.
    destruct_conjs.
    jkjke'.
    jkjke'.
    ff.
    eauto.",0,Proof
span_cvm,"forall atp t annt i j e e' tr tr' p p' i',
    build_cvmP
      atp
      {| st_ev := e;
         st_trace := tr;
         st_pl := p;
         st_evid := i |} 
      (Some tt)
      {| st_ev := e';
         st_trace := tr';
         st_pl := p';
         st_evid := i' |} ->
    
    term_to_coreP t atp -> 
    anno t i = (j, annt) ->
    j = i'",1,Lemma
span_cvm_proof,"intros.
  edestruct some_recons.
  eassumption.
  eexists.
  econstructor.
  eassumption.",0,Proof
anno_span_cvm,"forall t pt annt i i' e e' p p' tr tr' st_evid1,
    annoP_indexed annt t i i' ->
    term_to_coreP t pt ->
    build_cvmP pt
                     {|
                       st_ev := e ;
                       st_trace := tr ;
                       st_pl := p;
                       st_evid := i
                     |} (Some tt)
                     {|
                       st_ev := e';
                       st_trace := tr';
                       st_pl := p';
                       st_evid := st_evid1
                     |} ->
    i' = st_evid1",1,Lemma
anno_span_cvm_proof,"intros.
  induction t; ff.
  -
    destruct a; ff; try tauto.
    (* 
    +
      destruct s; ff.
  -
    jkjke'.
  -
    destruct s0; ff; lia.
  -
    destruct s0; ff; lia. *)",0,Proof
wfec_firstn,"forall e0 e1 e2,
    wf_ec (evc e0 e1) ->
    firstn (et_size e1) (e0 ++ e2) = e0",1,Lemma
wfec_firstn_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros;
    wrap_ccp_anno.

  
 (*   (* This is more automated, but slower *)
    try (
        destruct a;
        try destruct a;
        ff; tauto);
    try (
        repeat find_apply_hyp_hyp;
        lia).",0,Proof
wfec_skipn,"forall e0 e1 e2,
    wf_ec (evc e0 e1) ->
    skipn (et_size e1) (e0 ++ e2) = e2",1,Lemma
wfec_skipn_proof,"intros.
  assert (j = i + event_id_span' t).
  {
    assert (j - i = event_id_span' t).
    {
      symmetry.
      eapply span_range.
      eauto.
    }
    rewrite <- H2.
    assert (j > i).
    {
      eapply anno_mono; eauto.
    }
    lia.
  }
  subst.
  symmetry.
  eapply cvm_spans; eauto.",0,Proof
wf_ec_preserved_by_cvm,"forall e e' t1 tr tr' p p' i i',
    wf_ec e ->
        build_cvmP t1
                    {| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |}
                    (Some tt)
                    {| st_ev := e'; st_trace := tr'; st_pl := p'; st_evid := i' |} ->
    wf_ec (e')",1,Lemma
wf_ec_preserved_by_cvm_proof,"intros.
  invc H.
  eapply span_cvm; eauto.",0,Proof
cvm_ev_denote_evtype,"forall annt p e,
    (*annoP annt t -> *)
    et_fun (cvm_evidence_denote annt p e) = (aeval annt p (et_fun e))",1,Lemma
cvm_ev_denote_evtype_proof,"intros.
  inv_wfec.
  jkjke'.
  eapply More_lists.firstn_append.",0,Proof
exists_some_cc,"forall t st,
    exists st',
      build_cvm t st = (Some tt, st')",1,Lemma
exists_some_cc_proof,"intros.
  inv_wfec.
  jkjke'.
  eapply More_lists.skipn_append.",0,Proof
stating,"CVM traces are ""cumulative"" (or monotonic)",1,Lemma
stating_proof,"intros.
  generalizeEverythingElse t1.
  induction t1; intros.
  -
    rewrite <- ccp_iff_cc in *.
    destruct a; (* asp *)
      try destruct a; (* asp params *)
      ff;
      inv_wfec;
      try (
          econstructor;
          ff;
          try tauto;
          try congruence).
    +
      destruct f.
      ++
        ff.
        econstructor.
        ff.
      ++
        ff.
        econstructor.
        ff.
      ++
        ff.
        econstructor.
        ff.
        (* 
        congruence. *)
      ++
        ff.
        econstructor.
        ff.
      ++
        ff.
        econstructor.
        ff.
        
        
  -
    wrap_ccp.

    eapply wf_ec_preserved_remote; eauto.

  -
    wrap_ccp.
    eauto.
  -
    wrap_ccp.

    (*

    do_wfec_split. *)

    find_apply_hyp_hyp.
    find_apply_hyp_hyp.
    econstructor.
    dd.
    inv_wfec.
    repeat jkjke'.
    eapply app_length.

  -
    wrap_ccp.

    (*
    
    do_wfec_split. *)

    find_apply_hyp_hyp.

      inv_wfec;
      ff;
      econstructor;
      dd;
      repeat jkjke'.

    erewrite app_length.

    assert (wf_ec (evc r0 e1)).
    {
      rewrite <- Heqe1.
      eapply wf_ec_preserved_par.
      econstructor; eassumption.
    }

    solve_by_inversion.",0,Proof
stating,"CVM traces are ""cumulative"" (or monotonic)",1,Lemma
stating_proof,"intros.
  generalizeEverythingElse annt.
  induction annt; intros.
  -
    dd.
    destruct a; dd;
      try eauto.
    +
      destruct f; ff.
      destruct s; ff.
      destruct s; ff.
  -
    dd.
    eauto.
  -
    dd.
    assert (et_fun (cvm_evidence_denote annt1 p e) = aeval annt1 p (et_fun e)) by eauto.
    repeat jkjke.
  -
    dd.
    jkjke.
    jkjke.
    destruct s; destruct s; destruct s0; eauto.
  -
    dd.
    jkjke.
    jkjke.
    destruct s; destruct s; destruct s0; eauto.",0,Proof
suffix_prop,"forall t e e' tr tr' p p' i i',
    build_cvmP t
           {| st_ev := e;
              st_trace := tr;
              st_pl := p;
              st_evid := i |}
           (Some tt)
           {|
             st_ev := e';
             st_trace := tr';
             st_pl := p';
             st_evid := i' |} ->
    exists l, tr' = tr ++ l",1,Lemma
suffix_prop_proof,"intros.
  destruct (build_cvm t st) eqn:ee.
  do_asome.
  subst.
  eauto.",0,Proof
alseq_decomp,"forall t1' t2' e e'' p p'' tr i i'',
    build_cvmP
      (lseqc t1' t2')
      {| st_ev := e;
         st_trace := [];
         st_pl := p;
         st_evid := i |}
      (Some tt)
      {| st_ev := e'';
         st_trace := tr;
         st_pl := p'';
         st_evid := i'' |} ->

    exists e' tr' p' i',
      build_cvmP
        t1'
        {| st_ev := e;
           st_trace := [];
           st_pl := p;
           st_evid := i |}
        (Some  tt)
        {| st_ev := e';
           st_trace := tr';
           st_pl := p';
           st_evid := i' |} /\
      exists tr'',
        build_cvmP
          t2'
          {| st_ev := e';
             st_trace := [];
             st_pl := p';
             st_evid := i' |}
          (Some tt)
          {| st_ev := e'';
             st_trace := tr'';
             st_pl := p'';
             st_evid := i'' |} /\
        tr = tr' ++ tr''",1,Lemma
alseq_decomp_proof,"induction t; intros.
  -
    wrap_ccp.
    
    destruct a; (* asp *)
      try destruct a; (* asp params *)
      simpl;
      df;
      repeat rewrite app_assoc;
      reflexivity.
  -
    wrap_ccp.
    repeat rewrite app_assoc.
    reflexivity.

  - (* alseq case *)
    wrap_ccp_dohi.
     
    cumul_ih.
    dd.
    repeat do_st_trace.
    repeat find_rw_in_goal.
    eauto.

  - (* abseq case *)
    wrap_ccp_dohi.
    repeat rewrite <- app_assoc in *.
    cumul_ih.
    dd.
    cumul_ih.
    dd.
    rewrite app_assoc.
    eauto.
    
  - (* abpar case *)
    wrap_ccp_dohi.
    repeat rewrite <- app_assoc in *.
    cumul_ih.
    dd.
    repeat rewrite app_assoc.
    eauto.",0,Proof
restl,"forall t e e' x tr p p' i i',
    build_cvmP t
                     {| st_ev := e; st_trace := x; st_pl := p; st_evid := i|}
                     (Some tt)
                     {| st_ev := e'; st_trace := x ++ tr; st_pl := p'; st_evid := i' |} ->

    build_cvmP t
                     {| st_ev := e; st_trace := []; st_pl := p; st_evid := i |}
                     (Some tt)
                     {| st_ev := e'; st_trace := tr; st_pl := p'; st_evid := i' |}",1,Lemma
restl_proof,"intros.
  eapply st_trace_cumul''; eauto.
  repeat rewrite app_nil_r.
  eauto.",0,Proof
par_evidence_r,"forall l p bits bits' et et' t2,
    parallel_vm_thread l (copland_compile t2) p (evc bits et) = evc bits' et' ->
    et' = eval t2 p et",1,Lemma
par_evidence_r_proof,"intros.

  do_exists_some_cc t {| st_ev := e; st_trace := []; st_pl := p; st_evid := i |}.
  wrap_ccp.
  (*

  rewrite ccp_iff_cc in *. *)

  repeat do_st_trace_assumps.
  repeat find_rw_in_goal.
  eexists.

  erewrite st_trace_cumul''.
  3: {
    eassumption.
  }
  simpl.
  tauto.
  rewrite app_nil_r.
  eassumption.",0,Proof
cvm_refines_lts_evidence,"forall t t' tr tr' bits bits' et et' p p' i i',
    term_to_coreP t t' ->
    build_cvmP t'
                     (mk_st (evc bits et) tr p i)
                     (Some tt)
                     (mk_st (evc bits' et') tr' p' i') ->
    et' = (Term_Defs",1,Lemma
cvm_refines_lts_evidence_proof,"intros.
  wrap_ccp_dohi.
  
  eexists.
  eexists.
  eexists.
  eexists.

  split.
  +
    eassumption.
  +
    do_exists_some_cc t2' {| st_ev := st_ev0; st_trace := []; st_pl := st_pl0; st_evid := st_evid0 |}.
    vmsts.

    eexists.

    wrap_ccp_dohi.

    split.
    ++
      eassumption.
    ++
      repeat do_st_trace.
      repeat find_rw_in_goal.
      eapply st_trace_cumul'; 
        eassumption.",0,Proof
cvm_raw_evidence_denote_fact,"forall t annt t' tr tr' bits bits' et et' p p' i i' ec ec',
    build_cvmP t
                     (mk_st (evc bits et) tr p i)
                     (Some tt)
                     (mk_st (evc bits' et') tr' p' i') ->
    term_to_coreP t' t ->
    annoP_indexed annt t' i i' ->

    reconstruct_evP (evc bits et) ec ->
    reconstruct_evP (evc bits' et') ec' ->

    cvm_evidence_denote annt p ec = ec'",1,Lemma
cvm_raw_evidence_denote_fact_proof,"intros.

  do_exists_some_cc t  {| st_ev := e; st_trace := []; st_pl := p; st_evid := i |}.
  wrap_ccp_dohi.

  assert (st_trace = tr).
  {
    do_st_trace.
    rewrite H0; clear H0.
    assert (tr = st_trace).
    {
      assert (Cvm_St.st_trace {| st_ev := st_ev; st_trace := x ++ tr; st_pl := st_pl; st_evid := st_evid|} =
              x ++ Cvm_St.st_trace {| st_ev := st_ev; st_trace := st_trace; st_pl := st_pl; st_evid := st_evid |}).
      {
        eapply st_trace_cumul'; 
        eassumption.
      }
      simpl in *.
      eapply app_inv_head; eauto.
    }
    jkjke.
  }
  congruence.",0,Proof
cvm_raw_evidence_denote_fact_eval,"forall t annt t' tr tr' bits bits' et et' p p' i i' ec ec',
    build_cvmP t
                     (mk_st (evc bits et) tr p i)
                     (Some tt)
                     (mk_st (evc bits' et') tr' p' i') ->
    term_to_coreP t' t ->
    annoP_indexed annt t' i i' ->

    reconstruct_evP (evc bits et) ec ->
    reconstruct_evP (evc bits' (eval t' p et)) ec' ->

    cvm_evidence_denote annt p ec = ec'",1,Lemma
cvm_raw_evidence_denote_fact_eval_proof,"induction t1; intros;
    repeat ff;
    repeat jkjke.",0,Proof
anno_parP_redo,"forall t pt loc loc',
    anno_par_list' t loc = Some (loc', pt) ->
    anno_parP pt t",1,Lemma
anno_parP_redo_proof,"intros.
  rewrite par_evidence in H.
  rewrite <- at_evidence in H.
  rewrite <- remote_Evidence_Type_Axiom with (bits := bits).
  rewrite H.
  simpl.
  tauto.",0,Proof
anno_parPloc_redo,"forall t pt loc loc',
    anno_par t loc = (loc', pt) ->
    anno_parPloc pt t loc",1,Lemma
anno_parPloc_redo_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros.
  
  - (* aasp case *)
    rewrite <- ccp_iff_cc in *.
    subst.
    destruct a;
      (try dd; eauto).
    +
      destruct s; dd.
      destruct f; dd; eauto.
      unfold mt_evc in *.
      ff.
      destruct f; dd; eauto.
      unfold mt_evc in *.
      ff.
      unfold mt_evc in *.
      ff.

      

  - (* at case *)
    rewrite <- ccp_iff_cc in *.
    dd.
    erewrite <- remote_Evidence_Type_Axiom.
    jkjke.

  - (* alseq case *)
    do_suffix blah.
    destruct_conjs.
    subst.

    edestruct alseq_decomp.
    eapply restl.
    eassumption.
    destruct_conjs.

    wrap_ccp.
    
    destruct x.
    repeat jkjke'.
    
  - (* abseq case *)

    (*
    do_suffix blah.
    do_suffix blah'. *)

    wrap_ccp.

    destruct s0; destruct s1; ff.
    +
      wrap_ccp.
      assert (e = eval t1 st_pl1 et) by eauto.

      assert (e0 = eval t2 st_pl1 et) by eauto.
      congruence.
    +
      wrap_ccp.
      assert (e = eval t1 st_pl1 et) by eauto.

      assert (e0 = eval t2 st_pl1 mt) by eauto.
      congruence.
    +
      wrap_ccp.
      assert (e = eval t1 st_pl1 mt) by eauto.

      assert (e0 = eval t2 st_pl1 et) by eauto.
      congruence.
    +
      wrap_ccp.
      assert (e = eval t1 st_pl1 mt) by eauto.

      assert (e0 = eval t2 st_pl1 mt) by eauto.
      congruence.
      
   - (* abpar case *)

    (*
    do_suffix blah.
    do_suffix blah'. *)

    wrap_ccp.

    destruct s0; destruct s1; ff.
    +
      wrap_ccp.
      assert (e = eval t1 p et) by eauto.

      assert (e0 = eval t2 p et).
      {
        eapply par_evidence_r.
        eassumption.
      }
      congruence.
      
    +
      wrap_ccp.
      assert (e = eval t1 p et) by eauto.

      assert (e0 = eval t2 p mt).
      {
        rewrite par_evidence_clear in Heqe0.

        eapply par_evidence_r.
        eassumption.
      }
      
      congruence.
    +
      wrap_ccp.
      assert (e = eval t1 p mt) by eauto.

      assert (e0 = eval t2 p et).
      {
        eapply par_evidence_r.
        eassumption.
      }
      congruence.
    +
      wrap_ccp.
      assert (e = eval t1 p mt) by eauto.

      assert (e0 = eval t2 p mt).
      {
        rewrite par_evidence_clear in Heqe0.

        eapply par_evidence_r.
        eassumption.
      }
      congruence.",0,Proof
anno_parPloc_redo,"forall t pt loc loc',
    anno_par_list' t loc = Some (loc', pt) ->
    anno_parPloc pt t loc",1,Lemma
anno_parPloc_redo_proof,"intros.
  invc H.
  eapply cvm_refines_lts_evidence'.
  eauto.",0,Proof
peel_bs,"(ls:RawEv) : Opt (BS * RawEv) :=
  match ls with
  | bs :: ls' => ret (bs, ls')
  | _ => failm
  end",2,Definition
peel_bs_proof,"intros.
  generalizeEverythingElse t'.
  induction t'; intros.
  -
    wrap_ccp_anno.
    
    destruct a. (* wrap_ccp_anno. *)
    + (* NULL case *)
      wrap_ccp_anno.
      ff.
      invc H3.
      dd.
      tauto.   
    + (* CPY case *)
      wrap_ccp_anno.
      dd.
      eapply reconP_determ; eauto.

    + (* ASPC case *)
      wrap_ccp_anno.
      ff.
      ++ (* COMP case *)
        wrap_ccp_anno.
        invc H3.
        ff.
        assert (bits = encodeEv ec).
        {
          symmetry.
          invc H2.
          eapply recon_encodeEv.
          econstructor.
          eassumption.
        }
        subst.

        assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        eassumption.
      }
      congruence.
      ++ (* COMP NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
      ++ (* ENCR ALL case *)
        wrap_ccp_anno.
        invc H3.
        ff.
         assert (bits = encodeEv ec).
        {
          symmetry.
          invc H2.
          eapply recon_encodeEv.
          econstructor.
          eassumption.
        }
        subst.

        assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        eassumption.
      }
      congruence.

      ++ (* ENCR NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
        
      ++ (* EXTD ALL case *)
        wrap_ccp_anno.
        invc H3.
        ff.
        invc H2.
        ff.
        jkjke'.
        ff.
        assert (bits = encodeEv ec).
        {
          symmetry.
          eapply recon_encodeEv.
          econstructor.
          eassumption.
        }
        subst.
        tauto.
      ++ (* EXTD NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
      ++ (* KILL ALL case *)
        wrap_ccp_anno.
        invc H3.
        ff.
      ++ (* KILL NONE case *)
        wrap_ccp_anno.
        invc H3.
        ff.
             
      ++
        wrap_ccp_anno.
        invc H3.
        ff.
        assert (et_fun ec' = et').
        {
          symmetry.
          eapply etfun_reconstruct.
          econstructor.
          
        eassumption.
        }
        invc H2.
        unfold reconstruct_ev in *.
        congruence.
      ++
        wrap_ccp_anno.
        invc H3.
        ff.

    +
      wrap_ccp.
      dd.
      invc H3; invc H2.
      dd.
      jkjke'.
      dd.
      (* Search (encodeEv _ = _). *)
      rewrite recon_encodeEv with (bits:=bits) (et:=et).
      tauto.
      econstructor; eassumption.

    +
      wrap_ccp.
      invc H3; invc H2.
      dd.
      assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        econstructor.
        eassumption.
      }

      rewrite recon_encodeEv  with (bits:=bits) (et:=et).
      congruence.
      econstructor; eassumption.
    +
      wrap_ccp.
      invc H3; invc H2.
      dd.
      assert (et_fun ec = et).
      {
        symmetry.
        eapply etfun_reconstruct.
        econstructor.
        eassumption.
      }

      rewrite recon_encodeEv  with (bits:=bits) (et:=et).
      congruence.
      econstructor; eassumption.
      

  -
    wrap_ccp_anno.
    ff.
    wrap_ccp_anno.

    do_assert_remote (copland_compile t') (evc bits et) p (S i).

    assert (evc bits' et' = cvm_evidence_core (copland_compile t') p (evc bits et)). {

      rewrite at_evidence in *.
      unfold cvm_evidence in *.
      rewrite H5.
      tauto.
    }

    eapply IHt'.
    econstructor.
    rewrite <- H7 in H4.
    eassumption.
    econstructor; eauto.
    assert (n = (S i + event_id_span (copland_compile t'))).
    {
      wrap_ccp_anno.
      eapply anno_span_cvm.
      eassumption.
      2: { eassumption. }
      econstructor; eauto.
    }
    subst.
    eassumption.
    eassumption.
    eassumption.

  - (* lseq case *)
    wrap_ccp_anno.
    ff.
    wrap_ccp_anno.
    ff.

    assert (n = st_evid0).
    {
      eapply anno_span_cvm.
      eassumption.
      2: { eassumption. }
      econstructor; eauto.
    }
    
    dd.

    destruct st_ev0.

    assert (wf_ec (evc bits et)).
    {
      eapply wfec_recon; eauto.
    }

    do_wfec_preserved.

    do_somerecons.
    
    assert ((cvm_evidence_denote a p ec) = H8).
    {
      eapply IHt'1.
      
      eassumption.
      econstructor; eauto.
      eassumption.

      eassumption.
      eassumption.
    }
    
    subst.
    eapply IHt'2.
    apply Heqp1.
    econstructor; eauto.
    eassumption.
    eauto.
    eauto.
    
  - (* bseq case *)
    wrap_ccp_anno;
      ff;
      wrap_ccp_anno.
    
    +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid1).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp2. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a st_pl1 ec = e1).
    {
      eapply IHt'1.
      apply Heqp2.
      econstructor; eauto.
      

      eassumption.
      eassumption.
      eassumption.
    }

     assert (cvm_evidence_denote a0 st_pl1 ec = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      eassumption.
      eassumption.
    }
    
      
    dd.
    congruence.
    +
            do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid1).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp2. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a st_pl1 ec = e1).
    {
      eapply IHt'1.
      apply Heqp2.
      econstructor; eauto.
      

      eassumption.
      eassumption.
      eassumption.
    }

     assert (cvm_evidence_denote a0 st_pl1 mtc = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      econstructor. ff.
      eassumption.
    }
    
      
    dd.
    congruence.


    +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec mt_evc).
      {
        econstructor.
        ff.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid1).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp8. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a st_pl1 mtc = e1).
    {
      eapply IHt'1.
      apply Heqp8.
      econstructor; eauto.
      

      eassumption.
      econstructor; eauto.
      eassumption.
    }

     assert (cvm_evidence_denote a0 st_pl1 ec = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      econstructor. ff.
      eassumption.
    }
    
      
    dd.
    congruence.
    


        +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec mt_evc).
      {
        econstructor.
        ff.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid1).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp9. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a st_pl1 mtc = e1).
    {
      eapply IHt'1.
      apply Heqp9.
      econstructor; eauto.
      

      eassumption.
      econstructor; eauto.
      eassumption.
    }

     assert (cvm_evidence_denote a0 st_pl1 mtc = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      econstructor. ff.
      eassumption.
    }
    
      
    dd.
    congruence.



  - (* bpar case *)
    wrap_ccp_anno;
      ff;
      wrap_ccp_anno.
    
    +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp2. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a p ec = e1).
    {
      eapply IHt'1.
      apply Heqp2.
      econstructor; eauto.
      

      eassumption.
      eassumption.
      eassumption.
    }

    do_assert_remote (copland_compile t'2) (evc bits et) p (st_evid).

    wrap_ccp_anno.

    rewrite par_evidence in *.

    unfold cvm_evidence in *.
    rewrite Heqe0 in *.

    assert (cvm_evidence_denote a0 p ec = e2).
    {
      eapply IHt'2.
      apply H9.
      econstructor; eauto.
      assert (n0 = st_evid + event_id_span (copland_compile t'2)).
      {
        eapply anno_span_cvm.
        apply Heqp1.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      eassumption.
      eassumption.
    }
    
      
    dd.
    congruence.


    +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid).
      {
        eapply anno_span_cvm.
        eassumption.
        2: { 
             apply Heqp2. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a p ec = e1).
    {
      eapply IHt'1.
      apply Heqp2.
      econstructor; eauto.
      

      eassumption.
      eassumption.
      eassumption.
    }

     do_assert_remote (copland_compile t'2) mt_evc p (st_evid).

    wrap_ccp_anno.

    rewrite <- ev_cvm_mtc in *.

    rewrite par_evidence in *.

    unfold cvm_evidence in *.
    rewrite Heqe0 in *.


     assert (cvm_evidence_denote a0 p mtc = e2).
    {
      eapply IHt'2.
      apply H9.
      econstructor; eauto.
      assert (n0 = st_evid + event_id_span (copland_compile t'2)).
      {
        eapply anno_span_cvm.
        apply Heqp1.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      econstructor; eauto.
      eassumption.
    }
    
      
    dd.
    congruence.


    +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec mt_evc).
      {
        econstructor.
        ff.
      }

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid).
      {
        eapply anno_span_cvm.
        apply Heqp0.
        2: { 
             apply Heqp3. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a p mtc = e1).
    {
      eapply IHt'1.
      apply Heqp3.
      econstructor; eauto.
      

      eassumption.
      econstructor; eauto.
      eassumption.
    }

     do_assert_remote (copland_compile t'2) (evc bits et) p (st_evid).

    wrap_ccp_anno.

    rewrite par_evidence in *.

    unfold cvm_evidence in *.
    rewrite Heqe0 in *.


     assert (cvm_evidence_denote a0 p ec = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid + event_id_span (copland_compile t'2)).
      {
        eapply anno_span_cvm.
        apply Heqp1.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      eassumption.
      eassumption.
    }
    
      
    dd.
    congruence.



        +
      do_rewrap_reconP.
      ff.
      unfold OptMonad_Coq.bind in *.
      ff.

      assert (wf_ec mt_evc).
      {
        econstructor.
        ff.
      }

      assert (wf_ec (evc bits et)).
      {
        eapply wfec_recon; eauto.
      }

      do_wfec_preserved.

      do_wfec_firstn.
      do_wfec_skipn.

      clear_skipn_firstn.
      

      assert (reconstruct_evP (evc r e) e1).
      {
        econstructor.
        ff.
      }

    assert (reconstruct_evP (evc r0 e0) e2).
    {
      econstructor.
      ff.
    }

    assert (i + 1 = S i) as H9 by lia.
    rewrite H9 in *; clear H9.

    assert (n = st_evid).
      {
        eapply anno_span_cvm.
        apply Heqp0.
        2: { 
             apply Heqp3. }
   
        econstructor; eauto.
      }
      dd.

    assert (cvm_evidence_denote a p mtc = e1).
    {
      eapply IHt'1.
      apply Heqp3.
      econstructor; eauto.
      

      eassumption.
      econstructor; eauto.
      eassumption.
    }

     do_assert_remote (copland_compile t'2) mt_evc p (st_evid).

    wrap_ccp_anno.

    rewrite <- ev_cvm_mtc in *.

    rewrite par_evidence in *.

    unfold cvm_evidence in *.
    rewrite Heqe0 in *.


     assert (cvm_evidence_denote a0 p mtc = e2).
    {
      eapply IHt'2.
      eassumption.
      econstructor; eauto.
      assert (n0 = st_evid + event_id_span (copland_compile t'2)).
      {
        eapply anno_span_cvm.
        apply Heqp1.
        2: { eassumption. }
   
        econstructor; eauto.
      }
      dd.

      eassumption.
      econstructor; eauto.
      eassumption.
    }
    
      
    dd.
    congruence.",0,Proof
reconstruct_ev,"(e:EvC) : Opt EvidenceC :=
  match e with
  | evc ls et => reconstruct_ev' ls et
  end",2,Definition
reconstruct_ev_proof,"intros.
  assert (et' = eval t' p et).
  {
    eapply cvm_refines_lts_evidence.
    eassumption.
    eassumption.
  }
  eapply cvm_raw_evidence_denote_fact; eauto.
  congruence.",0,Proof
spc_ev,"(sp:SP) (e:EvidenceC) : EvidenceC :=
  match sp with
  | ALL => e
  | NONE => mtc
  end",2,Definition
spc_ev_proof,"intros.
  econstructor.
  eexists.
  jkjke.",0,Proof
cvm_evidence_denote_asp,"(a:ASP) (p:Plc) (e:EvidenceC) (x:Event_ID): EvidenceC :=
  match a with
  | NULL => mtc
  | CPY => e
  | ASPC sp fwd params =>
    match fwd with
    | COMP => hhc p params
                 (do_asp params (encodeEv (spc_ev sp e)) p x)
                 (sp_ev sp (et_fun e))
    | EXTD => ggc p params
                 (do_asp params (encodeEv (spc_ev sp e)) p x)
                 (spc_ev sp e)
    | ENCR => eec p params
                 (do_asp params (encodeEv (spc_ev sp e)) p x)
                 (sp_ev sp (et_fun e))
    | KEEP => (spc_ev sp e)
    | KILL => mtc (* kkc p params (sp_ev sp (et_fun e)) *)
    end
  | SIG => ggc p sig_params
              (do_asp sig_params (encodeEv e) p x)
              e
  | HSH => hhc p hsh_params
              (do_asp hsh_params (encodeEv e) p x)
              (et_fun e)
  | ENC q => eec p (enc_params q)
                (do_asp (enc_params q) (encodeEv e) p x)
                (et_fun e)
  end",2,Definition
cvm_evidence_denote_asp_proof,"intros.
  econstructor.
  jkjke.",0,Proof
checkASP,' (params:ASP_PARAMS) (bs:BS) : BS,2,Definition
checkHH,' (params:ASP_PARAMS) (bs:BS) (e:Evidence) : BS,2,Definition
checkEE,' (params:ASP_PARAMS) (bs:BS) : BS,2,Definition
gen_nonce_bits,: BS,2,Definition
decrypt_bs_to_rawev,(bs:BS) (params:ASP_PARAMS) : RawEv,2,Definition
check_asp_EXTD,(params:ASP_PARAMS) (p:Plc) (sig:BS) (ls:RawEv) : BS,2,Definition
checkNonce,(nonceGolden:BS) (nonceCandidate:BS) : BS,2,Definition
always_some,"forall t vm_st vm_st' op,
    build_cvm t vm_st = (op, vm_st') ->
    op = Some tt",1,Lemma
always_some_proof,"induction t; intros.
  -
    destruct a; (* asp *)
      try destruct a; (* asp params *)
      try (df; tauto).
  -
    repeat (df; try dohtac; df).
    tauto.
  -
    df.
    
    destruct o eqn:hhh;
      try (df; eauto).
  -
    df.

    repeat break_match;
      try (
          df; eauto).
  -
    df.
    dohtac.
    df.
    simpl.

    assert (o = Some tt) by eauto.
    subst.
    vmsts.
    df.
    tauto.",0,Proof
doRemote_session,(t:Term) (pTo:Plc) (e:EvC) : EvC,2,Definition
parallel_vm_thread,(l:Loc) (t:Term) (p:Plc) (e:EvC) : EvC,2,Definition
shuffled_events,(el1:list Ev) (el2:list Ev) : list Ev,2,Definition
cvm_events_core,(t:Core_Term) (p:Plc) (e:Evidence) : list Ev,2,Definition
cvm_evidence_core,(t:Core_Term) (p:Plc) (e:EvC) : EvC,2,Definition
cvm_events,"(t:Term) (p:Plc) (e:Evidence) : list Ev :=
  cvm_events_core (copland_compile t) p e",2,Definition
cvm_evidence,"(t:Term) (p:Plc) (e:EvC) : EvC :=
  cvm_evidence_core (copland_compile t) p e",2,Definition
BS,: Set,2,Definition
default_bs,: BS,2,Definition
passed_bs,: BS,2,Definition
failed_bs,: BS,2,Definition
evsubT_transitive,"forall e e' e'',
    EvSubT e e' ->
    EvSubT e' e'' ->
    EvSubT e e''",1,Lemma
evsubT_transitive_proof,"intros.
  generalizeEverythingElse e''.
  induction e''; intros;
    try evSubTFacts;
       eauto.",0,Proof
evsub_etfun,"forall e e',
    EvSub e e' ->
    EvSubT (et_fun e) (et_fun e')",1,Lemma
evsub_etfun_proof,"intros.
  induction H; intros;
    cbn in *; eauto.",0,Proof
evsub_hh,"forall e e' e0,
    EvSub e0 e' ->
    EvSubT (et_fun e') e ->
    EvSubT (et_fun e0) e",1,Lemma
evsub_hh_proof,"intros.
  generalizeEverythingElse e.
  induction e; intros; ff.
  -
    invc H0.
    jkjke.
    assert (e' = mtc).
    {
      destruct e'; try solve_by_inversion.
    }
    (*
    assert (e' = mtc \/ (exists p ps et', e' = kkc p ps et')).
    {
      destruct e'; try solve_by_inversion.
      eauto.
    }
    door.
    +
    subst.
    ff.
    +
      subst.
      ff.
     *)
    subst.
    ff.
      
  -
    invc H0.
    jkjke.
    destruct e'; try solve_by_inversion.
    ff.
  -
    invc H0.
    +
      destruct f.
      ++
        destruct e'; ff.
          
      ++
        destruct e'; ff.
          
      ++
        destruct e'; ff.
        invc H; ff; eauto.

      ++
        destruct e'; ff.
        
      ++
        destruct e'; ff.
          
    +
      eauto.
  -
    invc H0.
    +
      destruct e'; ff.
      invc H; ff; eauto.
    +
      eauto.
    +
      eauto.",0,Proof
evsub_transitive,"forall e e' e'',
    EvSub e e' ->
    EvSub e' e'' ->
    EvSub e e''",1,Lemma
evsub_transitive_proof,"intros e e' e'' H H0.
  generalizeEverythingElse e''.
  induction e''; intros; ff; invc H0; eauto.",0,Proof
splitEv_l,"(sp:Split) (e:EvC): EvC :=
  match sp with
  | (ALL, _) => e
  | _ => mt_evc
  end",2,Definition
splitEv_r,"(sp:Split) (e:EvC): EvC :=
  match sp with
  | (_,ALL) => e
  | _ => mt_evc
  end",2,Definition
splitEvl,"(sp:Split) (e:EvidenceC) : EvidenceC :=
  match sp with
  | (ALL,_) => e
  | _ => mtc
  end",2,Definition
splitEvr,"(sp:Split) (e:EvidenceC) : EvidenceC :=
  match sp with
  | (_,ALL) => e
  | _ => mtc
  end",2,Definition
list_of_string_app,"forall str1 str2,
  list_of_string (str1 ++ str2) = list_of_string str1 ++ list_of_string str2",1,Lemma
list_of_string_app_proof,"intros.
  induction str1.
  - simpl. reflexivity.
  - simpl. rewrite IHstr1. reflexivity.",0,Proof
list_of_string_cons,"forall a str1 a0 astr,
  list_of_string (String a str1) = a0 :: astr 
  <-> a = a0 /\ list_of_string str1 = astr",1,Lemma
list_of_string_cons_proof,"split; intros.
  - inversion H. auto.
  - destruct H. auto. simpl. rewrite H0.  rewrite H. reflexivity.",0,Proof
list_of_string_space,"list_of_string "" "" = ["" ""%char]",1,Lemma
list_of_string_space_proof,auto.,0,Proof
tokenize_helper_space_after,"forall c st (t1 : string),
  tokenize_helper c st (list_of_string t1) 
  = tokenize_helper c st (list_of_string (t1 ++ "" ""))",1,Lemma
tokenize_helper_space_after_proof,"intros.
  generalize dependent c.
  generalize dependent st.
  induction t1.
  - simpl. destruct st eqn:E.
    * reflexivity.
    * rewrite app_nil_r. reflexivity.
  - destruct (list_of_string (String a t1)) eqn:AT.
    * inversion AT.
    * intros.
      rewrite list_of_string_app. rewrite AT.
      inversion AT.
      subst.
      destruct a0; destruct b,b0,b1,b2,b3,b4,b5,b6;
      simpl; intros; rewrite list_of_string_app in IHt1;
      rewrite <- list_of_string_space; 
      try (apply IHt1);
      try (rewrite IHt1; reflexivity).",0,Proof
isCopySound,"parserSoundASP parseCopy ""_"" CPY",1,Lemma
isCopySound_proof,apply String.eqb_eq.,0,Proof
isSignSound,"parserSoundASP parseSign ""!"" SIG",1,Lemma
isSignSound_proof,soundParse.,0,Proof
isHashSound,"parserSoundASP parseHash ""#"" HSH",1,Lemma
isHashSound_proof,soundParse.,0,Proof
isNullSound,"parserSoundASP parseNull ""{}"" NULL",1,Lemma
isNullSound_proof,soundParse.,0,Proof
isLowerAlpha,"(c : ascii) : bool :=
  let n := nat_of_ascii c in
    andb (97 <=? n) (n <=? 122)",2,Definition
isLowerAlpha_proof,soundParse.,0,Proof
isAlpha,"(c : ascii) : bool :=
  let n := nat_of_ascii c in
    orb (andb (65 <=? n) (n <=? 90))
        (andb (97 <=? n) (n <=? 122))",2,Definition
isAlpha_proof,"intros t.
  induction t; intros.
  - destruct a.
    * exists 2. simpl. intros. qinv H. reflexivity.
    * exists 2. simpl. intros H. qinv H. reflexivity.
    * destruct a. destruct p.
      ** simpl.
      ** exists 2. destruct p. 
        *** destruct a.
          **** simpl. intros. discriminate.
          **** simpl. intros. 
  induction t.
  - simpl. destruct a. 
    * simpl. unfold tokenize. simpl. exists 10. simpl. reflexivity.
    * simpl. unfold tokenize. simpl. exists 10. reflexivity.
    * destruct a. admit. (* dies on computation? *)
    * simpl. unfold tokenize. simpl. exists 10. reflexivity.
    * simpl. unfold tokenize. simpl. exists 10. reflexivity.
  - induction p.
    * simpl. unfold tokenize. simpl. destruct IHt.
      exists (x + 2). simpl. admit.
    * admit.
  - simpl. unfold tokenize. simpl. destruct IHt1.
    destruct IHt2. exists (x + x0 + 2).
    simpl. admit.
  - simpl. destruct s.",0,Proof
isDigit,"(c : ascii) : bool :=
  let n := nat_of_ascii c in
     andb (48 <=? n) (n <=? 57)",2,Definition
isAlphaNum,"(c : ascii) : bool :=
    orb (orb (isAlpha c) (isLowerAlpha c)) (isDigit c)",2,Definition
isUnderscore,"(c : ascii) : bool :=
    (nat_of_ascii c) =? 95",2,Definition
classifyChar,"(c : ascii) : chartype :=
  if isWhite c then
    white
  else if isAlpha c then
    alpha
  else if isDigit c then
    digit
  else if isUnderscore c then
    underscore
  else
    other",2,Definition
string_of_list,"(xs : list ascii) : string :=
  fold_right String EmptyString xs",2,Definition
token,:= string,2,Definition
tokenize,"(s : string) : list string :=
  map string_of_list (tokenize_helper white [] (list_of_string s))",2,Definition
parser,"(T : Type) :=
    list token -> optionE (T * list token)",2,Definition
many,"{T} (p : parser T) (steps : nat) : parser (list T) :=
  many_helper p [] steps",2,Definition
expect,"(t : token) : parser unit :=
  firstExpect t (fun xs => SomeE (tt, xs))",2,Definition
isIdTail,:= fun x => orb (isAlphaNum x) (isUnderscore x),2,Definition
symbol_map,:= MapD string nat,2,Definition
parseSymbol,"(xs : list token) (sm : symbol_map) 
                         : optionE (symbol_map * string * list token) :=
    match xs with
    | [] => NoneE ""Expected identifier""
    | x::xs' => match (list_of_string x) with
                | nil => NoneE (""Illegal identifier: nil - is this possible?"")
                | xh :: xt => if andb (isLowerAlpha xh) (forallb isIdTail xt) then
                                SomeE (sm, x, xs')
                              else 
                                NoneE (""Illegal Identifier: '"" ++ x ++ ""'"")
                end
    end",2,Definition
str_to_nat,"(x : list ascii) : nat :=
  (fold_left 
    (fun n d => 10 * n + (nat_of_ascii d - nat_of_ascii ""0""%char))
    x
    0
  )",2,Definition
parseDigits,"(xs : list token) (sm : symbol_map)
      : optionE (symbol_map * string * list token) :=
  match xs with
  | nil     => NoneE ""Expected digits""
  | x::xs'  => if (forallb isDigit (list_of_string x))
                then 
                  let dig := str_to_nat (list_of_string x) in
                  SomeE ((map x to dig in sm), x, xs')
                else NoneE ""Invalid digit sequence""
  end",2,Definition
parsePlace,"(xs : list token) (sm : symbol_map)
                      : optionE (symbol_map * string * list token) :=
  match xs with
  | nil => NoneE ""Expected Place""
  | x::xs' => (* we need places to be either DIGITS or p + DIGITS *)
              match (list_of_string x) with
                | nil => NoneE (""Illegal place: nil - is this possible?"")
                | xh :: xt => if andb (isLowerAlpha xh) (forallb isDigit xt) then
                              (* we are a p + DIGITS *)
                                let dig := str_to_nat xt in
                                SomeE ((map x to dig in sm), x, xs')
                              else if (forallb isDigit (xh :: xt)) then
                                (* we are completely a digit *)
                                let dig := str_to_nat (list_of_string x) in
                                SomeE ((map x to dig in sm), x, xs')
                              else 
                                NoneE (""Illegal Identifier: '"" ++ x ++ ""'"")
                end
    end",2,Definition
spToStr,"(s : SP) :=
  match s with
  | ALL => ""+""
  | NONE => ""-""
  end",2,Definition
parserSoundASP,"(p :  list token -> symbol_map
        -> (optionE (symbol_map * Term * list token))) 
  (val : string) 
  (a : ASP) : Prop :=
    forall s t (sm : symbol_map), 
    (s = val <-> p (s :: t) sm = SomeE (sm, (asp a), t))
    /\
    (s <> val <-> exists m, p (s :: t) sm = NoneE m)",2,Definition
parseCopy,"(xs : list token) (sm : symbol_map)
                      : optionE (symbol_map * Term * list token) := 
  match xs with
  | nil => NoneE ""Expected a copy""
  | h :: t => if (h =? ""_"") 
                then SomeE (sm, (asp CPY), t) 
                else NoneE ""Invalid CPY""
  end",2,Definition
parseASPC,"(xs : list token) (sm : symbol_map)
                      : optionE (symbol_map * Term * list token) := 
    let sym1 := parseSymbol xs sm in
    match sym1 with
    | OutOfFuel => OutOfFuel
    | NoneE m => NoneE m
    | SomeE (sm', x',xs') => 
        let place := parsePlace xs' sm' in
        match place with
        | OutOfFuel => OutOfFuel
        | NoneE m => NoneE m
        | SomeE (sm'', x'',xs'') =>   
                  let sym2 := parseSymbol xs'' sm'' in
                  match sym2 with
                  | OutOfFuel => OutOfFuel
                  | NoneE m => NoneE m
                  | SomeE (sm''', x''',xs''') => 
                      match (mapD_get_value sm''' x'') with
                      (* TODO: Right now we FORCE the place to be digits because
                        the place is digits in Coq, we should find a way around this
                        though *)
                      | None => NoneE ""Failed to find relevant symbol for ASPC""
                      | Some pNat =>
                          SomeE (sm''',
                            (asp (ASPC ALL EXTD (asp_paramsC x' nil pNat x'''))),
                            xs''')
                      end
                  end
        end
    end",2,Definition
parseSign,"(xs : list token) sm : optionE (symbol_map * Term * list token) := 
  match xs with
  | nil => NoneE ""Expected a sign""
  | h :: t => if (h =? ""!"") 
                then SomeE (sm, (asp SIG), t) 
                else NoneE ""Invalid SIGN""
  end",2,Definition
parseHash,"(xs : list token) sm : optionE (symbol_map * Term * list token) := 
  match xs with
  | nil => NoneE ""Expected a hash""
  | h :: t => if (h =? ""#"") 
                then SomeE (sm, (asp HSH), t) 
                else NoneE ""Invalid HASH""
  end",2,Definition
parseNull,"(xs : list token) sm : optionE (symbol_map * Term * list token) :=
  match xs with
  | nil => NoneE ""Expected NULL""
  | h :: t => if (h =? ""{}"")
                then SomeE (sm, (asp NULL), t)
                else NoneE ""Invalid Null""
  end",2,Definition
parseASP,"(xs : list token) (sm : symbol_map)
                    : optionE (symbol_map * Term * list token) :=
    match xs with
    | nil   => NoneE ""Expected ASP""
    | x::t  =>  
        match (parseNull xs sm) with
        | OutOfFuel => OutOfFuel
        | SomeE x' => SomeE x'
        | NoneE _ =>
            match (parseCopy xs sm) with
            | OutOfFuel => OutOfFuel
            | SomeE x'' => SomeE x''
            | NoneE _ =>
                match (parseASPC xs sm) with
                | OutOfFuel => OutOfFuel
                | SomeE x''' => SomeE x'''
                | NoneE _ =>
                    match (parseSign xs sm) with
                    | OutOfFuel => OutOfFuel
                    | SomeE x'''' => SomeE x''''
                    | NoneE _ =>
                        match (parseHash xs sm) with
                        | OutOfFuel => OutOfFuel
                        | SomeE x''''' => SomeE x'''''
                        | NoneE _ => NoneE ""Expected an ASP""
                        end
                    end
                end
            end
        end
    end",2,Definition
parseBranch,"(xs : list token) (prevT : Term) (sm : symbol_map)
                : optionE (symbol_map * (Term -> Term) * list token) :=
    match xs with
    | nil   => NoneE ""Expected branch""
    | h::t  => (* we only check head, as this should be one contiguous token *)
                if (string_dec h ""-<-"")
                then SomeE (sm, fun t' => (bseq (NONE, NONE) prevT t'), t)
                else if (string_dec h ""-<+"")
                then SomeE (sm, fun t' => (bseq (NONE, ALL) prevT t'), t)
                else if (string_dec h ""+<-"")
                then SomeE (sm, fun t' => (bseq (ALL, NONE) prevT t'), t)
                else if (string_dec h ""+<+"")
                then SomeE (sm, fun t' => (bseq (ALL, ALL) prevT t'), t)
                else if (string_dec h ""-~-"")
                then SomeE (sm, fun t' => (bpar (NONE, NONE) prevT t'), t)
                else if (string_dec h ""-~+"")
                then SomeE (sm, fun t' => (bpar (NONE, ALL) prevT t'), t)
                else if (string_dec h ""+~-"")
                then SomeE (sm, fun t' => (bpar (ALL, NONE) prevT t'), t)
                else if (string_dec h ""+~+"")
                then SomeE (sm, fun t' => (bpar (ALL, ALL) prevT t'), t)
                else NoneE ""Invalid branch""
    end",2,Definition
testPhr,":= ""@1 kim 2 ker -> ! -<- @2 (vc 2 sys) -> !""",2,Definition
testPhr2,":= ""@p1 kim p2 ker -> ! -<- @p2 [(vc p2 sys) -> !]""",2,Definition
transTestPhr,":= <{ @ 1 [<< ""kim"" 2 ""ker"" >> -> (!) -<- @ 2 [<< ""vc"" 2 ""sys"">> -> !]]}>",2,Definition
ascii_from_range,"(min max : nat) : G ascii := 
  bind (choose (min,max)) (fun val =>
    ret (ascii_of_nat val))",2,Definition
genLower,: G ascii := ascii_from_range 97 122,2,Definition
isLowerCorrect,: ascii -> bool := correct_ascii_from_range 97 122,2,Definition
genDigits,: G ascii := ascii_from_range 48 57,2,Definition
isDigitsCorrect,: ascii -> bool := correct_ascii_from_range 48 57,2,Definition
genUnderScore,: G ascii := ascii_from_range 95 95,2,Definition
isUnderScoreCorrect,: ascii -> bool := correct_ascii_from_range 95 95,2,Definition
genUpper,: G ascii := ascii_from_range 65 90,2,Definition
isUpperCorrect,: ascii -> bool := correct_ascii_from_range 65 90,2,Definition
genIdChar,": G ascii := 
  oneOf [genLower; genUpper; genDigits; genUnderScore]",2,Definition
genIdCharCorrect,"(x : ascii) : bool :=
  orb ((correct_ascii_from_range 97 122) x)
    (orb ((correct_ascii_from_range 48 57) x) 
      (orb ((correct_ascii_from_range 95 95) x) ((correct_ascii_from_range 65 90) x)
      )
    )",2,Definition
genSymbol,": G string :=
  h <- genLower ;;
  tailSize <- choose (0,20) ;; 
  (* NOTE: We enforce a size limit here, it is questionable
           if we can really justify this as arbitrary then",2,Definition
shrinkSymbol,"(s : string) : list (string) :=
  match s with
  | EmptyString => []
  | String h t => (map (fun t' => (String h t')) (shrinkSymbolTail t))
  end",2,Definition
gListArg,: G (list Arg) := ret nil,2,Definition
gSplit,": G Split :=
  s1 <- (@arbitrary SP _) ;;
  s2 <- (@arbitrary SP _) ;;
  ret (s1, s2)",2,Definition
shrinkSplit_Aux,"(s : Split) : list (Split) :=
  match s with
  | (NONE, NONE) => []
  | (NONE, ALL) => [(NONE, NONE)]
  | (ALL, NONE) => [(NONE, NONE); (NONE, ALL)]
  | (ALL, ALL) => [(NONE, NONE); (NONE, ALL); (ALL, NONE)]
  end",2,Definition
gFWD,: G (FWD) := ret EXTD,2,Definition
shrinkFWD_Aux,"(f : FWD) : list (FWD) :=
  match f with
  | EXTD => []
  | COMP => [EXTD]
  | ENCR => [COMP]
  | KILL => [ENCR]
  | KEEP => [KILL]
  end",2,Definition
showASP_PARAMS_Aux,"(aspp : ASP_PARAMS) `{_ : Show ASP_ID} `{_ : Show TARG_ID} `{Show Plc} : string :=
    match aspp with
    | (asp_paramsC a arg p t) =>
        show a ++ "" "" ++ show p ++ "" "" ++ show t
    end",2,Definition
showASP_Aux,"(a : ASP) : string :=
    match a with
    | NULL => ""{}""
    | CPY => ""_""
    | ASPC sp fwd params => show params
    | SIG => ""!""
    | HSH => ""#""
    | ENC v => ""ENC""
    end",2,Definition
gASP,": G ASP :=
  oneOf [
    (ret NULL) ; (ret CPY) ; (ret SIG) ; (ret HSH) ;
    (par <- arbitrary ;; ret (ASPC ALL EXTD par))
  ]",2,Definition
shrinkASP_Aux,"(a : ASP) : list (ASP) :=
  match a with
  | (ASPC sp fwd par) => map (fun p' => (ASPC sp fwd p')) (shrink par)
  | _ => [] (* If its just a basic ASP we cant shrink *)
  end",2,Definition
shrinkTerm_Aux,"(t : Term) : list (Term) :=
  match t with
  | asp a => (map (fun a' => asp a') (shrink a))
  (* | _ => []  *)
  (* Testing to see how detrimental the shrink is*)
  | att p t' => 
    (* vary p or vary t *)
    [t'] 
    (* ++ 
    (map (fun p' => att p' t) (shrink p)) ++ 
    (map (fun t'' => att p t'') (shrinkTerm_Aux t')) *)
  | lseq t1 t2 =>
    [t1 ; t2] 
    (* ++ 
    (map (fun t1' => lseq t1' t2) (shrinkTerm_Aux t1)) ++
    (map (fun t2' => lseq t1 t2') (shrinkTerm_Aux t2)) *)
  | bseq sp t1 t2 =>
    [t1 ; t2] ++ (* Vary sp, t1 or t2*)
    (map (fun sp' => bseq sp' t1 t2) (shrink sp)) 
    (* ++
    (map (fun t1' => bseq sp t1' t2) (shrinkTerm_Aux t1)) ++
    (map (fun t2' => bseq sp t1 t2') (shrinkTerm_Aux t2)) *)
  | bpar sp t1 t2 =>
    [t1 ; t2] ++ (* Vary sp, t1 or t2*)
    (map (fun sp' => bpar sp' t1 t2) (shrink sp)) 
    (* ++
    (map (fun t1' => bpar sp t1' t2) (shrinkTerm_Aux t1)) ++
    (map (fun t2' => bpar sp t1 t2') (shrinkTerm_Aux t2)) *)
  end",2,Definition
stat_collect_prop,"(t : Term) :=
  (fun t => collect (term_seq_size t) (genTerm_Correct t))",2,Definition
AC_Policy,: Permission -> Object -> Prop,2,Definition
splitEv_T_l_LEFT,"forall e bits bits' es e0 sp,
    et_size e = es ->
    splitEv_l (ALL,sp) (evc bits e) = (evc bits' e0) ->
    et_size e0 = es",1,Lemma
splitEv_T_l_LEFT_proof,"about the Copland Virtual Machine implementation, linking it to the Copland reference semantics.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import More_lists Defs Term_Defs Anno_Term_Defs ConcreteEvidence LTS Event_system Term_system Main Appraisal_Evidence AutoApp.
Require Import Cvm_Monad StructTactics Auto.
Require Import Axioms_Io Cvm_Impl Cvm_Run External_Facts Helpers_CvmSemantics Evidence_Bundlers.

Require Import List.
Import ListNotations.
Require Import Coq.Program.Tactics Coq.Program.Equality.
Require Import Coq.Arith.Peano_dec Lia.


(*
Set Nested Proofs Allowed.
 *)

Lemma splitEv_T_l_LEFT: forall e bits bits' es e0 sp,
    et_size e = es ->
    splitEv_l (ALL,sp) (evc bits e) = (evc bits' e0) ->
    et_size e0 = es. (* (splitEv_T_l LEFT es). *)
Proof.
  intros.
  ff.",0,Proof
aeval_anno,"forall a i n e0,
    (aeval (snd (anno (unanno a) i)) n e0 = aeval a n e0)",1,Lemma
aeval_anno_proof,"intros.
  generalizeEverythingElse a.
  induction a; intros; ff;
    repeat jkjke';
    repeat jkjke.",0,Proof
evc_inv,"forall e,
    e = evc (get_bits e) (get_et e)",1,Lemma
evc_inv_proof,destruct e; eauto.,0,Proof
wfec_firstn,"forall e0 e1 e2,
    wf_ec (evc e0 e1) ->
    firstn (et_size e1) (e0 ++ e2) = e0",1,Lemma
wfec_firstn_proof,tauto.,0,Proof
wfec_skipn,"forall e0 e1 e2,
    wf_ec (evc e0 e1) ->
    skipn (et_size e1) (e0 ++ e2) = e2",1,Lemma
wfec_skipn_proof,tauto.,0,Proof
wfec_encodeEv_etfun,"forall e,
    wf_ec (evc (encodeEv e) (et_fun e))",1,Lemma
wfec_encodeEv_etfun_proof,"intros.
  inv_wfec.
  jkjke'.
  eapply More_lists.firstn_append.",0,Proof
recon_same,"forall e,
    Some e = reconstruct_ev (evc (encodeEv e) (et_fun e))",1,Lemma
recon_same_proof,"intros.
  inv_wfec.
  jkjke'.
  eapply More_lists.skipn_append.",0,Proof
wf_ec_preserved_by_cvm,"forall e e' t1 tr tr' p p' i i',
    wf_ec e ->
        build_cvmP t1
                    {| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |}
                    (Some tt)
                    {| st_ev := e'; st_trace := tr'; st_pl := p'; st_evid := i' |} ->
    wf_ec (e')",1,Lemma
wf_ec_preserved_by_cvm_proof,"intros.

  (*
  induction e; intros.
  -
    ff.
    econstructor; eauto.
  -
    ff.
    econstructor; eauto.
  -
    ff.
    econstructor.
    ff.
    invc IHe.
    eauto.
  -
    destruct f.
    +
      ff.
      econstructor. ff.
    +
      ff.
      econstructor. ff.
    +
      ff.
      econstructor.
      ff.
      
      
    ff.
    
    *)
    
    
    
  
  induction e; intros;
    dd;
    try (econstructor; tauto);
    try (repeat inv_wfec;
         econstructor;
         dd;
         try (erewrite app_length);
         jkjke).",0,Proof
event_id_spans_same,"forall t,
    event_id_span' t = event_id_span (copland_compile t)",1,Lemma
event_id_spans_same_proof,"intros.
  induction e; intros;
    dd;
    try (try jkjke'; tauto);
    try ( (* ss and pp cases *)
        assert (wf_ec (evc (encodeEv e1) (et_fun e1))) by
          (eapply wfec_encodeEv_etfun);
        ff;
        try (unfold OptMonad_Coq.bind);
        ff;
      try do_wfec_firstn;
      try do_wfec_skipn;
      repeat find_rewrite;
      try solve_by_inversion;
      try (repeat find_inversion; tauto)).
  Locate encodeEv.
  Locate reconstruct_ev.",0,Proof
cvm_spans,"forall t pt e tr p i e' tr' p' i',
    term_to_coreP t pt ->
    build_cvmP
      pt
      {| st_ev := e;
         st_trace := tr;
         st_pl := p;
         st_evid := i |}
      (Some tt)
      {|
        st_ev := e';
        st_trace := tr';
        st_pl := p';
        st_evid := i'
      |} ->
    i' = i + event_id_span' t",1,Lemma
cvm_spans_proof,"intros.
  generalizeEverythingElse t1.
  induction t1; intros.
  -
    rewrite <- ccp_iff_cc in *.
    destruct a; (* asp *)
      try destruct a; (* asp params *)
      ff;
      inv_wfec;
      try (
          econstructor;
          ff;
          try tauto;
          try congruence).
    +
      destruct f.
      ++
        ff.
        econstructor.
        ff.
      ++
        ff.
        econstructor.
        ff.
      ++
        ff.
        econstructor.
        ff.        
        congruence.
      ++
        ff.
        econstructor.
        ff.
      ++
        ff.
        econstructor.
        ff.
        
        
  -
    wrap_ccp.

    eapply wf_ec_preserved_remote; eauto.

  -
    wrap_ccp.
    eauto.
  -
    wrap_ccp.

    (*

    do_wfec_split. *)

    find_apply_hyp_hyp.
    find_apply_hyp_hyp.
    econstructor.
    dd.
    inv_wfec.
    repeat jkjke'.
    eapply app_length.

  -
    wrap_ccp.

    (*
    
    do_wfec_split. *)

    find_apply_hyp_hyp.

      inv_wfec;
      ff;
      econstructor;
      dd;
      repeat jkjke'.

    erewrite app_length.

    assert (wf_ec (evc r0 e1)).
    {
      rewrite <- Heqe1.
      eapply wf_ec_preserved_par.
      econstructor; eassumption.
    }

    solve_by_inversion.",0,Proof
span_cvm,"forall atp t annt i j e e' tr tr' p p' i',
    build_cvmP
      atp
      {| st_ev := e;
         st_trace := tr;
         st_pl := p;
         st_evid := i |} 
      (Some tt)
      {| st_ev := e';
         st_trace := tr';
         st_pl := p';
         st_evid := i' |} ->
    
    term_to_coreP t atp -> 
    anno t i = (j, annt) ->
    j = i'",1,Lemma
span_cvm_proof,"intros.
  destruct e;
    ff; eauto.",0,Proof
anno_span_cvm,"forall t pt annt i i' e e' p p' tr tr' st_evid1,
    annoP_indexed annt t i i' ->
    term_to_coreP t pt ->
    build_cvmP pt
                     {|
                       st_ev := e ;
                       st_trace := tr ;
                       st_pl := p;
                       st_evid := i
                     |} (Some tt)
                     {|
                       st_ev := e';
                       st_trace := tr';
                       st_pl := p';
                       st_evid := st_evid1
                     |} ->
    i' = st_evid1",1,Lemma
anno_span_cvm_proof,"intros.
  induction t; ff.
  -
    destruct a; ff; try tauto.
    +
      destruct s; ff.
  -
    jkjke'.
  -
    destruct s0; ff; lia.
  -
    destruct s0; ff; lia.",0,Proof
of,the CVM Monad + monadic helper functions,2,Definition
put_ev,"(e:EvC) : CVM unit :=
  st <- get ;;
     let tr' := st_trace st in
     let p' := st_pl st in
     let i := st_evid st in
     put (mk_st e tr' p' i)",2,Definition
put_pl,"(p:Plc) : CVM unit :=
  st <- get ;;
     let tr' := st_trace st in
     let e' := st_ev st in
     let i := st_evid st in
     put (mk_st e' tr' p i)",2,Definition
get_ev,": CVM EvC :=
  st <- get ;;
  ret (st_ev st)",2,Definition
get_pl,": CVM Plc :=
  st <- get ;;
  ret (st_pl st)",2,Definition
modify_evm,"(f:EvC -> EvC) : CVM unit :=
  st <- get ;;
  let '{| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |} := st in
  put (mk_st (f e) tr p i)",2,Definition
add_trace,"(tr':list Ev) : cvm_st -> cvm_st :=
  fun '{| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |} =>
    mk_st e (tr ++ tr') p i",2,Definition
add_tracem,"(tr:list Ev) : CVM unit :=
  modify (add_trace tr)",2,Definition
tag_ASP,"(params :ASP_PARAMS) (mpl:Plc) (e:EvC) : CVM Event_ID :=
  x <- inc_id ;;
  add_tracem [umeas x mpl params (get_et e)] ;;
  ret x",2,Definition
fwd_asp,"(fwd:FWD) (bs:BS) (e:EvC) (p:Plc) (ps:ASP_PARAMS): EvC :=
  match fwd with
  | COMP => cons_hsh bs e p ps
  | EXTD => cons_gg bs e p ps
  | ENCR => cons_enc bs e p ps
  | KILL => mt_evc
  | KEEP => e
  end",2,Definition
invoke_ASP,"(fwd:FWD) (params:ASP_PARAMS) : CVM EvC :=
  e <- get_ev ;;
  p <- get_pl ;;
  x <- tag_ASP params p e ;;
  bs <- do_asp' params (get_bits e) p x ;;
  ret (fwd_asp fwd bs e p params)",2,Definition
copyEv,": CVM EvC :=
  p <- get_pl ;;
  x <- inc_id ;;
  add_tracem [copy x p] ;;
  get_ev",2,Definition
nullEv,": CVM EvC :=
  p <- get_pl ;;
  x <- inc_id ;;
  add_tracem [null x p] ;;
  ret mt_evc",2,Definition
clearEv,": unit -> CVM EvC :=
  fun _ => ret mt_evc",2,Definition
do_prim,"(a:ASP_Core) : CVM EvC :=
  match a with
  | NULLC => nullEv
  | CLEAR => clearEv tt
  | CPYC => copyEv
  | ASPCC fwd params => invoke_ASP fwd params
  end",2,Definition
tag_REQ,"(t:Term) (p:Plc) (q:Plc) (e:EvC) : CVM unit :=
  reqi <- inc_id ;;
  add_tracem [req reqi p q t (get_et e)]",2,Definition
tag_RPY,"(p:Plc) (q:Plc) (e:EvC) : CVM unit :=
  rpyi <- inc_id ;;
  add_tracem [rpy rpyi p q (get_et e)]",2,Definition
remote_session,"(t:Term) (p:Plc) (q:Plc) (e:EvC) : CVM EvC :=
  tag_REQ t p q e ;;
  e' <- doRemote_session' t q e ;;
  add_tracem (cvm_events t q (get_et e)) ;;
  inc_remote_event_ids t ;;
  ret e'",2,Definition
doRemote,"(t:Term) (q:Plc) (e:EvC) : CVM EvC :=
  p <- get_pl ;;
  e' <- remote_session t p q e ;;
  tag_RPY p q e' ;;
  ret e'",2,Definition
join_seq,"(e1:EvC) (e2:EvC): CVM unit :=
  p <- get_pl ;;
  n <- inc_id ;;
  put_ev (ss_cons e1 e2) ;;
  add_tracem [join n p]",2,Definition
start_par_thread,"(loc:Loc) (t:Core_Term) (e:EvC) : CVM unit :=
  p <- get_pl ;;
  do_start_par_thread loc t (get_bits e) ;;
  add_tracem [cvm_thread_start loc p t (get_et e)]",2,Definition
wait_par_thread,"(loc:Loc) (t:Core_Term) (e:EvC) : CVM EvC :=
  p <- get_pl ;;
  e' <- do_wait_par_thread loc t p e ;;
  add_tracem [cvm_thread_end loc] ;;
  inc_par_event_ids t ;;
  ret e'",2,Definition
run_cvm,"(t:Core_Term) st : cvm_st :=
  execSt (build_cvm t) st",2,Definition
run_cvm,"' (t:Term) st : cvm_st :=
  run_cvm (copland_compile t) st",2,Definition
run_cvm_fresh,"(t:Term) : cvm_st :=
  run_cvm' t empty_vmst",2,Definition
run_cvm_w_config,"(t:Term) (p:Plc) (e:RawEv) : cvm_st :=
  run_cvm' t (mk_st (evc e mt) [] p 0)",2,Definition
run_cvm_rawEv,"(t:Term) (p:Plc) (e:RawEv) : RawEv :=
  get_bits (st_ev (run_cvm_w_config t p e))",2,Definition
empty_vmst,:= mk_st (evc [] mt) [] min_id_type 0,2,Definition
CVM,:= St cvm_st,2,Definition
pairsinv,"forall (a a' b b':nat),
    a <> a' -> (a,b) <> (a',b')",1,Lemma
pairsinv_proof,"intros.
  congruence.",0,Proof
client_demo_am_comp,"(t:Term) : AppResultC :=
  run_am_sendReq_nonce t dest_plc source_plc",2,Definition
client_demo_am_comp_auth,"(t:Term) : AppResultC :=
  run_am_sendReq_nonce_auth t dest_plc source_plc",2,Definition
run_client_demo_am_comp,"(t:Term) : AppResultC :=
  run_am_app_comp (client_demo_am_comp t) mtc_app",2,Definition
eqb_asp_params_refl,"forall a,
    eqb_asp_params a a = true",1,Lemma
eqb_asp_params_refl_proof,"Allowed.



Fixpoint evsubt_bool (e:Evidence) (e':Evidence): bool :=
  match (eqb_evidence e e') with
  | true => true
  | false =>
    match e' with
    | gg _ _ et' => evsubt_bool e et'
    | hh _ _ et' => evsubt_bool e et'
    | ss e1 e2 => evsubt_bool e e1 || evsubt_bool e e2
    | _ => false
    end
  end.

Lemma eqb_asp_params_refl: forall a,
    eqb_asp_params a a = true.
Proof.
  intros. apply eqb_asp_params_true_iff. auto.",0,Proof
eqb_evidence_refl,"forall e,
    eqb_evidence e e = true",1,Lemma
eqb_evidence_refl_proof,intros. apply eqb_eq_evidence. auto.,0,Proof
evsubt_prop_bool,"forall e e',
    EvSubT e e' -> evsubt_bool e e' = true",1,Lemma
evsubt_prop_bool_proof,"intros.
  generalizeEverythingElse e'.
  induction e'; intros;
    try (invc H; ff; try tauto; rewrite PeanoNat.Nat.eqb_refl; tauto).
  - (* gg case *)
    invc H.
    +
    ff.
    rewrite PeanoNat.Nat.eqb_refl.
    rewrite eqb_asp_params_refl.
    rewrite eqb_evidence_refl.
    ff.
    +
      ff.
      assert (evsubt_bool e e' = true) by eauto.
      rewrite H.
      ff.
  - (* hh case *)
    invc H.
    +
    ff.
    rewrite PeanoNat.Nat.eqb_refl.
    rewrite eqb_asp_params_refl.
    rewrite eqb_evidence_refl.
    ff.
    +
      ff.
      assert (evsubt_bool e e' = true) by eauto.
      rewrite H.
      ff.
  - (* ss case *)
    ff.
    invc H.
    +
      rewrite eqb_evidence_refl.
      ff.
    +
      erewrite IHe'1.
      ff.
      eassumption.
    +
      erewrite IHe'2.
      ff.
      Search orb.
      rewrite Bool.orb_true_r.
      ff.
      eassumption.",0,Proof
evsubt_bool_prop,"forall e e',
    evsubt_bool e e' = true -> EvSubT e e'",1,Lemma
evsubt_bool_prop_proof,"intros.
  generalizeEverythingElse e'.
  induction e'; intros.
  -
    ff.
    destruct e; ff.
  -
    ff.
    destruct e; ff.
    Search (_ -> _ = _).
    Search PeanoNat.Nat.eqb_refl.
    rewrite EqNat.beq_nat_true with (n:=n0) (m:=n).
    ff.
    eassumption.
  -
    ff.
    destruct e; ff.
    rewrite Bool.andb_true_iff in Heqb.
    rewrite Bool.andb_true_iff in Heqb.
    destruct_conjs.
    rewrite eqb_eq_asp_params in *.
    Check  EqNat.beq_nat_true.
    apply EqNat.beq_nat_true in H0.
    apply eqb_eq_evidence in H1.
    subst.
   

    eapply evsub_reflT.
  -
    destruct e; ff.
    Search (if _ then _ else _).
    (*
Bool.orb_lazy_alt: forall a b : bool, (a || b)%bool = (if a then true else b)
     *)
    assert (
        (orb ((p0 =? p) && eqb_asp_params a0 a && eqb_evidence e e')%bool
            (evsubt_bool (hh p0 a0 e) e')) =
    (if ((p0 =? p) && eqb_asp_params a0 a && eqb_evidence e e')%bool
       then true
     else evsubt_bool (hh p0 a0 e) e')).
    {
      apply Bool.orb_lazy_alt.
    }
    rewrite H in H0.
    Search orb.
    apply Bool.orb_prop in H0.
    invc H0.
     rewrite Bool.andb_true_iff in H1.
    rewrite Bool.andb_true_iff in H1.
    destruct_conjs.
    rewrite eqb_eq_asp_params in *.
    Check  EqNat.beq_nat_true.
    apply EqNat.beq_nat_true in H0.
    apply eqb_eq_evidence in H1.
    subst.
   

    eapply evsub_reflT.
    eauto.
  - (* ss case *)
    ff.

     assert (
        (orb (eqb_evidence e (ss e'1 e'2))%bool
            (evsubt_bool e e'1 || evsubt_bool e e'2)) =
    (if eqb_evidence e (ss e'1 e'2)
       then true
     else (evsubt_bool e e'1 || evsubt_bool e e'2)%bool)).
     {
       apply Bool.orb_lazy_alt.
     }
     rewrite H in H0.

     apply Bool.orb_prop in H0.
     invc H0.
    +
      ff.
      apply eqb_eq_evidence in Heqb.
      ff.
    +
      apply Bool.orb_prop in H1.
      invc H1.
      ++
        ff.
      ++
        ff.",0,Proof
evsubt_bool_prop_iff,"forall e e',
    EvSubT e e' <-> evsubt_bool e e' = true",1,Lemma
evsubt_bool_prop_iff_proof,"intros; split.
  apply evsubt_prop_bool.
  apply evsubt_bool_prop.",0,Proof
term_remote_disclosures_correct_events,"forall t p e r annt ev,
    term_discloses_to_remote t p e r = false -> 
    annoP annt t ->
    events annt p e ev ->
    ~ (discloses_to_remote ev r)",1,Lemma
term_remote_disclosures_correct_events_proof,"intros.
  unfold not in *; intros.
  generalizeEverythingElse t.
  induction t; ff; intros.
  -
    invc H0.
    destruct_conjs.
    destruct a; ff.
    repeat find_inversion.
    invc H1.
    invc H2.
    invc H1.
    invc H2.
    invc H1.
    invc H2.
    invc H1.
    invc H2.
    invc H2.
    invc H1.
  - (* @ case *)
    invc H0.
    destruct_conjs.
    invc H4.
    break_let.
    invc H6; simpl in *.
    rewrite Bool.orb_false_iff in H.
    destruct_conjs.


    (*
    
    assert ( andb (Nat.eqb p p1) (eqb_evidence e e0) = false).
    admit.
    assert (term_discloses_to_remote t p e (p1, e0) = false).
    admit. *)
    invc H1.
    +
    simpl in *.
    invc H2.
    assert (evsubt_bool e0 e = false).
    {
      rewrite <- EqNat.beq_nat_refl in H.
      Search andb.
      rewrite Bool.andb_true_l in H.
      eassumption.
    }
    rewrite evsubt_bool_prop_iff in H4.
    rewrite H4 in H1. solve_by_inversion.

    (*
    
    solve_by_inversion.
    
    rewrite PeanoNat.Nat.eqb_refl in H.
    assert (eqb_evidence e0 e0 = true).
    {
      apply eqb_eq_evidence. auto. }
    rewrite H1 in *.
    invc H. *)
    +
      eapply IHt.
      eassumption.
      econstructor. repeat eexists. eassumption.
      eassumption.
      eassumption.
    +
      simpl in *.
      solve_by_inversion.
  -

    rewrite Bool.orb_false_iff in H.
    destruct_conjs.

    (*
    
    assert (term_discloses_to_remote t1 p e r = false).
    admit.
    assert (term_discloses_to_remote t2 p (eval t1 p e) r = false).
    admit. *)
    invc H0.
    destruct_conjs.
    invc H5.
    repeat break_let.
    find_inversion.

    invc H1.
    + (* t1 case *)
      eapply IHt1.
      eassumption.
      econstructor. repeat eexists. eassumption.
      eassumption.
      eassumption.
    + (* t2 case *)
      eapply IHt2.
      eassumption.
      econstructor. repeat eexists. eassumption.
      
      assert (eval t1 p e = aeval a p e).
      {
        erewrite eval_aeval.
        rewrite Heqp1.
        simpl. tauto.
      }
      rewrite H1.
      eassumption.
      eassumption.
  -
    rewrite Bool.orb_false_iff in H.
    destruct_conjs.
    (*
    assert (term_discloses_to_remote t1 p (splitEv_mt s0 e) r = false).
    admit.
    assert (term_discloses_to_remote t2 p (splitEv_mt s1 e) r = false).
    admit.
     *)
    

    invc H0.
    destruct_conjs.
    invc H5.
    repeat break_let.
    ff.
    invc H1; ff.
    + (* t1 case *)
      destruct s0.
      ++
        eapply IHt1.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
      ++
        eapply IHt1.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
    + (* t2 case *)
      destruct s0.
      ++
        eapply IHt2.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
      ++
        eapply IHt2.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
  -
    rewrite Bool.orb_false_iff in H.
    destruct_conjs.
    (*
    assert (term_discloses_to_remote t1 p (splitEv_mt s0 e) r = false).
    admit.
    assert (term_discloses_to_remote t2 p (splitEv_mt s1 e) r = false).
    admit.
     *)
    

    invc H0.
    destruct_conjs.
    invc H5.
    repeat break_let.
    ff.
    invc H1; ff.
    + (* t1 case *)
      destruct s0.
      ++
        eapply IHt1.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
      ++
        eapply IHt1.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
    + (* t2 case *)
      destruct s0.
      ++
        eapply IHt2.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
      ++
        eapply IHt2.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.",0,Proof
filter_remote_disclosures_correct_events,"forall rs p e ts ts' t annt r ev,
  filter_remote_disclosures rs p e ts = ts' ->
  (*In t ts -> *)
  annoP annt t ->
  events annt p e ev ->
  In r rs ->
  In t ts' -> 
  ~ (discloses_to_remote ev r)",1,Lemma
filter_remote_disclosures_correct_events_proof,"intros.
  generalizeEverythingElse ls.
  induction ls; intros.
  -
    ff.
  -
    ff.
    rewrite Bool.orb_false_iff in H.
    destruct_conjs.
    
    assert (negb (f a) = true).
    {
      rewrite H. tauto.
    }
    assert (forallb (fun r : A => negb (f r)) ls = true).
    eapply IHls. eassumption.
    rewrite H1. rewrite H2. tauto.",0,Proof
lts_refines_events,"forall t p e tr ev,
  well_formed_r_annt t ->
  lstar (conf t p e) tr (stop p (aeval t p e)) ->
  In ev tr ->
  events t p e ev",1,Lemma
lts_refines_events_proof,"Check term_remote_disclosures_correct_events.
  (*
     : forall (t : Term) (p : Plc) (e : Evidence) (r : Plc * Evidence) (annt : AnnoTerm) (ev : Ev),
       term_discloses_to_remote t p e r = false ->
       annoP annt t -> events annt p e ev -> ~ discloses_to_remote ev r
   *)
  Check filter_In.
  (*
     : forall (A : Type) (f : A -> bool) (x : A) (l : list A), In x (filter f l) <-> In x l /\ f x = true
   *)
  intros.
  unfold filter_remote_disclosures in *.

  eapply term_remote_disclosures_correct_events.
  3: { eassumption. }
  2: { eassumption. }

  rewrite <- H in H3. clear H.
  rewrite filter_In in H3.
  destruct_conjs. clear H.
  unfold term_discloses_to_remotes in *.
  Check existsb_exists.
  (*
     : forall (A : Type) (f : A -> bool) (l : list A),
       existsb f l = true <-> (exists x : A, In x l /\ f x = true)
   *)

  
  assert ((existsb (term_discloses_to_remote t p e) rs) = false).
  {
    rewrite <- Bool.negb_true_iff.
    eassumption.
  }
  clear H3.

  assert (forall x, In x rs -> term_discloses_to_remote t p e x = false).
  {
    intros.
    assert (forallb (fun r => negb (term_discloses_to_remote t p e r)) rs = true).
    {
      eapply hii.
      eassumption.
    }
    rewrite forallb_forall in H4.
      Search negb.
  (*
Bool.negb_false_iff: forall b : bool, negb b = false <-> b = true
Bool.negb_true_iff: forall b : bool, negb b = true <-> b = false
   *)
      rewrite <- Bool.negb_true_iff.
      eapply H4.
      eassumption.
  }

  eapply H3. eassumption.",0,Proof
events_refines_lts,"forall t p e tr ev,
    events t p e ev ->
    In ev tr ->
    lstar (conf t p e) tr (stop p (aeval t p e))",1,Lemma
events_refines_lts_proof,"intros.
  eapply trace_events; eauto.
  eapply lstar_trace; eauto.",0,Proof
filter_remote_disclosures_correct_cvm,"forall rs p e ts ts' t annt r ev atp i i' bits bits' e' cvm_tr p',
    filter_remote_disclosures rs p e ts = ts' ->
    In t ts' -> 
    term_to_coreP t atp ->
    annoP_indexed annt t i i' ->
    copland_compileP atp
                     (mk_st (evc bits e) [] p i)
                     (Some tt)
                     (mk_st (evc bits' e') cvm_tr p' i') ->
    
    In ev cvm_tr ->
    In r rs ->
    ~ (discloses_to_remote ev r)",1,Lemma
filter_remote_disclosures_correct_cvm_proof,,0,Proof
term_asp_disclosures_correct_events,"forall t p e r annt ev,
    term_discloses_to_asp t p e r = false -> 
    annoP annt t ->
    events annt p e ev ->
    ~ (discloses_to_asp ev r)",1,Lemma
term_asp_disclosures_correct_events_proof,"intros.
  assert (events annt p e ev).
  {
    eapply lts_refines_events.
    -
      invc H2.
      eapply anno_well_formed_r.
      eassumption.
    -
      eapply cvm_refines_lts_events.
      +
        eassumption.
      +
        eassumption.
      +
        eassumption.
        
    -
      eassumption. 
  }
  
  eapply filter_remote_disclosures_correct_events; eauto.
  invc H2.
  econstructor.
  repeat eexists. eassumption.",0,Proof
filter_asp_disclosures_correct_events,"forall rs p e ts ts' t annt r ev,
  filter_asp_disclosures rs p e ts = ts' ->
  In t ts ->
  annoP annt t ->
  events annt p e ev ->
  In r rs ->
  In t ts' -> 
  ~ (discloses_to_asp ev r)",1,Lemma
filter_asp_disclosures_correct_events_proof,"intros.
  unfold not in *; intros.
  generalizeEverythingElse t.
  induction t; ff; intros.
  -
    invc H0.
    destruct_conjs.
    destruct a; ff.
    
    invc H1.
    invc H2.
    invc H1.
    invc H2.

    invc H1.
    invc H2.

    rewrite PeanoNat.Nat.eqb_refl in H.

    assert (eqb_aspid a0 a0 = true).
    {
      apply eqb_eq_aspid. auto.
    }
    rewrite H0 in *; clear H0.
    invc H.
    

    (*
     assert (eqb_evidence e0 e0 = true).
    {
      apply eqb_eq_evidence. auto. }
     *)

    rewrite evsubt_bool_prop_iff in H1.
    rewrite H1 in *.
    solve_by_inversion.

    (*
    
    rewrite H0 in *; clear H0.
    assert (eqb_aspid a0 a0 = true).
    {
      apply eqb_eq_aspid. auto.
    }
    rewrite H0 in *; clear H0.
    invc H. *)

    

    invc H1.
    simpl in *.
    invc H2.

    assert (eqb_evidence mt mt = true).
    {
      apply eqb_eq_evidence. auto. }
    invc H1.
    rewrite H0 in *.
    solve_by_inversion.

    invc H1.
    invc H2.

    destruct sig_params.
    ff.

    rewrite PeanoNat.Nat.eqb_refl in H.

    (*
     assert (eqb_evidence e0 e0 = true).
    {
      apply eqb_eq_evidence. auto. } *)
    assert (eqb_aspid a a = true).
    {
      apply eqb_eq_aspid. auto.
    }
    rewrite H0 in *; clear H0.
    invc H.
    rewrite evsubt_bool_prop_iff in H1.
    rewrite H1 in *. solve_by_inversion.

    (*

    
    assert (evsubt_bool e0 e = false).
    {
      admit.
    }
    
    rewrite H0 in *; clear H0.
    assert (eqb_aspid a a = true).
    {
      apply eqb_eq_aspid. auto.
    }
    rewrite H0 in *; clear H0.
    invc H. *)

     invc H1.
    invc H2.

    destruct hsh_params.
    ff.

    rewrite PeanoNat.Nat.eqb_refl in H.

    assert (eqb_aspid a a = true).
    {
      apply eqb_eq_aspid. auto.
    }
    rewrite H0 in *; clear H0.
    invc H.
    rewrite evsubt_bool_prop_iff in H1.
    rewrite H1 in *. solve_by_inversion.

(*
    
     assert (eqb_evidence e0 e0 = true).
    {
      apply eqb_eq_evidence. auto. }
    rewrite H0 in *; clear H0.
    assert (eqb_aspid a a = true).
    {
      apply eqb_eq_aspid. auto.
    }
    rewrite H0 in *; clear H0.
    invc H.
*)

    
    
      

  -
    invc H0.
    destruct_conjs.
    invc H4.
    break_let.
    invc H6; simpl in *.
    (*
    rewrite Bool.orb_false_iff in H.
    destruct_conjs. *)


    (*
    
    assert ( andb (Nat.eqb p p1) (eqb_evidence e e0) = false).
    admit.
    assert (term_discloses_to_remote t p e (p1, e0) = false).
    admit. *)
    invc H1.
    +
    simpl in *.
    invc H2.

    (*
    rewrite PeanoNat.Nat.eqb_refl in H.
    assert (eqb_evidence e0 e0 = true).
    {
      apply eqb_eq_evidence. auto. }
    rewrite H1 in *.
    invc H. *)
    +
      eapply IHt.
      eassumption.
      econstructor. repeat eexists. eassumption.
      eassumption.
      eassumption.
    +
      simpl in *.
      solve_by_inversion.
  -

    rewrite Bool.orb_false_iff in H.
    destruct_conjs.

    (*
    
    assert (term_discloses_to_remote t1 p e r = false).
    admit.
    assert (term_discloses_to_remote t2 p (eval t1 p e) r = false).
    admit. *)
    invc H0.
    destruct_conjs.
    invc H5.
    repeat break_let.
    find_inversion.

    invc H1.
    + (* t1 case *)
      eapply IHt1.
      eassumption.
      econstructor. repeat eexists. eassumption.
      eassumption.
      eassumption.
    + (* t2 case *)
      eapply IHt2.
      eassumption.
      econstructor. repeat eexists. eassumption.
      
      assert (eval t1 p e = aeval a0 p e).
      {
        erewrite eval_aeval.
        rewrite Heqp1.
        simpl. tauto.
      }
      rewrite H1.
      eassumption.
      eassumption.
  -
    rewrite Bool.orb_false_iff in H.
    destruct_conjs.
    (*
    assert (term_discloses_to_remote t1 p (splitEv_mt s0 e) r = false).
    admit.
    assert (term_discloses_to_remote t2 p (splitEv_mt s1 e) r = false).
    admit.
     *)
    

    invc H0.
    destruct_conjs.
    invc H5.
    repeat break_let.
    ff.
    invc H1; ff.
    + (* t1 case *)
      destruct s0.
      ++
        eapply IHt1.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
      ++
        eapply IHt1.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
    + (* t2 case *)
      destruct s0.
      ++
        eapply IHt2.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
      ++
        eapply IHt2.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
  -
    rewrite Bool.orb_false_iff in H.
    destruct_conjs.
    (*
    assert (term_discloses_to_remote t1 p (splitEv_mt s0 e) r = false).
    admit.
    assert (term_discloses_to_remote t2 p (splitEv_mt s1 e) r = false).
    admit.
     *)
    

    invc H0.
    destruct_conjs.
    invc H5.
    repeat break_let.
    ff.
    invc H1; ff.
    + (* t1 case *)
      destruct s0.
      ++
        eapply IHt1.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
      ++
        eapply IHt1.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
    + (* t2 case *)
      destruct s0.
      ++
        eapply IHt2.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.
      ++
        eapply IHt2.
        eassumption.
        econstructor. repeat eexists. eassumption.
        simpl. eassumption.
        eassumption.",0,Proof
filter_asp_disclosures_correct_cvm,"forall rs p e ts ts' t annt r ev atp i i' bits bits' e' cvm_tr p',
  filter_asp_disclosures rs p e ts = ts' ->
  In t ts ->

  term_to_coreP t atp ->
  (*anno_parP atp t -> *)
  annoP_indexed annt t i i' ->
  copland_compileP atp
                   (mk_st (evc bits e) [] p i)
                   (Some tt)
                   (mk_st (evc bits' e') cvm_tr p' i') ->

  In ev cvm_tr ->
  
  In r rs ->
  In t ts' -> 
  ~ (discloses_to_asp ev r)",1,Lemma
filter_asp_disclosures_correct_cvm_proof,"intros.
  unfold filter_asp_disclosures in *.

  eapply term_asp_disclosures_correct_events.
  3: { eassumption. }
  2: { eassumption. }

  rewrite <- H in H4. clear H.
  rewrite filter_In in H4.
  destruct_conjs. clear H.
  unfold term_discloses_to_asps in *.
  Check existsb_exists.
  (*
     : forall (A : Type) (f : A -> bool) (l : list A),
       existsb f l = true <-> (exists x : A, In x l /\ f x = true)
   *)

  
  assert ((existsb (term_discloses_to_asp t p e) rs) = false).
  {
    rewrite <- Bool.negb_true_iff.
    eassumption.
  }
  clear H4.

  assert (forall x, In x rs -> term_discloses_to_asp t p e x = false).
  {
    intros.
    assert (forallb (fun r => negb (term_discloses_to_asp t p e r)) rs = true).
    {
      eapply hii.
      eassumption.
    }
    rewrite forallb_forall in H5.
      Search negb.
  (*
Bool.negb_false_iff: forall b : bool, negb b = false <-> b = true
Bool.negb_true_iff: forall b : bool, negb b = true <-> b = false
   *)
      rewrite <- Bool.negb_true_iff.
      eapply H5.
      eassumption.
  }

  eapply H4. eassumption.",0,Proof
splitEv_mt,"(sp:SP) (e:Evidence) : Evidence :=
  match sp with
  | ALL => e
  | NONE => mt
  end",2,Definition
splitEv_mt_proof,"intros.
  assert (events annt p e ev).
  {
    eapply lts_refines_events.
    -
      invc H2.
      eapply anno_well_formed_r.
      eassumption.
    -
      eapply cvm_refines_lts_events.
      +
        eassumption.
      +
        eassumption.
      +
        eassumption.
        
    -
      eassumption. 
  }
  
  eapply filter_asp_disclosures_correct_events; eauto.
  invc H2.
  econstructor.
  repeat eexists. eassumption.",0,Proof
term_discloses_to_remotes,"(rs: list (Plc*Evidence)) (t:Term) (p:Plc) (e:Evidence) : bool :=
  existsb (term_discloses_to_remote t p e) rs",2,Definition
filter_remote_disclosures,"(rs: list (Plc*Evidence)) (p:Plc) (e:Evidence) (ts:list Term):
  list Term := filter (fun t => negb (term_discloses_to_remotes rs t p e)) ts",2,Definition
get_aspid,"(ps:ASP_PARAMS): ASP_ID :=
  match ps with
  | asp_paramsC i _ _ _ => i
  end",2,Definition
term_discloses_to_remotes,"(rs: list (Plc*Evidence)) (t:Term) (p:Plc) (e:Evidence) : bool :=
  existsb (term_discloses_to_remote t p e) rs",2,Definition
filter_remote_disclosures,"(rs: list (Plc*Evidence)) (p:Plc) (e:Evidence) (ts:list Term):
  list Term := filter (fun t => negb (term_discloses_to_remotes rs t p e)) ts",2,Definition
term_discloses_to_asps,"(ls: list (Plc*ASP_ID*Evidence)) (t:Term) (p:Plc) (e:Evidence) : bool :=
  existsb (term_discloses_to_asp t p e) ls",2,Definition
filter_asp_disclosures,"(ls: list (Plc*ASP_ID*Evidence)) (p:Plc) (e:Evidence) (ts:list Term):
  list Term := filter (fun t => negb (term_discloses_to_asps ls t p e)) ts",2,Definition
eqbPair,"{A B:Type}`{H:EqClass A}`{H':EqClass B} (p1:A*B) (p2:A*B) : bool :=
  match (p1,p2) with
  | ((a1,b1), (a2,b2)) => andb (eqb a1 a2) (eqb b1 b2)
  end",2,Definition
eqbPair_proof,"intros.
  destruct (eqb x y) eqn:E.
  - left; eapply eqb_leibniz; eauto.
  - right; erewrite <- eqb_leibniz; intros HC; congruence.",0,Proof
eqb_eq_aspid,"forall `{H : EqClass ID_Type} i1 i2,
    eqb_aspid i1 i2 = true -> i1 = i2",1,Lemma
eqb_eq_aspid_proof,"Allowed.
 *)


Definition eqb_aspid `{H : EqClass ID_Type} (a1 a2 : ASP_ID)  : bool :=
  eqb a1 a2.

(** Admitted Lemmas relating boolean to propositional equality for 
   ASP ID and PARAMS *)
Lemma eqb_eq_aspid: forall `{H : EqClass ID_Type} i1 i2,
    eqb_aspid i1 i2 = true -> i1 = i2.
Proof.
  unfold eqb_aspid.
  destruct H. eapply eqb_leibniz.",0,Proof
eqb_eq_asp_params,"forall `{H : EqClass ID_Type} a a0 ,
    eqb_asp_params a a0 = true <->
    a = a0",1,Lemma
eqb_eq_asp_params_proof,"intros.
  decide equality; subst;
  eapply EqClass_impl_DecEq; eauto.
  eapply EqClass_extends_to_list; eauto.",0,Proof
eqb_eq_fwd,"forall f1 f2,
    eqb_fwd f1 f2 = true <->
    f1 = f2",1,Lemma
eqb_eq_fwd_proof,"induction a; destruct a0; simpl;
  repeat (rewrite Bool.andb_true_iff);
  repeat split; eauto; try inv H0;
  try rewrite eqb_leibniz; eauto;
  try (eapply EqClass_extends_to_list; eauto).
  - intros; destruct_conjs; subst.
    repeat (rewrite eqb_leibniz in *); subst.
    eapply general_list_eqb_leibniz in H1; subst; eauto.
  - eapply eqb_leibniz; eauto.",0,Proof
eqb_eq_evidence,"forall e1 e2,
    eqb_evidence e1 e2 = true <-> e1 = e2",1,Lemma
eqb_eq_evidence_proof,"intros.
  decide equality; subst;
  try (try eapply EqClass_impl_DecEq; eauto;
  try eapply nat_EqClass; eauto; fail).
  - eapply eq_asp_params_dec.
  - destruct f, f0; eauto; right; intros HC; congruence.",0,Proof
eqb_aspid,"`{H : EqClass ID_Type} (a1 a2 : ASP_ID)  : bool :=
  eqb a1 a2",2,Definition
eqb_aspid_proof,"intros.
  decide equality; subst;
  try (try eapply EqClass_impl_DecEq; eauto;
  try eapply nat_EqClass; eauto; fail).
  - destruct a, a0; eauto; try (right; intros HC; congruence).
    * destruct (eq_asp_params_dec a a0); subst; eauto;
      destruct s, s0, f, f0; eauto; try (right; intros HC; congruence).
    * destruct (@EqClass_impl_DecEq Plc H p p0); subst; eauto.
      right; intros HC; congruence.
  - destruct s, s0, s, s1, s0, s2; eauto; try (right; intros HC; congruence).
  - destruct s, s0, s, s1, s0, s2; eauto; try (right; intros HC; congruence).",0,Proof
eqb_asp_params,"`{H : EqClass ID_Type} `{H : EqClass (list ID_Type)} (ap1 ap2 : ASP_PARAMS) : bool :=
  match ap1, ap2 with
  | (asp_paramsC a1 la1 p1 t1), (asp_paramsC a2 la2 p2 t2) =>
      andb (eqb_aspid a1 a2) 
        (andb (eqb la1 la2)
          (andb (eqb p1 p2) 
                (eqb t1 t2)))
  end",2,Definition
eqb_asp_params_proof,"intros.
  decide equality; subst;
  try (try eapply EqClass_impl_DecEq; eauto;
  try eapply nat_EqClass; eauto; fail).
  - destruct a, a0; eauto; try (right; intros HC; congruence).
    * destruct (eq_asp_params_dec a a0); subst; eauto;
      destruct f, f0; eauto; try (right; intros HC; congruence).
  - eapply eq_term_dec.",0,Proof
eq_asp_params_dec,"`{H : EqClass ID_Type} :
  forall x y: ASP_PARAMS, {x = y} + {x <> y}",2,Definition
eq_asp_params_dec_proof,"intros;
  decide equality; subst;
  try (try eapply EqClass_impl_DecEq; eauto;
  try eapply nat_EqClass; 
  try eapply EqClassASP_Params; eauto; fail).
  repeat decide equality; subst;
  try (try eapply EqClass_impl_DecEq; eauto;
  try eapply nat_EqClass; eauto; fail).
  - eapply eq_asp_params_dec.
  - eapply eq_evidence_dec.
  - eapply eq_term_dec.
  - eapply eq_evidence_dec.
  - eapply eq_evidence_dec.
  - eapply eq_core_term_dec.",0,Proof
eq_evidence_dec,": forall `{H : EqClass ID_Type},
  forall x y : Evidence, {x = y} + {x <> y}",2,Definition
eq_evidence_dec_proof,"intros.
   generalizeEverythingElse y.
   induction y; intros.
   -
     cbn.
     tauto.
   -
     cbn.
     eapply andb_true_intro.
     split.
     +
       eapply H; eauto.
     +
       eauto.",0,Proof
eq_term_dec,": forall `{H : EqClass ID_Type},
  forall x y : Term, {x = y} + {x <> y}",2,Definition
eq_term_dec_proof,"intros.
  generalizeEverythingElse x.
  induction x; destruct y; intros.
  -
    cbn in *.
    split; tauto.
  -
    cbn in *.
    split;
      intros;
      solve_by_inversion.
  -
    cbn in *.
    split; intros;
      solve_by_inversion.
  -
    cbn in *.
    split; intros.
    +
      assert (f a a0 = true /\ list_beq A f x y = true).
      {
        eapply Bool.andb_true_iff.
        eassumption.
      }
      destruct_conjs.
      
      edestruct IHx with (y:= y).
      assert (x = y).
      {
        eapply IHx.
        split; intros.
        eapply H.
        eassumption.
        specialize H with (a:=a1) (b:=b).
        inversion H.
        eapply H5. eassumption.
        eassumption.
      }
      intros.
      split; intros.
      specialize H with (a:=a1) (b:=b).
      invc H.
      eapply H5; eauto.
      subst.
      specialize H with (a:=b) (b:=b).
      invc H.
      eapply H4; eauto.
      

      assert (a = a0).
      {
        
      
        concludes.
        eapply H.
        eassumption.
      }
      subst.
      assert (x = y).
      {
        eapply IHx.
        eassumption.
        eassumption.
      }
      congruence.
    +
      invc H0.
      eapply andb_true_intro.
      split.
      eapply H.
      reflexivity.
      eapply list_beq_refl; eauto.",0,Proof
eq_core_term_dec,": forall `{H : EqClass ID_Type},
  forall x y : Core_Term, {x = y} + {x <> y}",2,Definition
eq_core_term_dec_proof,,0,Proof
eq_ev_dec,": forall `{H : EqClass ID_Type},
  forall x y: Ev, {x = y} + {x <> y}",2,Definition
eq_ev_dec_proof,"intros.
  split.
  -
    generalizeEverythingElse e1.
    induction e1; destruct e2; intros;
      try (cbn in *; repeat break_match; try solve_by_inversion; eauto).
    + rewrite Nat.eqb_eq in H; eauto.
    + cbn in *.
      rewrite Bool.andb_true_iff in H.
      rewrite Bool.andb_true_iff in H.
      rewrite Bool.andb_true_iff in H.
      destruct_conjs.
      rewrite eqb_leibniz in H.
      specialize IHe1 with e2.
      concludes.
      rewrite eqb_eq_asp_params in H1.
      rewrite eqb_eq_fwd in H2.
      congruence.


(*
      
    +
      cbn in *.
      rewrite Bool.andb_true_iff in H.
      rewrite Bool.andb_true_iff in H.
      destruct_conjs.
      apply EqNat.beq_nat_true in H.
      subst.
      specialize IHe1 with e2.
      concludes.
      assert (a = a0).
      {
        erewrite <- eqb_eq_asp_params.
        eassumption.
      }       
      congruence.  
      
    +
      cbn in *.
      rewrite Bool.andb_true_iff in H.
      rewrite Bool.andb_true_iff in H.
      destruct_conjs.
      apply EqNat.beq_nat_true in H.
      specialize IHe1 with e2.
      concludes.
      rewrite eqb_eq_asp_params in H1.
      congruence.
*)


    +
      cbn in *.
      rewrite Bool.andb_true_iff in H.
      destruct_conjs.
      specialize IHe1_1 with e2_1.
      specialize IHe1_2 with e2_2.
      concludes.
      concludes.
      congruence.
  -
    generalizeEverythingElse e1.
    induction e1; destruct e2; intros;
      try (cbn in * ; repeat break_match; try solve_by_inversion; eauto).
    + invc H. rewrite Nat.eqb_eq; eauto.
    + invc H.
      cbn in *.
      repeat rewrite Bool.andb_true_iff.
      split. split. split. 
      * eapply eqb_leibniz; eauto.
      * rewrite eqb_eq_fwd. tauto.
      * erewrite eqb_eq_asp_params. tauto.
      * eauto.
      (*
    +
      invc H.
      cbn in *.
      repeat rewrite Bool.andb_true_iff.
      split. split.
      apply Nat.eqb_refl.
      erewrite eqb_eq_asp_params. tauto.
      eauto. *)
    +
      invc H.
      cbn in *.
      repeat rewrite Bool.andb_true_iff.
      split;
        eauto.",0,Proof
eqb_fwd,(fwd1 fwd2 : FWD) : bool,2,Definition
well_structured_range,"forall es,
      well_structured es ->
      snd (es_range es) = fst (es_range es) + es_size es",1,Lemma
well_structured_range_proof,"induction es; simpl; intros; inv H; simpl; auto;
      try rewrite Nat.add_1_r; auto;
        apply IHes1 in H3;
        apply IHes2 in H4;
        lia.",0,Proof
prec_in_left,"forall es ev1 ev2,
      prec es ev1 ev2 -> ev_in ev1 es",1,Lemma
prec_in_left_proof,intros; induction H; auto.,0,Proof
prec_in_right,"forall es ev1 ev2,
      prec es ev1 ev2 -> ev_in ev2 es",1,Lemma
prec_in_right_proof,intros; induction H; auto.,0,Proof
ws_evsys_range,"forall es e,
      well_structured es ->
      ev_in e es ->
      fst (es_range es) <= ev e < snd (es_range es)",1,Lemma
ws_evsys_range_proof,"intros.
    pose proof H as G.
    apply well_structured_range in G.
    rewrite G.
    clear G.
    revert H0.
    revert e.
    induction es; intros; simpl in *; inv H; simpl in *;
      inv H0; simpl; try lia.
    - apply IHes1 in H2; auto; lia.
    - apply IHes2 in H2; auto.
      apply well_structured_range in H4.
      lia.
    - apply IHes1 in H2; auto; lia.
    - apply IHes2 in H2; auto.
      apply well_structured_range in H4.
      lia.",0,Proof
es_injective_events,"forall es ev0 ev1,
      well_structured es ->
      ev_in ev0 es -> ev_in ev1 es ->
      ev ev0 = ev ev1 ->
      ev0 = ev1",1,Lemma
es_injective_events_proof,"intros.
    revert H2.
    revert H1.
    revert H0.
    revert ev1.
    revert ev0.
    induction H; intros; simpl in *.
    - inv H1; inv H2; auto.
    - inv H3; inv H4.
      + eapply IHwell_structured1 in H8; eauto.
      + apply ws_evsys_range in H8; auto.
        apply ws_evsys_range in H6; auto.
        lia.
      + apply ws_evsys_range in H8; auto.
        apply ws_evsys_range in H6; auto.
        lia.
      + eapply IHwell_structured2 in H8; eauto.
    - inv H3; inv H4.
      + eapply IHwell_structured1 in H8; eauto.
      + apply ws_evsys_range in H8; auto.
        apply ws_evsys_range in H6; auto.
        lia.
      + apply ws_evsys_range in H8; auto.
        apply ws_evsys_range in H6; auto.
        lia.
      + eapply IHwell_structured2 in H8; eauto.",0,Proof
evsys_irreflexive,"forall es ev,
      well_structured es ->
      ~prec es ev ev",1,Lemma
evsys_irreflexive_proof,"induction es; intros; intro; inv H; inv H0.
    - apply ws_evsys_range in H8; auto.
      apply ws_evsys_range in H9; auto.
      lia.
    - apply IHes1 in H8; auto.
    - apply IHes2 in H8; auto.
    - apply IHes1 in H8; auto.
    - apply IHes2 in H8; auto.",0,Proof
evsys_transitive,"forall es ev0 ev1 ev2,
      well_structured es ->
      prec es ev0 ev1 ->
      prec es ev1 ev2 ->
      prec es ev0 ev2",1,Lemma
evsys_transitive_proof,"induction es; intros.
    - inv H0.
    - inv H.
      inv H0.
      + inv H1.
        * apply ws_evsys_range in H10; auto.
        * apply prec_in_left in H7.
          apply ws_evsys_range in H7; auto.
          apply ws_evsys_range in H10; auto.
          lia.
        * apply prec_in_right in H7; auto.
      + assert (G: ev_in ev0 es1). apply prec_in_left in H9; auto.
        assert (F: ev_in ev1 es1). apply prec_in_right in H9; auto.
        inv H1; auto.
        eapply IHes1 in H7; eauto.
        apply prseq; auto.
        apply prec_in_right in H7; auto.
      + assert (G: ev_in ev0 es2). apply prec_in_left in H9; auto.
        assert (F: ev_in ev1 es2). apply prec_in_right in H9; auto.
        inv H1.
        * apply ws_evsys_range in H7; auto.
          apply ws_evsys_range in F; auto.
          lia.
        * apply prec_in_left in H7.
          apply ws_evsys_range in H7; auto.
          apply ws_evsys_range in F; auto.
          lia.
        * eapply IHes2 in H7; eauto.
    - inv H.
      inv H0.
      + inv H1.
        * eapply IHes1 in H7; eauto.
        * apply prec_in_left in H7.
          apply prec_in_right in H9.
          apply ws_evsys_range in H9; auto.
          apply ws_evsys_range in H7; auto.
          lia.
      + assert (G: ev_in ev0 es2). apply prec_in_left in H9; auto.
        assert (F: ev_in ev1 es2). apply prec_in_right in H9; auto.
        inv H1.
        * apply prec_in_left in H7.
          apply ws_evsys_range in H7; auto.
          apply ws_evsys_range in F; auto.
          lia.
        * eapply IHes2 in H7; eauto.",0,Proof
ws_merge1,"forall r s x y z,
      well_structured (merge r x y) ->
      well_structured (merge s y z) ->
      well_structured (merge (fst r, snd s) x (merge s y z))",1,Lemma
ws_merge1_proof,"intros r s x y z Hr Hs.
    inv Hr; inv Hs.
    constructor; simpl; auto; lia.",0,Proof
ws_merge2,"forall r s x y z,
      well_structured (merge r x y) ->
      well_structured (merge s y z) ->
      well_structured (merge (fst r, snd s) (merge r x y) z)",1,Lemma
ws_merge2_proof,"intros r s x y z Hr Hs.
    inv Hr; inv Hs.
    constructor; simpl; auto; lia.",0,Proof
merge_associative,"forall r s x y z,
      same_rel (merge (fst r, snd s) x (merge s y z))
               (merge (fst r, snd s) (merge r x y) z)",1,Lemma
merge_associative_proof,"intros r s x y z.
    split; intro; inv H.
    - apply prparl; apply prparl; auto.
    - inv H5.
      + apply prparl; apply prparr; auto.
      + apply prparr; auto.
    - inv H5.
      + apply prparl; auto.
      + apply prparr; apply prparl; auto.
    - apply prparr; apply prparr; auto.",0,Proof
merge_associative_pairs,"forall r0 r1 s0 s1 x y z,
      same_rel (merge (r0, s1) x (merge (s0, s1) y z))
               (merge (r0, s1) (merge (r0, r1) x y) z)",1,Lemma
merge_associative_pairs_proof,"intros.
    apply merge_associative with (s:=(s0, s1))(r:=(r0,r1)).",0,Proof
ws_before1,"forall r s x y z,
      well_structured (before r x y) ->
      well_structured (before s y z) ->
      well_structured (before (fst r, snd s) x (before s y z))",1,Lemma
ws_before1_proof,"intros r s x y z Hr Hs.
    inv Hr; inv Hs.
    constructor; simpl; auto; lia.",0,Proof
ws_before2,"forall r s x y z,
      well_structured (before r x y) ->
      well_structured (before s y z) ->
      well_structured (before (fst r, snd s) (before r x y) z)",1,Lemma
ws_before2_proof,"intros r s x y z Hr Hs.
    inv Hr; inv Hs.
    constructor; simpl; auto; lia.",0,Proof
before_associative,"forall r s x y z,
      same_rel (before (fst r, snd s) x (before s y z))
               (before (fst r, snd s) (before r x y) z)",1,Lemma
before_associative_proof,"intros r s x y z.
    split; intro; inv H.
    - inv H6.
      + apply prseql; auto.
      + apply prseq; auto.
    - apply prseql; apply prseql; auto.
    - inv H5.
      + apply prseq; auto.
      + apply prseql; apply prseqr; auto.
      + apply prseqr; auto.
    - inv H5.
      + apply prseq; auto.
      + apply prseqr; apply prseq; auto.
    - inv H5.
      + apply prseq; auto.
      + apply prseql; auto.
      + apply prseqr; apply prseql; auto.
    - apply prseqr; apply prseqr; auto.",0,Proof
before_associative_pairs,"forall r0 r1 s0 s1 x y z,
      same_rel (before (r0, s1) x (before (s0, s1) y z))
               (before (r0, s1) (before (r0, r1) x y) z)",1,Lemma
before_associative_pairs_proof,"intros.
    apply before_associative with (s:=(s0, s1))(r:=(r0,r1)).",0,Proof
ws_exists,"forall es,
      well_structured es ->
      exists e, ev_in e es",1,Lemma
ws_exists_proof,"intros.
    induction H.
    - exists e; auto.
    - destruct IHwell_structured1 as [e].
      exists e; auto.
    - destruct IHwell_structured1 as [e].
      exists e; auto.",0,Proof
before_sup,"forall r x y e,
      sup (before r x y) e -> sup y e",1,Lemma
before_sup_proof,"intros.
    inv H.
    auto.",0,Proof
sup_supreme,"forall es e,
      well_structured es ->
      sup es e <-> supreme es e",1,Lemma
sup_supreme_proof,"unfold supreme; split.
    -  induction H; intros.
       + inv H1.
         split; auto; intros; intro.
         inv H1.
         apply evsys_irreflexive in H2; auto.
       + inv H1.
         inv H3.
         apply IHwell_structured2 in H7.
         destruct H7.
         split.
         * apply ein_beforer; auto.
         * intros; intro.
           inv H4; inv H5.
           -- apply ws_evsys_range in H8; auto.
              apply ws_evsys_range in H12; auto.
              lia.
           -- apply prec_in_left in H11.
              apply ws_evsys_range in H1; auto.
              apply ws_evsys_range in H11; auto.
              lia.
           -- apply prec_in_right in H11.
              apply ws_evsys_range in H8; auto.
              apply ws_evsys_range in H11; auto.
              lia.
           -- apply ws_evsys_range in H1; auto.
              apply ws_evsys_range in H11; auto.
              lia.
           -- apply prec_in_left in H11.
              apply ws_evsys_range in H1; auto.
              apply ws_evsys_range in H11; auto.
              lia.
           -- apply H3 in H8.
              tauto.
       + inv H3.
         * apply IHwell_structured1 in H8.
           destruct H8.
           split.
           -- apply ein_mergel; auto.
           -- intros; intro.
              inv H4; inv H5.
              ++ apply H3 in H8; tauto.
              ++ apply prec_in_right in H11.
                 apply ws_evsys_range in H8; auto.
                 apply ws_evsys_range in H11; auto.
                 lia.
              ++ apply prec_in_right in H11.
                 apply ws_evsys_range in H8; auto.
                 apply ws_evsys_range in H11; auto.
                 lia.
              ++ apply prec_in_left in H11.
                 apply ws_evsys_range in H1; auto.
                 apply ws_evsys_range in H11; auto.
                 lia.
         * apply IHwell_structured2 in H8.
           destruct H8.
           split.
           -- apply ein_merger; auto.
           -- intros; intro.
              inv H4; inv H5.
              ++ apply prec_in_left in H11.
                 apply ws_evsys_range in H1; auto.
                 apply ws_evsys_range in H11; auto.
                 lia.
              ++ apply prec_in_right in H11.
                 apply ws_evsys_range in H8; auto.
                 apply ws_evsys_range in H11; auto.
                 lia.
              ++ apply prec_in_left in H11.
                 apply ws_evsys_range in H1; auto.
                 apply ws_evsys_range in H11; auto.
                 lia.
              ++ apply H3 in H8; tauto.
    - intro; destruct H0.
      induction H; intros.
      + inv H0; auto.
      + inv H0; auto.
        * cut (exists f, ev_in f y).
          -- intros.
             destruct H0 as [f].
             specialize H1 with f.
             assert (G: prec
                          (before (fst (es_range x), snd (es_range y)) x y) e f).
             apply prseq; auto.
             apply H1 in G; auto.
             tauto.
          -- apply ws_exists; auto.
        * apply sup_before.
          apply IHwell_structured2; auto.
          intros; intro.
          assert (G: prec
                       (before (fst (es_range x), snd (es_range y)) x y) e e0).
          apply prseqr; auto.
          apply H1 in G; auto; tauto.
      + inv H0.
        * apply IHwell_structured1 in H7; auto.
          intros; intro.
          assert (G: prec
                       (merge (fst (es_range x), snd (es_range y)) x y) e e0).
          apply prparl; auto.
          apply H1 in G; auto; tauto.
        * apply IHwell_structured2 in H7; auto.
          intros; intro.
          assert (G: prec
                       (merge (fst (es_range x), snd (es_range y)) x y) e e0).
          apply prparr; auto.
          apply H1 in G; auto; tauto.",0,Proof
supreme_max,"forall es,
      well_structured es ->
      supreme es (max es)",1,Lemma
supreme_max_proof,"intros.
    apply sup_supreme; auto.
    induction H; auto.",0,Proof
ES_Range,: Set := nat * nat,2,Definition
es_range,"es :=
    match es with
    | leaf r _ => r
    | before r _ _ => r
    | merge r _ _ => r
    end",2,Definition
same_rel,"es0 es1 :=
    forall ev0 ev1,
      prec es0 ev0 ev1 <-> prec es1 ev0 ev1",2,Definition
supreme,"es e :=
    ev_in e es /\ forall e0, ev_in e0 es -> ~prec es e e0",2,Definition
encodeEvBits,"(e:EvC): BS :=
  match e with
  | (evc bits _) => encodeEvRaw bits
  end",2,Definition
cons_gg,"(sig:BS) (e:EvC) (p:Plc) (ps:ASP_PARAMS): EvC :=
  match e with
  | evc bits et => evc (sig :: bits) (uu p EXTD ps et)
  end",2,Definition
cons_hsh,"(hsh:BS) (e:EvC) (p:Plc) (ps:ASP_PARAMS): EvC :=
  match e with
  | evc _ et => evc [hsh] (uu p COMP ps et)
  end",2,Definition
cons_enc,"(enc:BS) (e:EvC) (p:Plc) (ps:ASP_PARAMS): EvC :=
  match e with
  | evc _ et => evc [enc] (uu p ENCR ps et)
  end",2,Definition
ss_cons,"(e1:EvC) (e2:EvC): EvC :=
  match (e1, e2) with
  | (evc bits1 et1, evc bits2 et2) => evc (bits1 ++ bits2) (ss et1 et2)
  end",2,Definition
term1,:= att 1 (asp SIG),2,Definition
P0,: Plc := 0,2,Definition
P1,: Plc := 1,2,Definition
P2,: Plc := 2,2,Definition
P3,: Plc := 3,2,Definition
P4,: Plc := 4,2,Definition
attest,"(p:Plc) (targ: TARG_ID) :=
  asp (ASPC (asp_paramsC attest_id [] p targ))",2,Definition
appraise,"(p:Plc) (targ: TARG_ID) :=
  asp (ASPC (asp_paramsC appraise_id [] p targ))",2,Definition
certificate,"(p:Plc) (targ: TARG_ID) :=
  asp (ASPC (asp_paramsC cert_id [] p targ))",2,Definition
store,"(p:Plc) (targ: TARG_ID) :=
  asp (ASPC (asp_paramsC cache_id store_args p targ))",2,Definition
retrieve,"(p:Plc) (targ: TARG_ID) :=
  asp (ASPC (asp_paramsC cache_id retrieve_args p targ))",2,Definition
cert_style_simple_sig,": Term :=
  att P1 (lseq
            (attest P1 sys)
            (att 2 (lseq
                      (appraise P2 sys)
                      (asp SIG))))",2,Definition
cert_style,": Term :=
  att P1 (lseq
           (attest P1 sys)
           (att 2 (lseq
                    (appraise P2 sys)
                    (certificate P2 sys))))",2,Definition
cert_cache_p1,": Term :=
  lseq
    (attest P1 sys)
    (lseq
       (att P2
            (lseq
               (appraise P2 sys)
               (certificate P2 sys)))
       (store P1 cache))",2,Definition
cert_cache_p0,": Term :=
  att P1
      (lseq
         (bseq (NONE,ALL)
               (retrieve P1 cache)
               (asp CPY))
         (asp SIG))",2,Definition
bg_check,": Term :=
  lseq
    (att P1 (attest P1 sys))
    (att P2 (appraise P2 sys))",2,Definition
par_mut_p0,": Term :=
  lseq
    (att P1 (attest P1 sys))
    (att P2 (appraise P2 sys))",2,Definition
par_mut_p1,": Term :=
  lseq
    (att P0 (attest P0 sys))
    (att P2 (appraise P2 sys))",2,Definition
layered_bg,"' : Term :=
  lseq
    (attest P1 sys)
    (lseq
       (attest P3 att_tid)
       (attest P4 att_tid))",2,Definition
layered_bg,"'' : Term :=
  bpar (ALL,ALL)
       (att P3 (attest P3 sys))
       (att P4 (attest P4 sys))",2,Definition
layered_bg_weak,": Term :=
  att P1
      (lseq
         (bpar (ALL,ALL)
               layered_bg'
               layered_bg'')
         (att P2
              (lseq
                 (appraise P2 it)
                 (asp SIG))))",2,Definition
layered_bg_strong,": Term :=
    att P1
      (lseq
         (bseq (ALL,ALL) (* only change from layered_bg_weak on this line (bpar --> bseq) *)
               layered_bg'
               layered_bg'')
         (att P2
              (lseq
                 (appraise P2 it)
                 (asp SIG))))",2,Definition
test_par_nested,": Term :=
  bpar (ALL,ALL)
       (asp SIG)
       (bpar (ALL,ALL)
             (asp SIG)
             (asp SIG))",2,Definition
attest_id,: ASP_ID,2,Definition
appraise_id,: ASP_ID,2,Definition
cert_id,: ASP_ID,2,Definition
cache_id,: ASP_ID,2,Definition
store_id,: ASP_ID,2,Definition
retrieve_id,: ASP_ID,2,Definition
store_args,: list Arg,2,Definition
retrieve_args,: list Arg,2,Definition
sys,: TARG_ID,2,Definition
cache,: TARG_ID,2,Definition
att_tid,: TARG_ID,2,Definition
it,: TARG_ID,2,Definition
kim_meas,": Term :=
  <{ << kim_meas_aspid dest_plc kim_meas_targid >> }>",2,Definition
create_and_load_ak,": Term :=
  asp (
      ASPC ALL KEEP
           (asp_paramsC
              cal_ak_aspid cal_ak_args source_plc cal_ak_targid))",2,Definition
pub_key_to_bc,": Term :=
  asp (
      ASPC ALL KEEP
           (asp_paramsC
              pub_bc_aspid pub_bc_args source_plc pub_bc_targid))",2,Definition
get_data,": Term :=
  <{ << get_data_aspid source_plc get_data_targid >> }>",2,Definition
tpm_sig,": Term :=
  <{ << tpm_sig_aspid source_plc tpm_sig_targid >> }>",2,Definition
ssl_enc,": Term :=
  asp (
      ASPC ALL ENCR
           (asp_paramsC
              ssl_enc_aspid ssl_enc_args source_plc ssl_enc_targid))",2,Definition
demo_phrase,": Term :=
  <{ kim_meas ->
     create_and_load_ak ->
     pub_key_to_bc ->
     get_data ->
     tpm_sig ->
     ssl_enc }>",2,Definition
demo_phrase2,": Term :=
  <{ @ demo_plc_2 [kim_meas] }>",2,Definition
demo_phrase3,": Term :=
  <{ @ demo_plc_2 [kim_meas -> @ demo_plc_1 [kim_meas]] }>",2,Definition
ssl_sig,": Term :=
  asp (
      ASPC ALL EXTD (asp_paramsC ssl_sig_aspid ssl_sig_args dest_plc ssl_sig_targid))",2,Definition
client_data_phrase,": Term :=
  asp (
      ASPC ALL KILL (asp_paramsC store_clientData_aspid store_clientData_args source_plc store_clientData_targid))",2,Definition
etsize_mt_sig,":=
  et_size (uu 0 EXTD sig_params mt)",2,Definition
P0,: Plc := 0,2,Definition
P1,: Plc := 1,2,Definition
P2,: Plc := 2,2,Definition
P3,: Plc := 3,2,Definition
P4,: Plc := 4,2,Definition
attest,"(p:Plc) (targ: TARG_ID) :=
  asp (ASPC (asp_paramsC attest_id [] p targ))",2,Definition
appraise,"(p:Plc) (targ: TARG_ID) :=
  asp (ASPC (asp_paramsC appraise_id [] p targ))",2,Definition
certificate,"(p:Plc) (targ: TARG_ID) :=
  asp (ASPC (asp_paramsC cert_id [] p targ))",2,Definition
store,"(p:Plc) (targ: TARG_ID) :=
  asp (ASPC (asp_paramsC cache_id store_args p targ))",2,Definition
retrieve,"(p:Plc) (targ: TARG_ID) :=
  asp (ASPC (asp_paramsC cache_id retrieve_args p targ))",2,Definition
cert_style_simple_sig,": Term :=
  att P1 (lseq
            (attest P1 sys)
            (att 2 (lseq
                      (appraise P2 sys)
                      (asp SIG))))",2,Definition
term1,:= att 1 (asp SIG),2,Definition
source_plc,: Plc := O,2,Definition
target_plc,: Plc := S O,2,Definition
cal_ak_targid,": ASP_ID := """" % string",2,Definition
cal_ak_aspid,": ASP_ID := ""cal_ak_id"" % string",2,Definition
pub_bc_targid,": ASP_ID := """" % string",2,Definition
pub_bc_aspid,": ASP_ID := ""pub_bc_id"" % string",2,Definition
get_data_targid,": ASP_ID := """" % string",2,Definition
get_data_aspid,": ASP_ID := ""get_data_id"" % string",2,Definition
tpm_sig_targid,": ASP_ID := """" % string",2,Definition
tpm_sig_aspid,": ASP_ID := ""tpm_sig_id"" % string",2,Definition
ssl_enc_targid,": ASP_ID := """" % string",2,Definition
ssl_enc_aspid,": ASP_ID := ""ssl_enc_id"" % string",2,Definition
build_cvm_external,"forall (t : Core_Term) (e : EvC) (n : ID_Type) i,
    build_cvm t
                    {| st_ev := e;
                       st_trace := [];
                       st_pl := n;
                       st_evid := i|} =
    (Some tt,
     {| st_ev := cvm_evidence_core t n e;
        st_trace := cvm_events_core t n (get_et e);
        st_pl := n;
        st_evid := (i + event_id_span t)
     |})",1,Lemma
build_cvm_external_proof,"intros.
  assert ([] ++ (cvm_events_core t n (get_et e)) = (cvm_events_core t n (get_et e))) by eauto.
  assert (n = st_pl
            (
              execSt
                (build_cvm t)
                {| st_ev := e;
                     st_trace := [];
                     st_pl := n; st_evid := i |})) as H0'.
  {
    rewrite pl_immut;
    tauto. 
  }
  rewrite H0' at 4.
  eapply build_cvm_external'.",0,Proof
my_extracted,"(t:Term) (st:cvm_st) (et:Evidence) (ls:RawEv) :=
  let res := run_cvm' t st in
  let res' := build_app_comp_evC et ls in
  let res'' := eval t 0 mt in
  (res, res', res'')",2,Definition
my_extracted,"(t:Term) (st:cvm_st) (et:Evidence) (ls:RawEv) :=
  let res := run_cvm' t st in
  let res' := build_app_comp_evC et ls in
  let res'' := eval t 0 mt in
  (res, res', res'')",2,Definition
recon_build_app,"forall e',
    
        reconstruct_evP (evc (encodeEv (build_app_comp_evC e')) (et_fun e')) (build_app_comp_evC e')",1,Lemma
recon_build_app_proof,"Allowed.
*)

Ltac evsub_ih :=
  match goal with
  | [H: EvSub _ ?e,
        IH: context[EvSub _ ?e -> _] |- _] =>
    edestruct IH; [eauto | eauto ]
  end.

Ltac do_ggsub :=
  unfold gg_sub in *;
  destruct_conjs;
  subst.

(*
Lemma recon_build_app : forall e',
    
        reconstruct_evP (evc (encodeEv (build_app_comp_evC e')) (et_fun e')) (build_app_comp_evC e').
Proof.
  intros.
  induction e';
    ff.
  -
    econstructor.
    repeat ff.
    tauto.
  -
    (*
    exists [(checkNonceF n b)]. *)
    econstructor.
    repeat ff.
  -
    invc IHe'.
    (*
    destruct_conjs.
    invc H.
    ff.
    exists ([(checkASPF a b)] ++ IHe'). *)
    econstructor.
    repeat ff.
  -
    (*
    destruct_conjs.
    invc H.
    ff.
    exists ([(checkSigF e' p b)] ++ IHe').
     *)
    invc IHe'.
    
    econstructor.
    repeat ff.
  -
    (*
    exists [(checkHashF e p b)]. *)
    econstructor.
    repeat ff.
  -
    (*
    destruct_conjs.
    invc H0; invc H.
    repeat ff.
    exists (IHe'1 ++ IHe'2). *)
    invc IHe'1; invc IHe'2.
    assert (wf_ec (evc (encodeEv (build_app_comp_evC e'1)) (et_fun e'1))).
    {
      eapply wf_recon.
      econstructor.
      eassumption.
    }
    assert (wf_ec (evc (encodeEv (build_app_comp_evC e'2)) (et_fun e'2))).
    {
      eapply wf_recon.
      econstructor.
      eassumption.
    }
    econstructor.
    repeat ff;
    
    try do_wfec_firstn;
    try do_wfec_skipn;
    try clear_skipn_firstn.
    
    jkjke'.
    jkjke'.
    invc Heqo.
    invc Heqo0.
    tauto.

    jkjke'.
    jkjke'.
    solve_by_inversion.

    rewrite H3 in *.
    rewrite Heqo in *.
    solve_by_inversion.

  -
        invc IHe'1; invc IHe'2.
    assert (wf_ec (evc (encodeEv (build_app_comp_evC e'1)) (et_fun e'1))).
    {
      eapply wf_recon.
      econstructor.
      eassumption.
    }
    assert (wf_ec (evc (encodeEv (build_app_comp_evC e'2)) (et_fun e'2))).
    {
      eapply wf_recon.
      econstructor.
      eassumption.
    }
    econstructor.
    repeat ff;
    
    try do_wfec_firstn;
    try do_wfec_skipn;
    try clear_skipn_firstn.
    
    jkjke'.
    jkjke'.
    invc Heqo.
    invc Heqo0.
    tauto.

    jkjke'.
    jkjke'.
    solve_by_inversion.

    rewrite H3 in *.
    rewrite Heqo in *.
    solve_by_inversion.",0,Proof
uuc_app,"forall e' e'' params p n,
    EvSub (uuc params p n e'') e' ->
    (*reconstruct_evP (evc
                       (encodeEv  (build_app_comp_evC e''))
                       (et_fun (build_app_comp_evC e''))
                    ) e''' -> *)
      EvSub (uuc params p (checkASPF params n) (Impl_appraisal_alt",1,Lemma
uuc_app_proof,"intros.
  generalizeEverythingElse e'.
  induction e'; intros;
    ff.",0,Proof
hhc_app,"forall e' p bs et,
    EvSub (hhc p bs et) e' ->
    EvSub (hhc p (fromSome default_bs (checkHash et p bs)) et)
          (build_app_comp_evC e')",1,Lemma
hhc_app_proof,"intros.
  generalizeEverythingElse e'.
  induction e'; intros;
    ff;
    try evSubFacts;
    eauto.",0,Proof
not_none_alseq_pieces,"forall t1 t2,
    not_none_none (lseq t1 t2) ->
    not_none_none t1 /\ not_none_none t2",1,Lemma
not_none_alseq_pieces_proof,"unfold not_none_none in *;
    unfold not in *.
  split; eauto.",0,Proof
not_none_abseq_pieces,"forall s t1 t2,
    not_none_none (bseq s t1 t2) ->
    not_none_none t1 /\ not_none_none t2",1,Lemma
not_none_abseq_pieces_proof,"unfold not_none_none in *;
    unfold not in *.
  split; eauto.",0,Proof
not_none_abpar_pieces,"forall s t1 t2,
    not_none_none (bpar s t1 t2) ->
    not_none_none t1 /\ not_none_none t2",1,Lemma
not_none_abpar_pieces_proof,"unfold not_none_none in *;
    unfold not in *.
  split; eauto.",0,Proof
not_none_aatt_pieces,"forall q t1,
    not_none_none (att q t1) ->
    not_none_none t1",1,Lemma
not_none_aatt_pieces_proof,"intros;
    unfold not_none_none in *;
    unfold not in *.
  eauto.",0,Proof
not_hshsig_alseq_pieces,"forall t1 t2,
    not_hash_sig_term (lseq t1 t2) ->
    not_hash_sig_term t1 /\ not_hash_sig_term t2",1,Lemma
not_hshsig_alseq_pieces_proof,"intros;
    unfold not_hash_sig_term in *;
    unfold not in *.
  split; eauto.",0,Proof
not_hshsig_abseq_pieces,"forall s t1 t2,
    not_hash_sig_term (bseq s t1 t2) ->
    not_hash_sig_term t1 /\ not_hash_sig_term t2",1,Lemma
not_hshsig_abseq_pieces_proof,"intros;
    unfold not_hash_sig_term in *;
    unfold not in *.
  split; eauto.",0,Proof
not_hshsig_abpar_pieces,"forall s t1 t2,
    not_hash_sig_term (bpar s t1 t2) ->
    not_hash_sig_term t1 /\ not_hash_sig_term t2",1,Lemma
not_hshsig_abpar_pieces_proof,"intros;
    unfold not_hash_sig_term in *;
    unfold not in *.
  split; eauto.",0,Proof
not_hshsig_aatt_pieces,"forall q t1,
    not_hash_sig_term (att q t1) ->
    not_hash_sig_term t1",1,Lemma
not_hshsig_aatt_pieces_proof,"intros;
    unfold not_hash_sig_term in *;
    unfold not in *.
  eauto.",0,Proof
not_none_none_contra_bseq,"forall t1 t2 (P:Prop),
    not_none_none (bseq (NONE, NONE) t1 t2) ->
    P",1,Lemma
not_none_none_contra_bseq_proof,"intros.
  cbv in H.
  exfalso.
  eapply H.
  left.
  repeat eexists.
  eauto.",0,Proof
not_none_none_contra_bpar,"forall t1 t2 (P:Prop),
    not_none_none (bpar (NONE, NONE) t1 t2) ->
    P",1,Lemma
not_none_none_contra_bpar_proof,"intros.
  cbv in H.
  exfalso.
  eapply H.
  right.
  repeat eexists.
  eauto.",0,Proof
evsubt_preserved_eval,"forall t et ett p,
    not_none_none t ->
    EvSubT ett et ->
    EvSubT ett (eval t p et)",1,Lemma
evsubt_preserved_eval_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros; ff;
  try (destruct a; ff; eauto; tauto); (* aasp case *)
    do_not_none;
    try eauto; (* aatt, alseq cases *)
    try (destruct s; destruct s; destruct s0; ff;
         do_none_none_contra). (* abseq, abpar cases  *)",0,Proof
evsubt_preserved,"forall t pt e e' et et' tr tr' p p' ett i i',
    not_none_none t ->
    anno_parP pt t ->
    copland_compileP pt
                     {| st_ev := evc e et; st_trace := tr; st_pl := p; st_evid := i |}
                     (Some tt)
                     {| st_ev := evc e' et'; st_trace := tr'; st_pl := p'; st_evid := i' |} ->
    EvSubT ett et ->
    EvSubT ett et'",1,Lemma
evsubt_preserved_proof,"intros.
  
  assert (et' = eval t p et).
  {
    eapply cvm_refines_lts_evidence; eauto.
  }
  subst.

  eapply evsubt_preserved_eval; eauto.",0,Proof
not_ev,"forall t e,
    not_hash_sig_term_ev t e ->
    not_hash_sig_ev e",1,Lemma
not_ev_proof,"intros; cbv in *.
  destruct_conjs.
  eauto.",0,Proof
etfun_exists,"forall y,
    exists y', y = et_fun y'",1,Lemma
etfun_exists_proof,"intros.
  induction y; intros.
  -
    exists mtc.
    eauto.
  -
    destruct_conjs. 
    exists (uuc a p default_bs IHy).
    ff.
  -
    destruct_conjs.
    exists (ggc p default_bs IHy).
    ff.
  -
    destruct_conjs.
    exists (hhc p default_bs y).
    ff.
  -
    exists (nnc n default_bs).
    ff.
  -
    destruct_conjs.
    exists (ssc IHy1 IHy2).
    ff.
  -
    destruct_conjs.
    exists (ppc IHy1 IHy2).
    ff.",0,Proof
not_hshsig_uuc,"forall e' params p x,
    not_hash_sig_ev e' ->
    not_hash_sig_ev (uuc params p x e')",1,Lemma
not_hshsig_uuc_proof,"cbv in *; intros.
  evSubFacts;
    try (destruct_conjs; solve_by_inversion);
    eauto.",0,Proof
not_hshsig_ggc,"forall e' n bs,
    not_hash_sig_ev e' ->
    not_hash_sig_ev (ggc n bs e')",1,Lemma
not_hshsig_ggc_proof,"cbv in *; intros.
  evSubFacts;
    try (destruct_conjs; solve_by_inversion);
    eauto.",0,Proof
gg_recons,"forall e ecc x y,
    reconstruct_evP ecc e ->
    not_hash_sig_ev e ->
    EvSubT (gg x y) (get_et ecc) ->
    gg_sub e",1,Lemma
gg_recons_proof,"intros e ecc x y H H0 H1.
  generalizeEverythingElse e.
  induction e; intros;
    destruct ecc; ff;
    do_inv_recon;
      try solve_by_inversion;
      do_nhse;
      do_recon_inv.
      
  - (* uuc case *)
    evSubTFacts.
    assert (gg_sub e) by eauto.
    do_ggsub. 
    repeat eexists.
    eauto.
    
  - (* ggc case *)
    econstructor.
    repeat eexists.
    eauto.
    
  - (* ssc case *)
    evSubTFacts.
    +
      assert (gg_sub e1) by eauto.
      do_ggsub.
      repeat eexists.
      eauto.
    +
      assert (gg_sub e2) by eauto.
      do_ggsub.
      repeat eexists.
      eauto.

  - (* ppc case *)
    evSubTFacts.
    +
      assert (gg_sub e1) by eauto.    
      do_ggsub.
      repeat eexists.
      eauto.
    +
      assert (gg_sub e2) by eauto.
      do_ggsub.
      repeat eexists.
      eauto.",0,Proof
recon_evdenote_decomp,"forall a p e,
    exists ecc,
      reconstruct_evP ecc (cvm_evidence_denote a p e)",1,Lemma
recon_evdenote_decomp_proof,"intros.
  generalizeEverythingElse a.
  induction a; intros.
  -
    exists (evc (encodeEv (cvm_evidence_denote (aasp r a) p e)) (et_fun (cvm_evidence_denote (aasp r a) p e))).
    econstructor.
    eapply recon_same.
  -
    edestruct IHa.
    invc H.
    exists x.
    econstructor.
    dd.
    eassumption.
  -
    dd.
    edestruct IHa1 with (p:=p) (e:=e).
    edestruct IHa2 with (p:=p) (e:= (cvm_evidence_denote a1 p e)).
    eexists.
    eassumption.
  -
    dd.
    edestruct IHa1 with (p:=p) (e:= (splitEvl s e)).
    edestruct IHa2 with (p:=p) (e:= (splitEvr s e)).
    eexists.
    econstructor.
    eapply recon_same.
  -
    dd.
    edestruct IHa1 with (p:=p) (e:= (splitEvl s e)).
    edestruct IHa2 with (p:=p) (e:= (splitEvr s e)).
    eexists.
    econstructor.
    eapply recon_same.",0,Proof
recon_evP_ssc_decomp,"forall ecc' a p e e' a0,
    reconstruct_evP ecc'
                    (ssc (cvm_evidence_denote a p e)
                         (cvm_evidence_denote a0 p e')) ->
    (exists ecc, reconstruct_evP ecc (cvm_evidence_denote a p e)) /\
    (exists ecc, reconstruct_evP ecc (cvm_evidence_denote a0 p e'))",1,Lemma
recon_evP_ssc_decomp_proof,"intros.
  destruct ecc'; try solve_by_inversion.
  do_inv_recon_ss.
  invc H.
  repeat ff.
    unfold OptMonad_Coq.bind in *.
    unfold OptMonad_Coq.ret in *.
    repeat ff.
  rewrite fold_recev in *.
  split.
  eexists.
  econstructor.
  symmetry.
  eassumption.
  eexists.
  econstructor.
  symmetry.
  eassumption.",0,Proof
recon_evP_ppc_decomp,"forall ecc' a p e e' a0,
    reconstruct_evP ecc'
                    (ppc (cvm_evidence_denote a p e)
                         (cvm_evidence_denote a0 p e')) ->
    (exists ecc, reconstruct_evP ecc (cvm_evidence_denote a p e)) /\
    (exists ecc, reconstruct_evP ecc (cvm_evidence_denote a0 p e'))",1,Lemma
recon_evP_ppc_decomp_proof,"intros.
  destruct ecc'; try solve_by_inversion.
  do_inv_recon_pp.
  invc H.
  repeat ff.
    unfold OptMonad_Coq.bind in *.
    unfold OptMonad_Coq.ret in *.
    repeat ff.
  rewrite fold_recev in *.
  split.
  eexists.
  econstructor.
  symmetry.
  eassumption.
  eexists.
  econstructor.
  symmetry.
  eassumption.",0,Proof
evAccum,"forall t annt p e e' e'',

    annoP annt t -> 
    not_none_none t ->
    cvm_evidence_denote annt p e = e' -> 
    EvSub e'' e ->

    (
      (EvSub e'' e') \/
      (exists ett p' bs,
          EvSub (hhc p' bs ett) e' /\
          EvSubT (et_fun e'') ett
      )
    )",1,Lemma
evAccum_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros.
  -
    inv_annoP.
    dd.
    destruct a; dd; eauto.
    right.
    repeat eexists.
    econstructor.
    eapply evsub_etfun.
    eassumption.
  - (* aatt case *)
    inv_annoP.
    dd.
    do_not_none.
    edestruct IHt.
    econstructor. repeat eexists. eassumption.
    eassumption.
    reflexivity.
    eassumption.
    eauto.
    eauto.
  - (* alseq case *)
    dd.
    inv_annoP.
    dd.
    repeat do_anno_redo.
    do_not_none.
    edestruct recon_evdenote_decomp with (a:=a) (p:=p) (e:=e).
    destruct x.
    
    do_evsub_ih''. (* IHt1 *)
    
    {
      eapply IHt1; eauto.
      
    }
    
    door.
    ++
      eapply IHt2; eauto.
    ++
      
      assert
        (EvSub (hhc H8 H9 H7) (cvm_evidence_denote a0 p (cvm_evidence_denote a p e)) \/
         (exists (ett : Evidence) p'0 bs,
             EvSub (hhc p'0 bs ett) (cvm_evidence_denote a0 p (cvm_evidence_denote a p e)) /\ EvSubT (et_fun (hhc H8 H9 H7)) ett)).
      {
        eapply IHt2;
          try eassumption;
          try reflexivity.
      }

      door.
      +++
        right.
        repeat (eexists; eauto).
      +++
        
        right.
        repeat (eexists; eauto).
        simpl in *.
        do_hh_sub.
        eapply evsubT_transitive; eauto.
        
  - (* abseq case *)

    inv_annoP.
    dd.
    repeat do_anno_redo.
    do_not_none.

    destruct s; destruct s; destruct s0;
      dd.

    +
      edestruct IHt1; eauto.
      destruct_conjs.
      right.
      repeat eexists; eauto.

    +
      edestruct IHt1; eauto.

      destruct_conjs.
      right.
      repeat eexists; eauto.
    +
      edestruct IHt2; eauto.
      destruct_conjs.
      right.
      repeat eexists; eauto.
    +
      do_none_none_contra.
  - (* abpar case *)

    inv_annoP.
    dd.
    repeat do_anno_redo.
    do_not_none.

    destruct s; destruct s; destruct s0;
      dd.

    +
      edestruct IHt1; eauto.

      destruct_conjs.
      right.
      repeat eexists; eauto.

    +
      edestruct IHt1; eauto.

      destruct_conjs.
      right.
      repeat eexists; eauto.
    +
      edestruct IHt2; eauto.
      destruct_conjs.
      right.
      repeat eexists; eauto.
    +
      do_none_none_contra.",0,Proof
term_sub_lseq_impl,"forall t t1 t2,
  (~ term_sub t (lseq t1 t2)) ->
  (~ term_sub t t1) /\ (~ term_sub t t2)",1,Lemma
term_sub_lseq_impl_proof,auto.,0,Proof
ev_reaches_impl_term_sub,"forall ts t,
  ev_reaches t ts -> term_sub ts t",1,Lemma
ev_reaches_impl_term_sub_proof,crush_ev_reaches_impl.,0,Proof
sig_term_ev_lseq,"forall t1 t2 e,
    not_hash_sig_term_ev (lseq t1 t2) e ->  
    not_hash_sig_term_ev t1 e",1,Lemma
sig_term_ev_lseq_proof,"intros.
  crush_sig_term_ev ev_reaches_lseq.",0,Proof
sig_is,"forall t annt e e' p,

    annoP annt t ->
    cvm_evidence_denote annt p e = e' ->
    gg_sub e' ->
    gg_sub e \/
    term_sub (asp SIG) t",1,Lemma
sig_is_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros; ff.
  -
    dd.
    
    destruct a; inv_annoP; dd; eauto; try tauto.
    +
      do_ggsub.
      evSubFacts.
      left.
      econstructor.
      eauto.
    +
      do_ggsub.
      evSubFacts.
      
  - (* aatt case *)
    inv_annoP.
    dd.
    
    edestruct IHt.
    econstructor. repeat eexists. eassumption.
    reflexivity.
    eassumption.
    eauto.
    eauto.
    
  -
    inv_annoP.
    dd.

    assert (gg_sub (cvm_evidence_denote a p e) \/ term_sub (asp SIG) t2).
    {
      eapply IHt2.
      econstructor. repeat eexists. eassumption.
      reflexivity.
      eassumption.
    }

    door.
    +
      edestruct IHt1.
      econstructor. repeat eexists. eassumption.
      reflexivity.
      eauto.
      eauto.
      eauto.
    +
      eauto.

  - (* abseq case *)
    inv_annoP.
    dd.

    do_ggsub.
    evSubFacts.
    +

      edestruct IHt1.
      econstructor. repeat eexists. eassumption.
      reflexivity.

      repeat eexists.
      eassumption.
      destruct_conjs.
      subst.
      left.
      repeat eexists.
      destruct s; destruct s; destruct s0;
        dd;
        try solve_by_inversion;
        eauto.
      right.
      eauto.
    +
      edestruct IHt2.
      econstructor. repeat eexists. eassumption.
      reflexivity.
      repeat eexists.
      eassumption.
      destruct_conjs.
      subst.
      left.
      repeat eexists.
      destruct s; destruct s; destruct s0;
        dd;
        try solve_by_inversion;
        eauto.
      right.
      eauto.
  - (* abseq case *)
    inv_annoP.
    dd.

    do_ggsub.
    evSubFacts.
    +

      edestruct IHt1.
      econstructor. repeat eexists. eassumption.
      reflexivity.
      repeat eexists.
      eassumption.
      destruct_conjs.
      subst.
      left.
      repeat eexists.
      destruct s; destruct s; destruct s0;
        dd;
        try solve_by_inversion;
        eauto.
      right.
      eauto.
    +
      edestruct IHt2.
      econstructor. repeat eexists. eassumption.
      reflexivity.
      

      repeat eexists.
      eassumption.
      destruct_conjs; subst.
      left. repeat eexists.
      destruct s; destruct s; destruct s0;
        dd;
        try solve_by_inversion;
        eauto.
      right.
      eauto.",0,Proof
term_sub_bseq_impl,"forall t s t1 t2,
  (~ term_sub t (bseq s t1 t2)) ->
  (~ term_sub t t1) /\ (~ term_sub t t2)",1,Lemma
term_sub_bseq_impl_proof,auto.,0,Proof
sig_term_ev_bseql,"forall s (t1 t2 : Term)
                           (e : EvidenceC),
    not_hash_sig_term_ev (bseq s t1 t2) e ->
    
    not_hash_sig_term_ev t1 (splitEvl s e)",1,Lemma
sig_term_ev_bseql_proof,"intros.
  destruct s eqn:E. destruct s0; destruct s1.
  - crush_sig_term_ev ev_reaches_bseq_aa.
  - crush_sig_term_ev ev_reaches_bseq_an.
  - crush_sig_term_ev ev_reaches_bseq_na.
  - crush_sig_term_ev ev_reaches_bseq_na.",0,Proof
sig_term_ev_bseqr,"forall s (t1 t2 : Term)
                           (e : EvidenceC),
    
    not_hash_sig_term_ev (bseq s t1 t2) e ->   
    not_hash_sig_term_ev t2 (splitEvr s e)",1,Lemma
sig_term_ev_bseqr_proof,"intros.
  destruct s eqn:E. destruct s0; destruct s1.
  - crush_sig_term_ev ev_reaches_bseq_aa.
  - crush_sig_term_ev ev_reaches_bseq_an.
  - crush_sig_term_ev ev_reaches_bseq_na.
  - crush_sig_term_ev ev_reaches_bseq_na. 
  (* in contradiction case, constructor passed does not really matter *)",0,Proof
term_sub_bpar_impl,"forall t s t1 t2,
  (~ term_sub t (bpar s t1 t2)) ->
  (~ term_sub t t1) /\ (~ term_sub t t2)",1,Lemma
term_sub_bpar_impl_proof,auto.,0,Proof
sig_term_ev_bparl,"forall s (t1 t2 : Term)
                           (e : EvidenceC),
    
    not_hash_sig_term_ev (bpar s t1 t2) e ->
    not_hash_sig_term_ev t1 (splitEvl s e)",1,Lemma
sig_term_ev_bparl_proof,"intros.
  destruct s eqn:E. destruct s0; destruct s1.
  - crush_sig_term_ev ev_reaches_bpar_aa.
  - crush_sig_term_ev ev_reaches_bpar_an.
  - crush_sig_term_ev ev_reaches_bpar_na.
  - crush_sig_term_ev ev_reaches_bpar_na. 
  (* in contradiction case, constructor passed does not really matter *)",0,Proof
sig_term_ev_bparr,"forall s (t1 t2 : Term)
                           (e : EvidenceC),
    
    not_hash_sig_term_ev (bpar s t1 t2) e ->
    not_hash_sig_term_ev t2 (splitEvr s e)",1,Lemma
sig_term_ev_bparr_proof,"intros.
  destruct s eqn:E. destruct s0; destruct s1.
  - crush_sig_term_ev ev_reaches_bpar_aa.
  - crush_sig_term_ev ev_reaches_bpar_an.
  - crush_sig_term_ev ev_reaches_bpar_na.
  - crush_sig_term_ev ev_reaches_bpar_na. 
  (* in contradiction case, constructor passed does not really matter *)",0,Proof
term_sub_att_impl,"forall t t1 p,
  (~ term_sub t (att p t1)) ->
  (~ term_sub t t1)",1,Lemma
term_sub_att_impl_proof,auto.,0,Proof
not_hste_att,"forall t e n,
    not_hash_sig_term_ev (att n t) e ->
    not_hash_sig_term_ev t e",1,Lemma
not_hste_att_proof,"intros.
  crush_sig_term_ev ev_reaches_att.",0,Proof
nhst_lseq_r,"forall t1 t2 e,
    not_hash_sig_term_ev (lseq t1 t2) e ->
    not_hash_sig_term t2",1,Lemma
nhst_lseq_r_proof,"intros.
  unfold not_hash_sig_term_ev in *.
  destruct_conjs.
  unfold not_hash_sig_term in *.
  cbv.
  unfold not in *.
  intros.
  destruct_conjs.
  eapply H. (*with (t':= (alseq (n, n0) H4 H2)). *)
  econstructor.
  repeat eexists.
  eassumption.
  eassumption.
  subst.
  eauto.",0,Proof
hshsig_ev_term_contra,"forall t annt p e e',

    annoP annt t ->
    not_hash_sig_term_ev t e ->
    cvm_evidence_denote annt p e = e' ->
    not_hash_sig_ev e'",1,Lemma
hshsig_ev_term_contra_proof,"intros.
  generalizeEverythingElse e.
  induction e; intros; ff.
  -
    invc H0.
    do_nhse.
    
    assert (gg_sub e).
    eapply IHe.
    eassumption.
    eassumption.
    
    
    do_ggsub.
    repeat eexists.
    eauto.
  -
    do_ggsub.
    repeat eexists.
    eauto.
  -
    invc H0.
    unfold not_hash_sig_ev in *.
    unfold not in *.
    exfalso.
    eapply H.
    econstructor.
    repeat eexists.
    eassumption.
    econstructor.
  -
    invc H0.
    +
      do_nhse.
      assert (gg_sub e1) by eauto.
      
      do_ggsub.
      repeat eexists.
      eauto.
    +
      do_nhse.
      assert (gg_sub e2) by eauto.
      
      do_ggsub.
      repeat eexists.
      eauto.
  -
    invc H0.
    +
      do_nhse.
      assert (gg_sub e1) by eauto.
      
      do_ggsub.
      repeat eexists.
      eauto.
    +
      do_nhse.
      assert (gg_sub e2) by eauto.
      
      do_ggsub.
      repeat eexists.
      eauto.",0,Proof
sig_term_ev_lseqr,"forall t1 t2 annt e e' p,
    annoP annt t1 ->
    not_hash_sig_term_ev (lseq t1 t2) e ->
    cvm_evidence_denote annt p e = e' ->  
    not_hash_sig_term_ev t2 e'",1,Lemma
sig_term_ev_lseqr_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros.
  -
    inv_annoP.
    dd.
    destruct a; dd.
    +
    unfold not_hash_sig_term_ev in *.
    destruct_conjs.
    eassumption.
    +
    unfold cons_uu in *.
    repeat ff.
    unfold not_hash_sig_term_ev in *;
      destruct_conjs.

    eapply not_hshsig_uuc; eauto.
    +
    repeat ff.
    unfold not_hash_sig_term_ev in *;
      destruct_conjs.
    unfold cons_sig in *.
    ff.
      
    eapply not_hshsig_ggc; eauto.
    +
      assert (~ (gg_sub e)).
      {
        unfold not_hash_sig_term_ev in *.
        destruct_conjs.
        unfold not in *; intros.
        apply H3.
        eassumption.
        eauto.
        constructor. reflexivity.
      }
      unfold not_hash_sig_term_ev in *.
      destruct_conjs.
      
      unfold not_hash_sig_ev.
      intros.
      unfold not in *; intros.
      invc H5.
      unfold hash_sig_ev in *.
      destruct_conjs.
      invc H6.
      invc H13.
      apply H1.

      eapply gg_recons''; eauto.

  - (* aatt case *)

    inv_annoP.
    dd.
    
    do_nhste_att.
     
    eapply IHt.
    econstructor. repeat eexists. eassumption.
    eassumption.
    reflexivity.
        
  - (* alseq case *)

    inv_annoP.
    dd.
    repeat do_anno_redo.
        
    do_nhste_lseql.
    
    assert (not_hash_sig_ev (cvm_evidence_denote a p e)) by eauto.

    do_nhst_lseqr.

    eapply IHt2.
    eassumption.
      
    2: { reflexivity. }
    split.
    eassumption.
    split.
    eassumption.
    intros.
    unfold not.
    intros.

    do_sig_is e.
    
    door.
    ++ 

      unfold not_hash_sig_term_ev in H0.
      destruct_conjs.
      apply H10 in H8.
      apply H8.
      eapply ev_reaches_lseq.
      reflexivity.
      right. assumption.
    ++ 
      unfold not_hash_sig_term_ev in *.
        destruct_conjs.
        unfold not_hash_sig_term in *.
        unfold not in *.
        eapply H0. (*with (t':= (alseq r t1 t2)). *)
                
        econstructor.
        repeat eexists.
        eassumption.
        
        eassumption.
        eauto.
    
  - (* abseq case *)


    inv_annoP.
    dd.
    repeat do_anno_redo.
        
    unfold not_hash_sig_ev.
    intros.
    unfold not.
    intros.
        
    do_nhste_bseql.
    do_nhste_bseqr.
    
    evSubFacts.

    +
      invc H1.
      
      destruct_conjs.
      solve_by_inversion.
    +
      assert (not_hash_sig_ev (cvm_evidence_denote a p (splitEvl s e))).
      {
        eapply IHt1.
        eassumption.
        eassumption.
        reflexivity.
      }

      eapply H3; eassumption.

    +
      assert (not_hash_sig_ev (cvm_evidence_denote a0 p (splitEvr s e))) by eauto.
      eapply H3; eassumption.
  - (* bpar case *)
    
    inv_annoP.
    dd.
    repeat do_anno_redo.
       
    unfold not_hash_sig_ev.
    intros.
    unfold not.
    intros.
        
    do_nhste_bparl.
    do_nhste_bparr.
    
    evSubFacts.

    +
      invc H1.
      destruct_conjs.
      solve_by_inversion.
    +
      assert (not_hash_sig_ev (cvm_evidence_denote a p (splitEvl s e))).
      {
        eapply IHt1.
        eassumption.
        eassumption.
        reflexivity.
      }

      eapply H3; eassumption.

    +
      assert (not_hash_sig_ev (cvm_evidence_denote a0 p (splitEvr s e))) by eauto.
      eapply H3; eassumption.",0,Proof
uu_preserved,"forall t1 t2 annt p n p0 e e''' e' params et,
    annoP annt t1 ->
    not_none_none t1 ->
    not_none_none t2 ->
    events annt p (et_fun e) (umeas n p0 params et) ->
    cvm_evidence_denote annt p e = e''' ->
    cvm_evidence_denote annt p e''' = e' ->
    
    (
      (exists bits'' e'',
          (reconstruct_evP (evc bits'' et) e'' /\
           EvSub (uuc params p0 (do_asp params bits'' p0 n) e'') e')) \/
      (exists ett p' bs et',
          EvSub (hhc p' bs ett) e' /\
          EvSubT (uu params p0 et') ett)
    )",1,Lemma
uu_preserved_proof,"intros.
  
  do_nhste_lseql.
  do_nhst_lseqr.

  split; try eassumption.

  do_hste_contra e'.

  -
    split; try eassumption.
    +
      intros.
      unfold not; intros.

      do_sig_is e.
      door.

      ++
        unfold not_hash_sig_term_ev in H0.
        destruct_conjs.
        concludes.
        unfold not in *.
        do_hsh_subt.
        forwards;
          eauto.
          eapply ev_reaches_lseq.
          reflexivity.
          right. assumption.
      ++
        unfold not_hash_sig_term_ev in H0.
        destruct_conjs.
        unfold not_hash_sig_term in H0.
        unfold not in *.
        do_hsh_subt.
        eapply H0; eauto.
        econstructor.
        repeat eexists.
        eauto.
        eauto.",0,Proof
nhse_bseql_nosplit,"forall t1 t2 annt s p e e',
    annoP annt t1 ->
    not_hash_sig_term_ev (bseq s t1 t2) e ->
    cvm_evidence_denote annt p (splitEvl s e) = e' ->
    not_hash_sig_ev e'",1,Lemma
nhse_bseql_nosplit_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros.
  -
    inv_annoP.
    dd.

        
    destruct a; ff.
    +
      invEvents.

      unfold cons_uu in *.
      repeat ff.
      left.
      exists (encodeEv e).
      eexists.
      split.
      econstructor.
      eapply recon_same.
      econstructor.
  -
    inv_annoP.
    dd.

    do_anno_redo.
       
    inv_events.

    do_not_none.
    inv_annoP.

    do_assume_remote t (evc (encodeEv e) (et_fun e)) n (S H4) HHH.
    do_annopar_redo.

    eapply IHt;
      try eassumption;
      try reflexivity.  
  -
    inv_annoP.
    dd.
    repeat do_anno_redo.
    
    do_not_none.

    invEvents.
    + (* t1 case *)

      edestruct IHt1.
      eassumption.
      eassumption.
      eassumption.
      reflexivity.

      destruct_conjs.

      do_evaccum (cvm_evidence_denote a0 p (cvm_evidence_denote a p e)).
      door.

      ++
        left.
        eauto.
        
      ++
        assert (et = et_fun H6).
        {
          eapply etfun_reconstruct.
          eassumption.
        }
        subst.

        right.
        repeat (eexists; eauto).
      ++
        destruct_conjs.

        do_evaccum (cvm_evidence_denote a0 p (cvm_evidence_denote a p e)).
        door.
        +++
          right.
          repeat (eexists; eauto).
        +++
          
          destruct_conjs.
          right.
          repeat eexists.
          eauto.

          eapply evsubT_transitive.
          eapply hhSubT.
          eassumption.
          eassumption.
          
    + (* t2 case *)

      assert (et_fun (cvm_evidence_denote a p e) = (aeval a p (et_fun e))).
      {
        eapply cvm_ev_denote_evtype.
      }
        
      edestruct IHt2.
      eassumption.
      eassumption.
      rewrite H1.
      eassumption.
      reflexivity.

      destruct_conjs.

      ++
        eapply IHt2.
        eassumption.
        eassumption.
        rewrite H1.
        eassumption.
        reflexivity.
      ++
        destruct_conjs;
          right;
          repeat (eexists; eauto).

  - (* abseq case *)

    inv_annoP.
    dd.
    repeat do_anno_redo.
    do_not_none.

    invEvents.
    +
      destruct s; destruct s; destruct s0; dd.
      ++
        edestruct IHt1.
        eassumption.
        eassumption.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H6.
          eassumption.

          eauto.
          (*
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)). *)
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        edestruct IHt1.
        eassumption.
        eassumption.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H6. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        assert (mt = et_fun mtc) by tauto.
        edestruct IHt1.
        eassumption.
        eassumption.
        rewrite <- H1.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H7. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
          
      ++
        exfalso.
        eapply not_none_none_contra_bseq; eauto.
    +
      destruct s; destruct s; destruct s0; dd.
      ++
        edestruct IHt2.
        eassumption.
        eassumption.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H6. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        assert (mt = et_fun mtc) by tauto.
        edestruct IHt2.
        eassumption.
        eassumption.
        rewrite <- H1.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H7. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        edestruct IHt2.
        eassumption.
        eassumption.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H6. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        exfalso.
        eapply not_none_none_contra_bseq; eauto.

  - (* new abpar case *)

    inv_annoP.
    dd.
    repeat do_anno_redo.
  
    do_not_none.

    invEvents.

    +
      destruct s; destruct s; destruct s0; dd.
      ++
        edestruct IHt1.
        eassumption.
        eassumption.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H6. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        edestruct IHt1.
        eassumption.
        eassumption.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H6. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        assert (mt = et_fun mtc) by tauto.
        edestruct IHt1.
        eassumption.
        eassumption.
        rewrite <- H1.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H7. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        exfalso.
        eapply not_none_none_contra_bpar; eauto.
    + (* t2 case *)
      destruct s; destruct s; destruct s0; dd.
      ++
        edestruct IHt2.
        eassumption.
        eassumption.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H6. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        assert (mt = et_fun mtc) by tauto.
        edestruct IHt2.
        eassumption.
        eassumption.
        rewrite <- H1.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H7. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        edestruct IHt2.
        eassumption.
        eassumption.
        eassumption.
        reflexivity.
        destruct_conjs.
        +++
          left.
          repeat eexists.
          invc H6. eassumption.
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
        +++
          try eauto;
          try (destruct_conjs;
               right;
               repeat (eexists; eauto)).
      ++
        exfalso.
        eapply not_none_none_contra_bpar; eauto.",0,Proof
nhse_bseqr_nosplit,"forall t1 t2 annt s p e e',
    annoP annt t2 ->
    not_hash_sig_term_ev (bseq s t1 t2) e ->
    cvm_evidence_denote annt p (splitEvr s e) = e' ->
    not_hash_sig_ev e'",1,Lemma
nhse_bseqr_nosplit_proof,"intros.
  
  assert (
      (exists bits'' e'',
          (reconstruct_evP (evc bits'' et) e'' /\
           EvSub (uuc params p0 (do_asp params bits'' p0 n) e'') e''')) \/
      (exists ett p' bs,
          EvSub (hhc p' bs ett) e''' /\
          EvSubT (uu params p0 et) ett)
    ).
  {
    eapply uu_preserved'.
    apply H.
    eassumption.
    eassumption.
    tauto.
  }
  rewrite <- H3 in *; clear H3.
  door.
  +
    do_evaccum (cvm_evidence_denote annt p (cvm_evidence_denote annt p e)).
    clear H7.
  
    door.
    ++
      
      left.
      eexists.
      jkjke'.
    ++
      
      

    right;
      (repeat eexists; eauto).
    jkjke'.
  +
    do_evaccum (cvm_evidence_denote annt p (cvm_evidence_denote annt p e)).
    door.
    ++
      right.
      repeat (eexists; eauto).
      jkjke'.
    ++
      assert (EvSubT (uu params p0 et) H9).
      {
        eapply evsubT_transitive.
        apply hhSubT.
        eassumption.
        eassumption.
      }
      
      right; 
        repeat (eexists; eauto).
      jkjke'.",0,Proof
nhse_bparl_nosplit,"forall t1 t2 annt s p e e',
    annoP annt t1 ->
    not_hash_sig_term_ev (bpar s t1 t2) e ->
    cvm_evidence_denote annt p (splitEvl s e) = e' ->
    not_hash_sig_ev e'",1,Lemma
nhse_bparl_nosplit_proof,"intros.
  eapply hshsig_ev_term_contra.
  eassumption.
  eapply sig_term_ev_bseql.
  eassumption.
  destruct s; destruct s; destruct s0; ff.",0,Proof
nhse_bparr_nosplit,"forall t1 t2 annt s p e e',
    annoP annt t2 ->
    not_hash_sig_term_ev (bpar s t1 t2) e ->
    cvm_evidence_denote annt p (splitEvr s e) = e' ->
    not_hash_sig_ev e'",1,Lemma
nhse_bparr_nosplit_proof,"intros.
  eapply hshsig_ev_term_contra.
  eassumption.
  eapply sig_term_ev_bseqr.
  eassumption.
  destruct s; destruct s; destruct s0; ff.",0,Proof
pl_immut,"forall t e tr p i,
    st_pl
      (execSt
         (build_cvm t)
         {|
           st_ev := e;
           st_trace := tr;
           st_pl := p;
           st_evid := i|}) = p",1,Lemma
pl_immut_proof,"Allowed.
*)

(* Lemma stating the CVM st_pl parameter ends up where it started execution *)
Lemma pl_immut : forall t e tr p i,
    st_pl
      (execSt
         (build_cvm t)
         {|
           st_ev := e;
           st_trace := tr;
           st_pl := p;
           st_evid := i|}) = p.
Proof.
  induction t; intros.
  -
    destruct a; (* asp *)
      try destruct a; (* asp params *)    
      try reflexivity.
  -
    df.
    reflexivity.
  -
    simpl in *.
    monad_unfold.
    repeat break_match;
      try solve_by_inversion.
    df.
    annogo.
    simpl.  
    assert (p = st_pl0).
    {
      edestruct IHt1.
      jkjke.
    }
    assert (st_pl0 = st_pl).
    {
      edestruct IHt2.
      jkjk_s.
    }
    congruence.
  -
    (*
    do_wf_pieces. *)
    annogo.
    df.
    
    repeat break_match;
      try solve_by_inversion;
    repeat find_inversion;
    repeat dunit;
    simpl in *; vmsts; simpl in *.
    +
    assert (p = st_pl0).
    {
      edestruct IHt1.
      jkjk_s; eauto.     
    }

    assert (st_pl0 = st_pl).
    {     
      edestruct IHt2.
      jkjk_s; eauto.
    }

    congruence.
    +
      assert (p = st_pl).
      {
        edestruct IHt1.
        jkjk_s; eauto.
      }

      assert (st_pl = st_pl0).
      {
        edestruct IHt2.
        jkjk_s; eauto.
      }

      congruence.
    +
      symmetry.
      edestruct IHt1.
      jkjk_s; eauto.
    +
      symmetry.
      edestruct IHt1.
      jkjk_s; eauto.

  -
    annogo.
    df.

    repeat break_let.

    repeat break_match;
      try solve_by_inversion;
    repeat find_inversion;
    repeat dunit;
    simpl in * ; vmsts; simpl in *.
    +
    assert (p = st_pl).
    {
      edestruct IHt1.
      jkjke. 
    }
    congruence.   

    +
    assert (p = st_pl).
    {
      edestruct IHt1.
      jkjke.    
    }
    congruence.",0,Proof
st_congr,"forall st tr e p i,
    st_ev st = e ->
    st_trace st = tr ->
    st_pl st = p ->
    st_evid st = i ->
    st =  {| st_ev := e; st_trace := tr; st_pl := p; st_evid := i |}",1,Lemma
st_congr_proof,"intros.
  subst; destruct st; auto.",0,Proof
st_trace_irrel,"forall t e e' e'' x x' y y' p p' p'' i i' i'',
    build_cvm t {| st_ev := e; st_trace := x; st_pl := p; st_evid := i |} =
    (Some tt, {| st_ev := e'; st_trace := x'; st_pl := p'; st_evid := i' |}) ->
    build_cvm t {| st_ev := e; st_trace := y; st_pl := p; st_evid := i |} =
    (Some tt, {| st_ev := e''; st_trace := y'; st_pl := p''; st_evid := i'' |}) ->
    (e' = e'' /\ p' = p'' /\ i' = i'')",1,Lemma
st_trace_irrel_proof,"induction t; intros.
  - destruct a; (* asp *)
      try destruct a; (* asp params *)
      df; eauto.
  -
    repeat (df; try dohtac; df).
    tauto.
  -
    df;
    repeat break_match;
    try (repeat find_inversion);
    simpl in *.
    df.
    anhl.
    eauto. 
  -
    df;
    repeat break_match;
    try (repeat find_inversion);
    simpl in *.
    df.
    repeat anhl.
    repeat find_inversion.
    eauto.
  -
    cbn in *.
    monad_unfold.
    repeat break_let.
    simpl in *.

    dosome.
    df.
    dosome.
    dosome.
    df.

    annogo.
    simpl in *.

    repeat anhl.
    repeat (find_inversion).
    repeat find_rewrite.
    df.
    tauto.",0,Proof
trace_irrel_pl,"forall t tr1 tr1' tr2 e e' p1' p1 i i',
    build_cvm t
           {| st_ev := e; st_trace := tr1; st_pl := p1; st_evid := i |} =
    (Some tt, {| st_ev := e'; st_trace := tr1'; st_pl := p1'; st_evid := i' |}) ->
    
    st_pl
      (execSt (build_cvm t)
           {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) = p1'",1,Lemma
trace_irrel_pl_proof,"intros.
  destruct (build_cvm t {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) eqn:ff.
  simpl.
  vmsts.
  simpl.
  do_asome.
  subst.
  dohi.
  df.
  tauto.",0,Proof
trace_irrel_ev,"forall t tr1 tr1' tr2 e e' p1' p1 i i',
    build_cvm t
           {| st_ev := e; st_trace := tr1; st_pl := p1; st_evid := i|} =
    (Some tt, {| st_ev := e'; st_trace := tr1'; st_pl := p1'; st_evid := i' |}) ->
    
    st_ev
      (execSt (build_cvm t)
           {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) = e'",1,Lemma
trace_irrel_ev_proof,"intros.
  destruct (build_cvm t {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) eqn:ff.
  simpl.
  vmsts.
  simpl.
  do_asome.
  subst.
  dohi.
  df.
  tauto.",0,Proof
trace_irrel_evid,"forall t tr1 tr1' tr2 e e' p1' p1 i i',
    build_cvm t
           {| st_ev := e; st_trace := tr1; st_pl := p1; st_evid := i|} =
    (Some tt, {| st_ev := e'; st_trace := tr1'; st_pl := p1'; st_evid := i' |}) ->
    
    st_evid
      (execSt (build_cvm t)
           {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) = i'",1,Lemma
trace_irrel_evid_proof,"intros.
  destruct (build_cvm t {| st_ev := e; st_trace := tr2; st_pl := p1; st_evid := i |}) eqn:ff.
  simpl.
  vmsts.
  simpl.
  do_asome.
  subst.
  dohi.
  df.
  tauto.",0,Proof
ccp_implies_cc,"forall t st st' res,
  build_cvmP t st res st' ->
  build_cvm t st = (res,st')",1,Lemma
ccp_implies_cc_proof,"intros.
  solve_by_inversion.",0,Proof
cc_implies_ccp,"forall t st st' res,
  build_cvm t st = (res,st') -> 
  build_cvmP t st res st'",1,Lemma
cc_implies_ccp_proof,"intros.
  econstructor.
  tauto.",0,Proof
ccp_iff_cc,"forall t st st' res,
  build_cvm t st = (res,st') <-> 
  build_cvmP t st res st'",1,Lemma
ccp_iff_cc_proof,"intros.
  split; intros;
    try (eapply cc_implies_ccp; eauto);
    try (eapply ccp_implies_cc; eauto).",0,Proof
term_to_coreP_redo,"forall t t',
    copland_compile t = t' ->
    term_to_coreP t t'",1,Lemma
term_to_coreP_redo_proof,"intros.
  econstructor.
  eauto.",0,Proof
annoP_redo,"forall t annt n n',
    anno t n = (n', annt) ->
    annoP annt t",1,Lemma
annoP_redo_proof,"intros.
  econstructor.
  eexists.
  jkjke.",0,Proof
annoP_indexed_redo,"forall t annt n n',
    anno t n = (n', annt) ->
    annoP_indexed annt t n n'",1,Lemma
annoP_indexed_redo_proof,"intros.
  econstructor.
  jkjke.",0,Proof
ba_const,"forall e et a_st a_st' o,
    build_app_comp_ev e et a_st = (o, a_st') ->
    am_nonceMap a_st = am_nonceMap a_st' /\
    am_nonceId a_st = am_nonceId a_st' /\
    st_aspmap a_st = st_aspmap a_st' /\
    st_sigmap a_st = st_sigmap a_st' /\
    st_hshmap a_st = st_hshmap a_st'",1,Lemma
ba_const_proof,"Allowed.

Ltac amsts' :=
  repeat match goal with
         | H:AM_St |- _ => destruct H
         end.

Lemma ba_const : forall e et a_st a_st' o,
    build_app_comp_ev e et a_st = (o, a_st') ->
    am_nonceMap a_st = am_nonceMap a_st' /\
    am_nonceId a_st = am_nonceId a_st' /\
    st_aspmap a_st = st_aspmap a_st' /\
    st_sigmap a_st = st_sigmap a_st' /\
    st_hshmap a_st = st_hshmap a_st'.

                               (*/\
    checked a_st = checked a_st'. *)
Proof.
  intros.
  generalizeEverythingElse e.
  induction e; intros;
    
    repeat ff;
    try eauto;
    try (unfold am_add_trace in * );
    try (unfold am_checkNonce in * );
    repeat ff; eauto;

      try (edestruct IHe; eauto; tauto);

      try (
          amsts'; ff;
          edestruct IHe1; eauto;
          ff;
          edestruct IHe2; eauto;
          ff; destruct_conjs; ff
        ).",0,Proof
hshMapped_relevant,"forall a_st a e,
    (*
    am_nonceMap a_st = am_nonceMap a /\
    (*am_nonceId a_st = am_nonceId a /\ *)
    st_aspmap a_st = st_aspmap a /\
    st_sigmap a_st = st_sigmap a /\ *)
    st_hshmap a_st = st_hshmap a ->
    hshMapped e a ->
    hshMapped e a_st",1,Lemma
hshMapped_relevant_proof,"intros.
  generalizeEverythingElse e.
  induction e; intros;
    try (econstructor; tauto);
    try (
        hshMappedFacts;
        repeat (econstructor; eauto); subst'; eauto).",0,Proof
evmapped_relevant,"forall a_st a e,
    am_nonceMap a_st = am_nonceMap a /\
    (*am_nonceId a_st = am_nonceId a /\ *)
    st_aspmap a_st = st_aspmap a /\
    st_sigmap a_st = st_sigmap a /\
    st_hshmap a_st = st_hshmap a ->
    evMapped e a ->
    evMapped e a_st",1,Lemma
evmapped_relevant_proof,"intros.
  generalizeEverythingElse e.
  induction e; intros;
    try (econstructor; tauto);
    try (
        evMappedFacts;
        repeat (econstructor; eauto); subst'; eauto).

  (*
  - (* hsh case *)
    econstructor.
    evMappedFacts.
    amsts'.
    df.
    repeat subst'.
    eapply hshMapped_relevant.
    2: {
      eassumption.
    }
    ff. *)",0,Proof
build_app_some,"forall e et a_st,
    evMapped et a_st ->
    Ev_Shape e et ->
    exists o a_st', build_app_comp_ev e et a_st = (Some o, a_st')",1,Lemma
build_app_some_proof,"induction e; intros;
    try (
        repeat ff;
        destruct_conjs;
        try solve_by_inversion;
        try (repeat (econstructor; eauto); tauto)
      ).
  - (* hh case *)
    invc H0.
    admit.

    (*
  -
    invc H0.
    unfold am_checkNonce in *.
    repeat ff.

    do_ba_st_const.
    destruct_conjs; subst.
    rewrite <- H in *.
    
   
    
    econstructor.
    tauto.
    eauto.
    eexists.
    econstructor.
    admit.
    admit.
  -
    *)
    
    

(*
  - (* hhc case *)
    repeat ff.
    amsts'.
    df.
    econstructor.

    HEREEEE


    
    admit.
*)
  - (* nnc case *)
    repeat ff.
    +
      destruct_conjs.
      ff.
      econstructor.
      ++
        tauto.
      ++    
        eauto.
      ++
        unfold am_checkNonce in *.
        repeat ff.
        +++
        eexists.
        econstructor.
        do_ba_st_const.
        destruct_conjs.
        subst'.
        admit.
        +++
          eexists.
          econstructor.
          do_ba_st_const.
          destruct_conjs.
          subst'.
          admit.
  -
    repeat ff; 
      destruct_conjs;
      ff.

    do_ba_st_const.
    destruct_conjs.
    subst.
    
      econstructor.
      +
        eauto.
      +
        assert (evMapped e4 a) by eauto.
        
        destruct_conjs.

        eapply evmapped_relevant.
        split; eauto.
        eassumption.

  -
    repeat ff; 
      destruct_conjs;
      ff.

    do_ba_st_const.
    
      econstructor.
      +
        eauto.
      +
        assert (evMapped e4 a) by eauto.
        
        destruct_conjs.

        eapply evmapped_relevant.
        split; eauto.
        eassumption.
        Unshelve.
        tauto.
        tauto.",0,Proof
same_ev_shape,"forall e et a_st a_st' ec_res,
    Ev_Shape e et -> 
    build_app_comp_ev e et a_st = (Some ec_res, a_st') ->
    Ev_Shape ec_res et",1,Lemma
same_ev_shape_proof,"intros.
  generalizeEverythingElse e.
  induction e; intros.
  -
    repeat ff; eauto.
  -
    evShapeFacts.
    
    evMappedFacts.
    ff.
    dosomeee.
    eauto.
  -
    evShapeFacts.
    evMappedFacts.
    ff.
    dosomeee.
    eauto.
  -
    evShapeFacts.
    evMappedFacts.
    ff.
    eauto.
  -
    cbn.
    evShapeFacts.
    evMappedFacts.
    df.
    unfold am_checkNonce in *.
    do_ba_st_const.
    destruct_conjs.
    subst'.
    monad_unfold.
    unfold getNonceVal in *.
    monad_unfold.
    break_let.
    dosome.
    edestruct IHe.
    eassumption.
    eassumption.
    destruct_conjs.
    subst'.
    invc H8.
    eauto.
    destruct o1.
    +
      break_let.
      break_let.
      break_let.
      rewrite H0 in *.
      invc Heqp3.
      invc Heqp1.
      destruct (PeanoNat.Nat.eq_dec n0 n1).
      ++
        invc Heqp2.
        invc Heqp.
        invc Heqp0.
        eauto.
      ++
        invc Heqp2.
        invc Heqp.
        invc Heqp0.
        eauto.
    +
      repeat break_let.
      rewrite H0 in *.
      invc Heqp.
      invc Heqp1.


  -
    cbn.
    evShapeFacts.
    evMappedFacts.
    
    assert (exists o a_st', build_app_comp_ev e1 e1t a_st = (Some o, a_st')) by eauto.
    assert (exists o a_st', build_app_comp_ev e2 e2t a_st = (Some o, a_st')) by eauto.
    destruct_conjs.
    cbn.
    df.
    assert (evMapped e2t H7).
    {
      eapply evmapped_relevant.
      do_ba_st_const.
      destruct_conjs.
      split.
      symmetry.
      eassumption.
      
      split; eauto.
      eassumption.
    }
    assert (exists o a_st', build_app_comp_ev e2 e2t H7 = (Some o, a_st')) by eauto.
    destruct_conjs.
    subst'.
    df.
    eauto.

  -
    cbn.
    evShapeFacts.
    evMappedFacts.
    
    assert (exists o a_st', build_app_comp_ev e1 e1t a_st = (Some o, a_st')) by eauto.
    assert (exists o a_st', build_app_comp_ev e2 e2t a_st = (Some o, a_st')) by eauto.
    destruct_conjs.
    cbn.
    df.
    assert (evMapped e2t H7).
    {
      eapply evmapped_relevant.
      do_ba_st_const.
      destruct_conjs.
      split.
      symmetry.
      eassumption.
      
      split; eauto.
      eassumption.
    }
    assert (exists o a_st', build_app_comp_ev e2 e2t H7 = (Some o, a_st')) by eauto.
    destruct_conjs.
    subst'.
    df.
    eauto.",0,Proof
am_trace_cumul,"forall  e et e_res
                          nm nm' ni ni' amap amap' smap smap' hmap hmap' tr tr' cs cs',
    build_app_comp_ev e et {| am_nonceMap := nm;
                           am_nonceId := ni;
                           st_aspmap := amap;
                           st_sigmap := smap;
                           st_hshmap := hmap;
                           am_st_trace:= tr;
                           checked := cs
                        |}
    = (Some e_res, {| am_nonceMap := nm';
                      am_nonceId := ni';
                      st_aspmap := amap';
                      st_sigmap := smap';
                      st_hshmap := hmap';
                      am_st_trace:= tr';
                      checked := cs'
                        |}) -> 
    exists tr'', tr' = tr ++ tr''",1,Lemma
am_trace_cumul_proof,"intros.
  generalizeEverythingElse e.
  induction e; intros;
    try (repeat ff; evShapeFacts; eauto).",0,Proof
mt_subT_all,"forall e,
    EvSubT mt e",1,Lemma
mt_subT_all_proof,"intros.
  generalizeEverythingElse e.
  induction e; intros.
  -
    ff.
    exists [].
    rewrite app_nil_r.
    auto.
    destruct et; try solve_by_inversion.
  -
    repeat ff.
    unfold am_add_trace in *.
    ff.
    invc H1.
    edestruct IHe.
    eassumption.
    subst.
    eexists.
    rewrite app_assoc.
    eauto.
  -
    repeat ff.
    unfold am_add_trace in *.
    ff.
    invc H1.
    edestruct IHe.
    eassumption.
    subst.
    eexists.
    rewrite app_assoc.
    eauto.
  -
    repeat ff;
      amsts';
    repeat ff;
    eauto.
    (*
    exists [].
    rewrite app_nil_r.
    eauto. *)
  -
    repeat ff;
      amsts';
    unfold am_checkNonce in *;
    repeat ff;
    eauto.
  -
    repeat ff.
    amsts'.
    edestruct IHe1; eauto.
    subst.
    edestruct IHe2; eauto.
    subst.
    eexists.
    rewrite app_assoc.
    eauto.
  -
    repeat ff.
    amsts'.
    edestruct IHe1; eauto.
    subst.
    edestruct IHe2; eauto.
    subst.
    eexists.
    rewrite app_assoc.
    eauto.",0,Proof
mt_sub_all,"forall e,
    EvSub mtc e",1,Lemma
mt_sub_all_proof,"induction e; intros;
    try
      (econstructor; eauto; tauto).",0,Proof
evSubT_trans,"forall e' e e'',
  EvSubT e e' ->
  EvSubT e' e'' ->
  EvSubT e e''",1,Lemma
evSubT_trans_proof,"induction e; intros;
    try
      (econstructor; eauto; tauto).
  - (* hhc case *)
    econstructor.
    ff.
    apply mt_subT_all.",0,Proof
esub_esubt,"forall e e',
    EvSub e e' ->
    EvSubT (et_fun e) (et_fun e')",1,Lemma
esub_esubt_proof,"induction e''; intros;
    try (
        do_evsubT;
        try solve_by_inversion;
        try (econstructor; eauto);
        tauto).",0,Proof
evSub_trans,"forall e' e e'',
  EvSub e e' ->
  EvSub e' e'' ->
  EvSub e e''",1,Lemma
evSub_trans_proof,"intros.
  generalizeEverythingElse e'.
  induction e'; intros.
  -
    do_evsub.
    econstructor.
  -
    do_evsub.
    ff.
    econstructor.
    econstructor. eauto.
  -
    do_evsub.
    ff.
    econstructor.
    ff.
    econstructor.
    eauto.
  -
    do_evsub.
    ff.
    econstructor.
    econstructor. eauto.
  -
    do_evsub.
    ff.
    econstructor.
    econstructor. eauto.
  -
    do_evsub.
    econstructor; eauto.
    econstructor; eauto.
    apply ssSubrT.
    eauto.
  -
    do_evsub.
    econstructor; eauto.
    econstructor; eauto.
    apply ppSubrT.
    eauto.",0,Proof
evAccum,"forall t vmst vmst' e e',
  well_formed_r t -> 
  copland_compile t vmst = (Some tt, vmst') ->
  e = st_evT vmst ->
  e' = st_evT vmst' ->
  EvSubT e e'",1,Lemma
evAccum_proof,"induction e''; intros;
    try (
    do_evsub;
    try solve_by_inversion;
    try (econstructor; eauto);
    tauto).
  (*
  -
    do_evsub; eauto.
    +
      econstructor.
      eapply evSubT_trans.
      Focus 2.
      eassumption.
      apply esub_esubt; eauto. *)",0,Proof
evMappedSome,"forall e1 e2 a_st,
  EvSubT e1 e2 ->
  evMapped e2 a_st ->
  evMapped e1 a_st",1,Lemma
evMappedSome_proof,"intros.
  generalizeEverythingElse t.
  induction t; intros;
    try do_wf_pieces.
  -
    destruct a; repeat ff;
      try (repeat econstructor; eauto; tauto).
  -
    repeat ff.
    eapply IHt.
    eassumption.
    Check copland_compile_at.
    eapply copland_compile_at.
    eassumption.
    tauto.
    tauto.
  -
    vmsts.
    edestruct alseq_decomp_gen;
    eauto.
    destruct_conjs.
    simpl in *.
    subst.

    assert (EvSubT st_evT0 H5) by eauto.
    assert (EvSubT H5 st_evT) by eauto.
    eapply evSubT_trans; eauto.

  -
    repeat (vmsts; ff).
    destruct s;
      ff;
      econstructor;
      eauto; tauto.

  -
    repeat (vmsts; ff).
    destruct s;
      ff;
      econstructor;
      eauto; tauto.
    Unshelve.
    tauto.",0,Proof
evMappedAll,"forall e1 a_st a_st',
    evMapped e1 a_st ->
    am_nonceMap a_st = am_nonceMap a_st' ->
    (*am_nonceId a_st = am_nonceId a_st' -> *)
    st_aspmap a_st = st_aspmap a_st' ->
    st_sigmap a_st = st_sigmap a_st' ->
    evMapped e1 a_st'
 *)



Lemma subSome: forall e1 e2 e1t e2t x a_st a_st',
    EvSubT e1t e2t ->
    Ev_Shape e1 e1t ->
    build_app_comp_ev e2 e2t a_st = (Some x, a_st') ->
    exists x' ab_st ab_st', build_app_comp_ev e1 e1t ab_st = (Some x', ab_st')",1,Lemma
evMappedAll_proof,"induction e2; intros;
    try (
        try evShapeFacts;
    try evMappedFacts;
    do_evsubT;
      try (eauto; tauto);
      econstructor;
        try tauto;
        try (eexists; econstructor; eauto); tauto).
  (*
  -
    invc H.
    e
    +
      econstructor.
    +
      eapply evmapped_hsh_pieces; eauto. *)",0,Proof
app_evSub,"forall st_ev e_res t1 t2 ev1 tr1 p st_trace tr1'
              nm ni amap smap hmap tr cs
              nm' ni' amap' smap' hmap' x0 cs'
              nm2' ni2' amap2' smap2' hmap2' tr2 x1 cs2 cs2'
              x_res1 x_res2,
    
    (*EvSub e1 e2 -> *)

    copland_compile t1 {| st_ev := ev1; st_trace := tr1; st_pl := p |} =
    (Some tt, {| st_ev := st_ev; st_trace := st_trace; st_pl := p |}) ->
      
    copland_compile t2
    {| st_ev := st_ev; st_trace := st_trace; st_pl := p |} =
    (Some tt, {| st_ev := e_res; st_trace := tr1'; st_pl := p |}) ->


    build_app_comp_ev st_ev
                      {|
                        am_nonceMap := nm;
                        am_nonceId := ni;
                        st_aspmap := amap;
                        st_sigmap := smap;
                        st_hshmap := hmap;
                        am_st_trace := tr;
                        checked := cs |} =
    (Some x_res1,
     {|
       am_nonceMap := nm';
       am_nonceId := ni';
       st_aspmap := amap';
       st_sigmap := smap';
       st_hshmap := hmap';
       am_st_trace := tr ++ x0;
       checked := cs' |}) ->

    build_app_comp_ev e_res
                      {|
                        am_nonceMap := nm;
                        am_nonceId := ni;
                        st_aspmap := amap;
                        st_sigmap := smap;
                        st_hshmap := hmap;
                        am_st_trace := tr2;
                        checked := cs2 |} =
    (Some x_res2,
     {|
       am_nonceMap := nm2';
       am_nonceId := ni2';
       st_aspmap := amap2';
       st_sigmap := smap2';
       st_hshmap := hmap2';
       am_st_trace := tr2 ++ x1;
       checked := cs2' |}) ->

    (forall ev, In ev x0 -> In ev x1)",1,Lemma
app_evSub_proof,"intros.
  Check build_app_some.
  assert ( exists (o : EvidenceC) (a_st' : AM_St),
             build_app_comp_ev e1 e1t a_st = (Some o, a_st')).
  {
    eapply build_app_some.
    eapply evMappedSome.
    eassumption.
    eapply build_app_some'; eauto.
    eassumption.
  }
  destruct_conjs.
  eauto.",0,Proof
encodeEvRaw,(e:RawEv): BS,2,Definition
do_asp,(params :ASP_PARAMS) (e:RawEv) (mpl:Plc) (x:Event_ID) : BS,2,Definition
doRemote_session,(t:Term) (pTo:Plc) (e:EvC) : EvC,2,Definition
parallel_vm_thread,(l:Loc) (t:Core_Term) (p:Plc) (e:EvC) : EvC,2,Definition
am_sendReq,(t:Term) (pFrom:Plc) (pTo:Plc) (authTok:ReqAuthTok) (e:RawEv) : RawEv,2,Definition
do_asp,"' (params :ASP_PARAMS) (e:RawEv) (mpl:Plc) (x:Event_ID) : IO BS :=
  ret (do_asp params e mpl x)",2,Definition
doRemote_session,"' (t:Term) (pTo:Plc) (e:EvC) : IO EvC :=
  ret (doRemote_session t pTo e)",2,Definition
do_start_par_thread,"(loc:Loc) (t:Core_Term) (e:RawEv) : IO unit :=
  ret tt",2,Definition
do_wait_par_thread,"(loc:Loc) (t:Core_Term) (p:Plc) (e:EvC) : IO EvC :=
  ret (parallel_vm_thread loc t p e)",2,Definition
requester_bound,(t:Term) (fromPl:Plc) (authTok:ReqAuthTok) : bool,2,Definition
appraise_auth_tok,(res:AppResultC) : bool,2,Definition
IO,:= CVM,2,Definition
peel_bs_am,"(ls:RawEv) : AM (BS * RawEv) :=
  match ls with
  | bs :: ls' => ret (bs, ls')
  | _ => failm
  end",2,Definition
fromSome,"{A:Type} (default:A) (opt:option A): A :=
  match opt with
  | Some x => x
  | _ => default
  end",2,Definition
gen_appraise_am_comp,"(t:Term) (p:Plc) (et:Evidence) (ls:RawEv) : AM AppResultC :=
  gen_appraise_AM (eval t p et) ls",2,Definition
run_am_app_comp,"{A:Type} (am_comp:AM A) (default_A:A) : A :=
  let optRes := evalSt am_comp empty_amst in (* TODO:  use input nonce mapping here? *)
  fromSome default_A optRes",2,Definition
run_gen_appraise_am,"(t:Term) (p:Plc) (et:Evidence) (ls:RawEv) : AppResultC := 
  let am_appr_comp := gen_appraise_AM (eval t p et) ls in
  (run_am_app_comp am_appr_comp mtc_app)",2,Definition
am_sendReq_nonce,"(t:Term) (pFrom:Plc) (pTo:Plc) : AM AppResultC :=
  let nonce_bits := gen_nonce_bits in
  nid <- am_newNonce nonce_bits ;;
  let resev := am_sendReq t pFrom pTo (evc [] mt) [nonce_bits] in
  let expected_et := eval t pTo (nn nid) in
  gen_appraise_AM expected_et resev",2,Definition
am_sendReq_nonce_auth,"(t:Term) (pFrom:Plc) (pTo:Plc) : AM AppResultC :=
  let nonce_bits := gen_nonce_bits in
  nid <- am_newNonce nonce_bits ;;
  let auth_phrase := (* kim_meas *) ssl_sig in
  let auth_rawev := run_cvm_rawEv auth_phrase pFrom [] in
  let auth_et := eval auth_phrase pFrom mt in
  let resev := am_sendReq t pFrom pTo (evc auth_rawev auth_et) [nonce_bits]  in
  let expected_et := eval t pTo (nn nid) in
  gen_appraise_AM expected_et resev",2,Definition
am_sendReq_auth,"(t:Term) (pFrom:Plc) (pTo:Plc) (initEv:RawEv) : AM RawEv :=
  let auth_phrase := (* kim_meas *) ssl_sig in
  let auth_rawev := run_cvm_rawEv auth_phrase pFrom [] in
  let et := eval auth_phrase pFrom mt in
  let resev := am_sendReq t pFrom pTo (evc auth_rawev et) initEv in
  ret resev",2,Definition
run_am_sendReq_nonce_auth,"(t:Term) (pFrom:Plc) (pTo:Plc) : AppResultC :=
  let am_comp := am_sendReq_nonce_auth t pFrom pTo in
  (run_am_app_comp am_comp mtc_app)",2,Definition
am_check_auth_tok,"(t:Term) (fromPl:Plc) (authTok:ReqAuthTok) : AM AppResultC :=
  match authTok with
  | evc auth_ev auth_et => 
    appres <-
    (match (requester_bound t fromPl authTok) with
     | false => failm
     | true => gen_appraise_AM auth_et auth_ev
     end) ;;
    ret appres
  end",2,Definition
am_serve_auth_tok_req,"(t:Term) (fromPl:Plc) (myPl:Plc) (authTok:ReqAuthTok) (init_ev:RawEv): AM RawEv :=
  match authTok with
  | evc auth_ev auth_et => 
    v <- am_check_auth_tok t fromPl authTok ;;
    match (andb (requester_bound t fromPl authTok) (appraise_auth_tok v)) with
    | true =>
      match (privPolicy fromPl t) with
      | true => ret (run_cvm_rawEv t myPl init_ev)
      | false => failm
      end
        
    | false => failm
    end
  end",2,Definition
run_am_serve_auth_tok_req,"(t:Term) (fromPl:Plc) (myPl:Plc) (authTok:ReqAuthTok) (init_ev:RawEv) : RawEv :=
  run_am_app_comp (am_serve_auth_tok_req t fromPl myPl authTok init_ev) []",2,Definition
checkASP,(i:ASP_ID) (args:list Arg) (tpl:Plc) (tid:Plc) (bs:BS) : BS,2,Definition
checkSig,(ls:EvBits) (p:Plc) (sig:BS) : BS,2,Definition
checkHash,(e:Evidence) (p:Plc) (hash:BS) : BS,2,Definition
peel_bs,"(ls:EvBits) : option (BS * EvBits) :=
  match ls with
  | bs :: ls' => Some (bs, ls')
  | _ => None
  end",2,Definition
checkASP_fwd,"(p:Plc) (f:FWD) (params:ASP_PARAMS)
           (et:Evidence) (bs:BS) (ls:RawEv) : Opt EvidenceC :=
  match f with
  | COMP => res <- checkHH params bs ;;
           ret (hhc p params res et)
  | ENCR => res <- checkEE params bs ;;
           ret (eec p params res et)
  | _ => res <- checkASP params bs ;;
        
        ret (ggc p params bs mtc)
  end",2,Definition
run_gen_appraise,"(t:Term) (p:Plc) (et:Evidence) (nonceGolden:BS) (ls:RawEv) :=
  fromSome mtc_app (build_app_comp_evC (eval t p et) ls nonceGolden)",2,Definition
run_gen_appraise_w_nonce,"(t:Term) (p:Plc) (nonceIn:BS) (ls:RawEv) :=
  run_gen_appraise t p (nn 0) nonceIn ls",2,Definition
am_add_trace,"(tr':list Ev) : AM_St -> AM_St :=
  fun '{| am_nonceMap := nm;
        am_nonceId := ni;
        st_aspmap := amap;
        st_sigmap := smap;
        st_hshmap := hmap;
        am_st_trace := tr;
        checked := cs |} =>
    mkAM_St nm ni amap smap hmap (tr ++ tr') cs",2,Definition
am_add_tracem,"(tr:list Ev) : AM unit :=
  modify (am_add_trace tr)",2,Definition
am_run_cvm,"(annt:AnnoTerm) (e:EvidenceC) (et:Evidence) : AM EvidenceC :=
  let start_st := (mk_st e et [] 0) in
  let end_st := (run_cvm annt start_st) in
  am_add_tracem (st_trace end_st) ;;
  ret (st_ev end_st)",2,Definition
am_run_cvm_comp,"{A:Type} (comp:CVM A) : AM A :=
  let '(cvm_res, vmst') := (runSt comp empty_vmst) in
  match cvm_res with
  | Some v =>
    am_add_tracem (st_trace vmst') ;;
    ret v
  | _ => failm
  end",2,Definition
am_get_hsh_gv,"(p:Plc) (i:ASP_ID) : AM BS :=
  m <- gets st_hshmap ;;
  let maybeId := map_get m (p,i) in
  match maybeId with
  | Some i' => ret i'
  | None => failm
  end",2,Definition
am_get_hsh_golden_val,"(p:Plc) (et:Evidence): AM BS :=
  (*
    m <- gets st_aspmap ;;
    let maybeId := map_get m (p,i) in
    match maybeId with
    | Some i' => ret i'
    | None => failm
    end",2,Definition
am_check_hsh_eq,"(gv:BS) (actual:BS) : AM BS :=
  ret 1",2,Definition
am_add_trace,"(tr':list Ev) : AM_St -> AM_St :=
  fun '{| am_nonceMap := nm;
        am_nonceId := ni;
        st_aspmap := amap;
        st_sigmap := smap;
        st_hshmap := hmap;
        am_st_trace := tr;
        checked := cs |} =>
    mkAM_St nm ni amap smap hmap (tr ++ tr') cs",2,Definition
am_add_tracem,"(tr:list Ev) : AM unit :=
  modify (am_add_trace tr)",2,Definition
am_run_cvm,"(annt:AnnoTerm) (e:EvidenceC) (et:Evidence) : AM EvidenceC :=
  let start_st := (mk_st e et [] 0) in
  let end_st := (run_cvm annt start_st) in
  am_add_tracem (st_trace end_st) ;;
  ret (st_ev end_st)",2,Definition
am_run_cvm_comp,"{A:Type} (comp:CVM A) : AM A :=
  let '(cvm_res, vmst') := (runSt comp empty_vmst) in
  match cvm_res with
  | Some v =>
    am_add_tracem (st_trace vmst') ;;
    ret v
  | _ => failm
  end",2,Definition
am_get_hsh_gv,"(p:Plc) (i:ASP_ID) : AM BS :=
  m <- gets st_hshmap ;;
  let maybeId := map_get m (p,i) in
  match maybeId with
  | Some i' => ret i'
  | None => failm
  end",2,Definition
am_get_hsh_golden_val,"(p:Plc) (et:Evidence): AM BS :=
  (*
    m <- gets st_aspmap ;;
    let maybeId := map_get m (p,i) in
    match maybeId with
    | Some i' => ret i'
    | None => failm
    end",2,Definition
am_check_hsh_eq,"(gv:BS) (actual:BS) : AM BS :=
  ret 1",2,Definition
step_pl_eq,"forall st0 ev st1,
    step st0 ev st1 -> pl st0 = pl st1",1,Lemma
step_pl_eq_proof,"intros.
  induction H; simpl; auto.",0,Proof
step_seval,"forall st0 ev st1,
    step st0 ev st1 ->
    seval st0 = seval st1",1,Lemma
step_seval_proof,"intros.
  induction H; simpl; auto; try rewrite IHstep; auto.
  apply step_pl_eq in H. rewrite H; auto.",0,Proof
lstar_transitive,"forall st0 tr0 st1 tr1 st2,
    lstar st0 tr0 st1 ->
    lstar st1 tr1 st2 ->
    lstar st0 (tr0 ++ tr1) st2",1,Lemma
lstar_transitive_proof,"intros.
  induction H.
  - rewrite app_nil_l; auto.
  - apply IHlstar in H0.
    rewrite <- app_comm_cons.
    eapply lstar_tran; eauto.
  - apply IHlstar in H0.
    eapply lstar_silent_tran; eauto.",0,Proof
star_transitive,"forall st0 st1 st2,
    star st0 st1 ->
    star st1 st2 ->
    star st0 st2",1,Lemma
star_transitive_proof,"intros.
  induction H; auto.
  apply IHstar in H0.
  eapply star_tran; eauto.",0,Proof
lstar_star,"forall st0 tr st1,
    lstar st0 tr st1 -> star st0 st1",1,Lemma
lstar_star_proof,"intros.
  induction H; auto;
    eapply star_tran; eauto.",0,Proof
star_lstar,"forall st0 st1,
    star st0 st1 -> exists tr, lstar st0 tr st1",1,Lemma
star_lstar_proof,"intros.
  induction H; auto.
  - exists []; auto.
  - destruct IHstar as [tr G].
    destruct e.
    + exists (e :: tr).
      eapply lstar_tran; eauto.
    + exists tr.
      eapply lstar_silent_tran; eauto.",0,Proof
star_seval,"forall st0 st1,
    star st0 st1 -> seval st0 = seval st1",1,Lemma
star_seval_proof,"intros.
  induction H; auto.
  apply step_seval in H; auto.
  rewrite H; auto.",0,Proof
steps_preserves_eval,"forall t p p' e0 e1,
    star (conf t p e0) (stop p' e1) ->
    aeval t p e0 = e1",1,Lemma
steps_preserves_eval_proof,"intros.
  apply star_seval in H.
  simpl in H; auto.",0,Proof
star_strem,"forall st0 st1 j p,
    star st0 st1 -> star (rem j p st0) (rem j p st1)",1,Lemma
star_strem_proof,"intros.
  induction H; auto.
  eapply star_tran; eauto.",0,Proof
star_stls,"forall st0 st1 t,
    star st0 st1 -> star (ls st0 t) (ls st1 t)",1,Lemma
star_stls_proof,"intros.
  induction H; auto.
  eapply star_tran; eauto.",0,Proof
star_stbsl,"forall st0 st1 j t p e,
    star st0 st1 ->
    star (bsl j st0 t p e) (bsl j st1 t p e)",1,Lemma
star_stbsl_proof,"intros.
  induction H; auto.
  eapply star_tran; eauto.",0,Proof
star_stbsr,"forall st0 st1 j e,
    star st0 st1 ->
    star (bsr j e st0) (bsr j e st1)",1,Lemma
star_stbsr_proof,"intros.
  induction H; auto.
  eapply star_tran; eauto.",0,Proof
lstar_stls,"forall st0 st1 t tr,
    lstar st0 tr st1 -> lstar (ls st0 t) tr (ls st1 t)",1,Lemma
lstar_stls_proof,"intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.",0,Proof
lstar_strem,"forall st st' tr p r,
    lstar st tr
          st' ->
    lstar (rem r p st) tr (rem r p st')",1,Lemma
lstar_strem_proof,"intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.",0,Proof
lstar_stbsl,"forall st0 st1 j t p e tr,
    lstar st0 tr st1 ->
    lstar (bsl j st0 t p e) tr (bsl j st1 t p e)",1,Lemma
lstar_stbsl_proof,"intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.",0,Proof
lstar_stbsr,"forall st0 st1 j e tr,
    lstar st0 tr st1 ->
    lstar (bsr j e st0) tr (bsr j e st1)",1,Lemma
lstar_stbsr_proof,"intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.",0,Proof
lstar_stbparl,"forall st0 st1 st2 j tr,
    lstar st0 tr st1 ->
    lstar (bp j st0 st2) tr (bp j st1 st2)",1,Lemma
lstar_stbparl_proof,"intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.",0,Proof
lstar_stbparr,"forall st0 st1 st2 j tr,
    lstar st1 tr st2 ->
    lstar (bp j st0 st1) tr (bp j st0 st2)",1,Lemma
lstar_stbparr_proof,"intros.
  induction H; auto.
  eapply lstar_tran; eauto.
  eapply lstar_silent_tran; eauto.",0,Proof
star_stbp,"forall st0 st1 st2 st3 j,
    star st0 st1 ->
    star st2 st3 ->
    star (bp j st0 st2) (bp j st1 st3)",1,Lemma
star_stbp_proof,"intros.
  induction H; auto.
  - induction H0; auto.
    eapply star_tran; eauto.
  - eapply star_tran; eauto.",0,Proof
nstar_transitive,"forall m n st0 st1 st2,
    nstar m st0 st1 ->
    nstar n st1 st2 ->
    nstar (m + n) st0 st2",1,Lemma
nstar_transitive_proof,"induction t; intros; simpl; eauto.
  - eapply star_tran; eauto.
  - (* destruct p. *)
    eapply star_tran; eauto.
    eapply star_transitive.
    apply star_strem.
    apply IHt.
    eapply star_tran; eauto.
  - eapply star_tran; eauto.
    eapply star_transitive.
    apply star_stls.
    apply IHt1.
    eapply star_tran; eauto.
    
  - eapply star_tran; eauto.
    eapply star_transitive.
    apply star_stbsl.
    apply IHt1.
    eapply star_tran; eauto.
    eapply star_transitive.
    apply star_stbsr.
    apply IHt2.
    eapply star_tran; eauto.
    
  -
    repeat dest_range.
    (*destruct p; destruct p0. *)
    eapply star_tran; eauto.
    eapply star_transitive.
    apply star_stbp.
    apply IHt1.
    apply IHt2.
    eapply star_tran; eauto.",0,Proof
nstar_star,"forall n st0 st1,
    nstar n st0 st1 -> star st0 st1",1,Lemma
nstar_star_proof,"induction st0.
  - left; simpl; auto.
  - right.
    destruct a.
    + exists (Some (asp_event (fst r) a p e)).
      eapply ex_intro; eauto.
    + exists (Some (req (fst r) p p0 (unanno a) e)).
      repeat dest_range.
      eapply ex_intro; eauto.
    + exists None.
      eapply ex_intro; eauto.
      
    + exists (Some (split (fst r) p)).
      eapply ex_intro; eauto.
      
    + exists (Some (Term_Defs.split(fst r) p)).
      (*destruct p; destruct p0. *)
      repeat dest_range.
      eapply ex_intro; eauto.
  -
    right.
    destruct IHst0.
    + destruct st0; simpl in H; try tauto.
      exists (Some (rpy (pred n) p p0 e)).
      eapply ex_intro; eauto.
    + destruct H as [e H].
      exists e.
      destruct H as [st1 H].
      exists (rem n p st1); auto.
  -
    right.
    destruct IHst0.
    + destruct st0; simpl in H; try tauto.
      exists None. eapply ex_intro; eauto.
    + destruct H as [e H].
      exists e.
      destruct H as [st H].
      exists (ls st a). auto.
          
  -
    right.
    destruct IHst0.
    + destruct st0; simpl in H; try tauto.
      exists None. eapply ex_intro; eauto.
    + destruct H as [e0 H].
      exists e0.
      destruct H as [st H].
      exists (bsl n st a p e). auto.
  - right.
    destruct IHst0.
    + destruct st0; simpl in H; try tauto.
      exists (Some (join (pred n) p)).
      eapply ex_intro; eauto.
    + destruct H as [e0 H].
      exists e0.
      destruct H as [st H].
      exists (bsr n e st). auto.
         
  - right.
    destruct IHst0_1 as [H|H].
    + destruct st0_1; simpl in H; try tauto.
      clear H.
      destruct IHst0_2.
      * destruct st0_2; simpl in H; try tauto.
        exists (Some (join (pred n) p0)).
        eapply ex_intro; eauto.
      * destruct H as [e0 H].
        exists e0.
        destruct H as [st H].
        exists (bp n (stop p e) st). auto.
    + destruct H as [e0 H].
      exists e0.
      destruct H as [st H].
      exists (bp n st st0_2). auto.",0,Proof
star_nstar,"forall st0 st1,
    star st0 st1 ->
    exists n, nstar n st0 st1",1,Lemma
star_nstar_proof,"intros.
  induction H0.
  rewrite Nat.add_0_r; auto.
  apply IHnstar in H.
  eapply nstar_tran in H; eauto.
  rewrite plus_n_Sm in H.
  eauto.",0,Proof
halt_size,"forall st,
    halt st <-> ssize st = 0",1,Lemma
halt_size_proof,"intros.
  induction H; auto.
  eapply star_transitive; eauto.
  eapply star_tran; eauto.",0,Proof
step_size,"forall st0 e st1,
    step st0 e st1 ->
    S (ssize st1) = ssize st0",1,Lemma
step_size_proof,"intros.
  induction H.
  - exists 0; auto.
  - destruct IHstar as [n G].
    exists (S n).
    rewrite <- Nat.add_1_l.
    eapply nstar_transitive; eauto.
    eapply nstar_tran; eauto.",0,Proof
step_count,"forall n t p e st,
    nstar n (conf t p e) st ->
    tsize t = n + ssize st",1,Lemma
step_count_proof,"split; intros.
  - destruct st; simpl in H; try tauto.
  - destruct st; simpl in H; try tauto;
      try discriminate.
    + simpl; auto.
    + destruct a; simpl in H; discriminate.",0,Proof
nlstar_transitive,"forall m n st0 tr0 st1 tr1 st2,
    nlstar m st0 tr0 st1 ->
    nlstar n st1 tr1 st2 ->
    nlstar (m + n) st0 (tr0 ++ tr1) st2",1,Lemma
nlstar_transitive_proof,"intros.
  induction H; simpl; auto; lia.",0,Proof
nlstar_lstar,"forall n st0 tr st1,
    nlstar n st0 tr st1 -> lstar st0 tr st1",1,Lemma
nlstar_lstar_proof,"induction n; intros.
  - inv H; simpl; auto.
  - inv H.
    apply IHn in H1.
    rewrite H1.
    apply step_size in H2.
    lia.",0,Proof
lstar_nlstar,"forall st0 tr st1,
    lstar st0 tr st1 ->
    exists n, nlstar n st0 tr st1",1,Lemma
lstar_nlstar_proof,"intros.
  apply step_count in H.
  apply halt_size.
  lia.",0,Proof
nlstar_step_size,"forall n st0 tr st1,
    nlstar n st0 tr st1 ->
    ssize st1 <= ssize st0",1,Lemma
nlstar_step_size_proof,"intros.
  induction H.
  - rewrite app_nil_l; auto.
  - apply IHnlstar in H0.
    rewrite <- app_comm_cons.
    eapply nlstar_tran; eauto.
  - apply IHnlstar in H0.
    eapply nlstar_silent_tran; eauto.",0,Proof
lstar_nlstar_size,"forall st0 tr st1,
    lstar st0 tr st1 ->
    nlstar (ssize st0 - ssize st1) st0 tr st1",1,Lemma
lstar_nlstar_size_proof,"intros.
  induction H; auto.
  - eapply lstar_tran; eauto.
  - eapply lstar_silent_tran; eauto.",0,Proof
rlstar_transitive,"forall m n st0 tr0 st1 tr1 st2,
    rlstar m st0 tr0 st1 ->
    rlstar n st1 tr1 st2 ->
    rlstar (m + n) st0 (tr0 ++ tr1) st2",1,Lemma
rlstar_transitive_proof,"intros.
  induction H.
  - exists 0; auto.
  - destruct IHlstar as [n G].
    exists (S n).
    eapply nlstar_tran; eauto.
  - destruct IHlstar as [n G].
    exists (S n).
    eapply nlstar_silent_tran; eauto.",0,Proof
rlstar_lstar,"forall n st0 tr st1,
    rlstar n st0 tr st1 -> lstar st0 tr st1",1,Lemma
rlstar_lstar_proof,"intros.
  induction H; auto;
    apply step_size in H;
    lia.",0,Proof
lstar_rlstar,"forall st0 tr st1,
    lstar st0 tr st1 ->
    exists n, rlstar n st0 tr st1",1,Lemma
lstar_rlstar_proof,"intros.
  induction H.
  - rewrite Nat.sub_diag; auto.
  - pose proof H as G.
    apply step_size in G.
    rewrite <- G.
    rewrite <- minus_Sn_m.
    + eapply nlstar_tran; eauto.
    + apply nlstar_step_size in IHlstar; auto.
  - pose proof H as G.
    apply step_size in G.
    rewrite <- G.
    rewrite <- minus_Sn_m.
    + eapply nlstar_silent_tran; eauto.
    + apply nlstar_step_size in IHlstar; auto.",0,Proof
rlstar_nlstar,"forall n st0 tr st1,
    rlstar n st0 tr st1 <-> nlstar n st0 tr st1",1,Lemma
rlstar_nlstar_proof,"intros.
  induction H0.
  - rewrite Nat.add_0_r; rewrite app_nil_r; simpl; auto.
  - apply IHrlstar in H.
    rewrite Nat.add_succ_r.
    rewrite app_assoc.
    eapply rlstar_tran; eauto.
  - apply IHrlstar in H.
    rewrite Nat.add_succ_r.
    eapply rlstar_silent_tran; eauto.",0,Proof
halt,"st :=
  match st with
  | stop _ _ => True
  | _ => False
  end",2,Definition
halt_proof,"intros.
  induction H; auto.
  - eapply lstar_transitive; eauto.
    eapply lstar_tran; eauto.
  - rewrite <- app_nil_r with (l:=tr).
    eapply lstar_transitive; eauto.
    apply lstar_silent_tran with st2; auto.",0,Proof
esize_tr,"forall t p e tr,
    trace t p e tr -> length tr = esize t",1,Lemma
esize_tr_proof,"Allowed.
(** The traces associated with a state. *)

Inductive traceS: St -> list Ev -> Prop :=
| tstop: forall p e,
    traceS (stop p e) []
| tconf: forall t tr p e,
    trace t p e tr ->
    traceS (conf t p e) tr
| trem: forall st tr j p,
    traceS st tr ->
    traceS (rem j p st)
           (tr ++
               [(rpy (pred j) p (pl st) (seval st))])
| tls: forall st tr1 t tr2,
    traceS st tr1 ->
    trace t (pl st) (seval st) tr2 ->
    traceS (ls st t) (tr1 ++ tr2)
| tbsl: forall st tr1 t p e tr2 j,
    traceS st tr1 ->
    trace t p e tr2 ->
    traceS (bsl j st t p e)
           (tr1 ++ tr2 ++
                [(join (pred j) p )])
| tbsr: forall st tr j e,
    traceS st tr ->
    traceS (bsr j e st)
           (tr ++ [(join (pred j) (pl st) )])
 | tbp: forall st1 tr1 st2 tr2 tr3 j,
    traceS st1 tr1 -> traceS st2 tr2 ->
    shuffle tr1 tr2 tr3 ->
    traceS (bp j st1 st2)
           (tr3 ++ [(join (pred j) (pl st2))]).
#[export] Hint Constructors traceS : core.

Fixpoint esizeS s:=
  match s with
  | stop _ _ => 0
  | conf t _ _ => esize t
  | rem _ _ st => 1 + esizeS st
  | ls st t => esizeS st + esize t
  | bsl _ st t _ _ => 1 + esizeS st + esize t
  | bsr _ _ st => 1 + esizeS st
  | bp _ st1 st2 => 1 + esizeS st1 + esizeS st2
  end.

Ltac inv_trace :=
  match goal with
  | H:trace (?C _) _ _ _ |- _ => inv H
  end.

Lemma esize_tr:
  forall t p e tr,
    trace t p e tr -> length tr = esize t.
Proof.
  induction t; intros; inv_trace; simpl;
    autorewrite with list; simpl; auto;
      try (
          try find_apply_lem_hyp shuffle_length;
          repeat find_apply_hyp_hyp;
          lia).",0,Proof
esizeS_tr,"forall st tr,
    traceS st tr -> length tr = esizeS st",1,Lemma
esizeS_tr_proof,"induction st; intros;
    inv_traceS; simpl; auto;
      try (destruct a; find_apply_lem_hyp esize_tr; tauto);
      repeat find_apply_lem_hyp esize_tr;
      repeat (rewrite app_length; simpl);
      repeat find_apply_hyp_hyp;
      repeat find_apply_lem_hyp shuffle_length;
      try lia.",0,Proof
step_silent_tr,"forall st st' tr,
    step st None st' ->
    traceS st' tr ->
    traceS st tr",1,Lemma
step_silent_tr_proof,"induction st; intros; inv H; inv H0.
  - constructor.
    constructor; auto.
    solve_by_inversion.
  -
    find_copy_apply_lem_hyp step_pl_eq.
    find_copy_apply_lem_hyp step_seval.
    jkjke'.
    jkjke'.
  -
    constructor.
    eauto.

    find_apply_lem_hyp step_pl_eq.
    find_copy_apply_lem_hyp step_seval.
    
    cbn in *.
    invc H.
    repeat find_rewrite.
    assert (traceS st tr1) by eauto.
    assert (seval st = seval st1).
    {
      eapply step_seval.
      eassumption.
    }
    repeat find_rewrite.
    eauto.
  -
    erewrite <- app_nil_l.
    constructor; auto.
  -
    eauto.
  -
    erewrite <- app_nil_l.
    apply tbsl; auto; simpl; auto.
    invc H.
    invc H5.
    eauto.
  -
    find_eapply_hyp_hyp; eauto.
    find_copy_apply_lem_hyp step_seval.
    find_copy_apply_lem_hyp step_pl_eq.
    jkjke'.
  -
    eauto.    
  -
    find_copy_apply_hyp_hyp; eauto.
    find_copy_apply_lem_hyp step_seval.
    find_copy_apply_lem_hyp step_pl_eq.
    jkjke'.",0,Proof
step_evt_tr,"forall st st' ev tr,
    step st (Some ev) st' ->
    traceS st' tr ->
    traceS st (ev::tr)",1,Lemma
step_evt_tr_proof,"induction st; intros; inv H; inv H0.
  - constructor.
    constructor.
  - constructor. apply tatt. simpl.
    solve_by_inversion.
  - constructor. apply tbseq; auto.
    solve_by_inversion.  
  - constructor.
    eapply tbpar; eauto; solve_by_inversion.
  -
    find_copy_apply_lem_hyp step_seval.
    find_copy_apply_lem_hyp step_pl_eq.
    jkjke'.
    jkjke'.
    rewrite app_comm_cons; eauto. 
  - rewrite <- app_nil_l.
    econstructor; eauto.
    (* apply trem; auto. *)
  -
    find_copy_apply_lem_hyp step_seval.
    find_copy_apply_lem_hyp step_pl_eq.
    rewrite app_comm_cons; auto.
    apply tls;
      try jkjk;
      eauto.
    repeat find_rewrite.
    eauto.    
  -
    find_copy_apply_lem_hyp step_seval.
    rewrite app_comm_cons; auto.
    eauto.
  -
    find_copy_apply_lem_hyp step_seval.
    find_copy_apply_lem_hyp step_pl_eq.
    rewrite app_comm_cons.
    jkjke'.
  - rewrite <- app_nil_l; constructor; auto.
  -
    find_copy_apply_lem_hyp step_seval.
    rewrite app_comm_cons.
    find_eapply_lem_hyp shuffle_left.
    eapply tbp; eauto.
  -
    find_copy_apply_lem_hyp step_seval.
    find_copy_apply_lem_hyp step_pl_eq.
    rewrite app_comm_cons.
    find_eapply_lem_hyp shuffle_right.
    jkjke'.
  -
    rewrite <- app_nil_l; auto.
    eapply tbp; eauto.",0,Proof
nlstar_trace_helper,"forall e p n st0 tr st1,
    step st0 e st1 ->
    nlstar n st1 tr (stop p (seval st0)) ->
    nlstar n st1 tr (stop p (seval st1))",1,Lemma
nlstar_trace_helper_proof,"intros e p n st0 tr st1 H G.
  apply step_seval in H.
  rewrite <- H.
  auto.",0,Proof
nlstar_trace,"forall n p st tr,
    nlstar n st tr (stop p (seval st)) ->
    traceS st tr",1,Lemma
nlstar_trace_proof,"induction n; intros; inv H; auto;
    eapply nlstar_trace_helper in H2; eauto;
      apply IHn in H2; auto.
  - eapply step_evt_tr; eauto.
  - eapply step_silent_tr; eauto.",0,Proof
lstar_trace,"forall t p e tr,
    well_formed_r_annt t ->
    lstar (conf t p e) tr (stop p (aeval t p e)) ->
    trace t p e tr",1,Lemma
lstar_trace_proof,"intros.
  apply lstar_nlstar in H0.
  destruct H0.
  apply nlstar_trace in H0.
  inv H0; auto.",0,Proof
ex18,(trc (R e3) Rely Rely),1,Lemma
ex18_proof,"intros k e a.
    unfold hasASPe.
    destruct (e k).
    * induction (asps m).
      right. unfold not. intros. inverts H.
      case (ASP_dec a a0).
      intros H. subst. left. simpl. auto.
      intros H. unfold not in H. destruct IHl. left. simpl. auto.
      right. unfold not. intros. unfold not in n. simpl in H0.
      destruct H0. apply H. subst. auto. apply n. assumption.
    * cbv. right. intros. assumption.",0,Proof
ex19,(trc (R e3) Rely Appraise),1,Lemma
ex19_proof,"intros k e a.
    induction e.
    + simpl in *. apply hasASP_dec.
    + simpl in *.  inverts IHe1; inverts IHe2.
    ++ left. left. apply H.
    ++ left. left. apply H.
    ++ left. right. apply H0.
    ++ right. unfold not in *. intros. inversion H1. congruence. congruence.",0,Proof
ex20,(trcs (Rs (union (env e3) (env e2))) Rely Appraise),1,Lemma
ex20_proof,unfold hasASPe. simpl. left. reflexivity.,0,Proof
Environment,: Type :=  Plc -> (option Manifest),2,Definition
Environment_proof,unfold hasASPe. simpl. intros. destruct H. inverts H. assumption.,0,Proof
e_empty,: Environment := (fun _ => None),2,Definition
e_empty_proof,unfold hasASPs. unfold hasASPe. simpl. left. reflexivity.,0,Proof
e_update,"(m : Environment) (x : Plc) (v : (option Manifest)) :=
    fun x' => if plc_dec x x' then v else m x'",2,Definition
e_update_proof,unfold hasASPs. left. unfold hasASPe. simpl. left. reflexivity.,0,Proof
e0,:= e_empty,2,Definition
e0_proof,"intros. induction l.
    + right. auto.
    + inversion IHl.
    ++ left. simpl. right. auto.
    ++ specialize X with a a0. inversion X.
    +++ simpl. left. left. apply eq_sym. apply H0.
    +++ simpl. right. unfold not. intros. inversion H1. apply eq_sym in H2. destruct H0. apply H2. destruct H. apply H2.",0,Proof
e1,":=
    e_update e0 Rely (Some {| asps := [aspc1]; M:= [Target] |})",2,Definition
e1_proof,"intros k e p.
    unfold knowsOfe.
    destruct (e k).
    induction (M m).
    right. simpl. unfold not. intros. assumption.
    case (string_dec p a).
    intros. subst. left. simpl. auto.
    intros H. unfold not in H. destruct IHl. left. simpl. auto.
    right. unfold not. intros. unfold not in n. simpl in H0.
    destruct H0. apply H. subst. auto. apply n. assumption.
    auto.",0,Proof
e2,":=
    e_update e1 Target (Some {| asps := [SIG;  aspc2]; M:= [Appraise] |})",2,Definition
e2_proof,"intros k s p.
      induction s; simpl in *.
      + apply knowsOfe_dec.
      + inverts IHs1; inverts IHs2.
      ++ left. left. apply H. 
      ++ left. left. apply H.
      ++ left. right. apply H0.
      ++ right. unfold not in *. intros. inverts H1; congruence.",0,Proof
e3,":=
    e_update e2 Appraise (Some {| asps := [HSH] ; M:= [] |})",2,Definition
e3_proof,unfold knowsOfe. simpl. auto.,0,Proof
example_sys_1,:= env e3,2,Definition
example_sys_1_proof,unfold knowsOfe. simpl. intros. destruct H. inverts H. assumption.,0,Proof
mapD_key_values_length,"forall m,
  length (mapD_vals m) = length (mapD_keys m)",1,Lemma
mapD_key_values_length_proof,"intros.
  induction m; simpl.
  - reflexivity.
  - destruct a. simpl. rewrite IHm. reflexivity.",0,Proof
MapC,(A:Type) (B:Type) `{H : EqClass A} := list (A * B),2,Definition
MapC_proof,"intros.
  induction m; simpl.
  - reflexivity.
  - destruct a; simpl; rewrite IHm; reflexivity.",0,Proof
map_empty,{A B:Type} `{H : EqClass A} : MapC A B := [],2,Definition
map_empty_proof,"intros.
  induction x; simpl;
  rewrite Nat.eqb_refl; reflexivity.",0,Proof
map_set,"{A B:Type} `{H : EqClass A} (m:MapC A B) (x:A) (v:B) : MapC A B := (x, v) :: m",2,Definition
map_set_proof,"intros.
  generalizeEverythingElse m.
  induction m; intros.
  -
    right.
    unfold not.
    intros.
    destruct_conjs.
    invc H1.
    simpl in *.
    solve_by_inversion.
  - specialize IHm with x.
    destruct IHm.
    * (* bound_to m x a *)
      destruct a.
      destruct (eqb x a) eqn:E.
      ** (* x = a *)
         left. exists b. econstructor. simpl. 
         rewrite E. auto.
      ** (* x <> a *)
        assert (exists a0, bound_to ((a,b) :: m) x a0). {
          destruct e. exists x0.
          inversion H0; subst. econstructor. simpl.
          rewrite E. auto.
        }
        left. auto.
    * (* ~ (exists a, bound_to m x a )*)
      destruct a.
      destruct (eqb x a) eqn:E.
      ** (* x = a *)
         left. exists b. econstructor; simpl; rewrite E; auto.
      ** (* x <> a *)
         assert (~ (exists a0, bound_to ((a,b) :: m) x a0)). {
          intros Contra. destruct Contra. inversion H0. subst.
          unfold map_get in H1. rewrite E in H1. simpl in *.
          destruct n. exists x0. econstructor. apply H1.
         }
         right. auto.",0,Proof
MapD,(A:Type) (B:Type) `{H : EqClass A} `{H1 : EqClass B} := list (A * B),2,Definition
mapD_empty,{A B:Type} `{H : EqClass A} `{H1 : EqClass B} : MapD A B := [],2,Definition
mapD_set,"{A B:Type} `{H : EqClass A} `{H1 : EqClass B} 
                    (m:MapD A B) (x:A) (v:B) : MapD A B := (x, v) :: m",2,Definition
monad_left_id,forall S A B (a:A)(f:A -> (GenStMonad,1,Lemma
monad_left_id_proof,"of monad laws for the general state monad in GenStMonad.v.

Author:  Adam Petz, ampetz@ku.edu
*)

Require Import GenStMonad.

Require Import StructTactics.

Lemma monad_left_id : forall S A B (a:A)(f:A -> (GenStMonad.St S) B) (s:S),
    (bind (ret a) f) s = (f a s).
Proof.
  intros.
  unfold ret.
  unfold bind.
  simpl.
  destruct (f a s).
  reflexivity.",0,Proof
monad_right_id,"forall S A (m:St S A) (s:S),
    (bind m ret) s = m s",1,Lemma
monad_right_id_proof,"intros.
  unfold ret.
  unfold bind.
  destruct (m s).
  destruct o; auto.",0,Proof
firstn_append,"forall l l': list A,
      firstn (length l) (l ++ l') = l",1,Lemma
firstn_append_proof,"induction n as [|k iHk]; intros l1 l2.
    - now simpl.
    - destruct l1 as [|x xs].
      * unfold skipn at 2, length.
        repeat rewrite app_nil_l.
        rewrite <- Minus.minus_n_O.
        auto.
      * rewrite <- app_comm_cons. simpl. apply iHk.",0,Proof
skipn_append,"forall l l': list A,
      skipn (length l) (l ++ l') = l'",1,Lemma
skipn_append_proof,"induction l; intros; simpl; auto.
    rewrite IHl; auto.",0,Proof
skipn_all,"forall l: list A,
      skipn (length l) l = []",1,Lemma
skipn_all_proof,induction l; intros; simpl; auto.,0,Proof
skipn_nil,"forall i,
      @skipn A i [] = []",1,Lemma
skipn_nil_proof,induction l; intros; simpl; auto.,0,Proof
firstn_all_n,"forall (l: list A) n,
      length l <= n ->
      firstn n l = l",1,Lemma
firstn_all_n_proof,destruct i; simpl; auto.,0,Proof
skipn_all_n,"forall (l: list A) n,
      length l <= n ->
      skipn n l = []",1,Lemma
skipn_all_n_proof,"induction l; intros; simpl.
    - rewrite firstn_nil; auto.
    - destruct n.
      simpl in H.
      lia.
      simpl in *.
      apply le_S_n in H.
      apply IHl in H.
      rewrite H; auto.",0,Proof
firstn_in,"forall x i (l: list A),
      In x (firstn i l) ->
      In x l",1,Lemma
firstn_in_proof,"induction l; intros; simpl.
    - rewrite skipn_nil; auto.
    - destruct n; simpl in *.
      lia.
      apply le_S_n in H.
      apply IHl; auto.",0,Proof
skipn_in,"forall x i (l: list A),
      In x (skipn i l) ->
      In x l",1,Lemma
skipn_in_proof,"induction i; intros.
    - simpl in H; tauto.
    - destruct l.
      + simpl in H; tauto.
      + simpl in H.
        destruct H.
        subst; simpl; auto.
        apply IHi in H.
        simpl; auto.",0,Proof
skipn_zero,"forall l: list A,
      skipn 0 l = l",1,Lemma
skipn_zero_proof,"induction i; intros.
    - simpl in H; tauto.
    - destruct l.
      + simpl in H; tauto.
      + simpl in H.
        apply IHi in H.
        simpl; auto.",0,Proof
in_skipn_cons,"forall i x y (l: list A),
      In x (skipn i l) ->
      In x (skipn i (y :: l))",1,Lemma
in_skipn_cons_proof,destruct l; simpl; auto.,0,Proof
nodup_append,"forall l l': list A,
      NoDup l -> NoDup l' ->
      disjoint_lists l l' ->
      NoDup (l ++ l')",1,Lemma
nodup_append_proof,"induction i; intros; simpl.
    - rewrite skipn_zero in H; auto.
    - destruct l.
      + simpl in H; tauto.
      + simpl in H; auto.",0,Proof
in_cons_app_cons,"forall x y z (l: list A),
      In x (y :: l ++ [z]) <->
      x = y \/ In x l \/ x = z",1,Lemma
in_cons_app_cons_proof,"intros.
    induction H.
    - rewrite app_nil_l; auto.
    - rewrite <- app_comm_cons.
      apply NoDup_cons.
      + intro.
        apply in_app_iff in H3.
        destruct H3; intuition.
        apply H1 in H3; try tauto; simpl; auto.
      + apply IHNoDup. unfold disjoint_lists; intros.
        apply H1 in H4; try tauto.
        simpl; auto.",0,Proof
earlier_in_left,"forall l x y,
      earlier l x y -> In x l",1,Lemma
earlier_in_left_proof,"intros.
    rewrite app_comm_cons.
    rewrite in_app_iff; simpl.
    intuition.",0,Proof
earlier_in_right,"forall l x y,
      earlier l x y -> In y l",1,Lemma
earlier_in_right_proof,"intros.
    destruct H as [i].
    destruct H.
    apply firstn_in in H; auto.",0,Proof
earlier_left,"forall p q x y,
      earlier p x y -> earlier (p ++ q) x y",1,Lemma
earlier_left_proof,"intros.
    destruct H as [i].
    destruct H.
    apply skipn_in in H0; auto.",0,Proof
earlier_right,"forall p q x y,
      earlier q x y -> earlier (p ++ q) x y",1,Lemma
earlier_right_proof,"intros.
    destruct H as [i].
    destruct H.
    exists i.
    split.
    - rewrite firstn_app.
      apply in_or_app.
      left; auto.
    - rewrite skipn_app.
      apply in_or_app.
      left; auto.",0,Proof
earlier_append,"forall p q x y,
      In x p -> In y q ->
      earlier (p ++ q) x y",1,Lemma
earlier_append_proof,"intros.
    destruct H as [i].
    destruct H.
    exists (length p + i).
    assert (G: length p + i - length p = i).
    lia.
    split.
    - rewrite firstn_app.
      apply in_or_app.
      right.
      rewrite G; auto.
    - rewrite skipn_app.
      apply in_or_app.
      right.
      rewrite G; auto.",0,Proof
earlier_append_iff,"forall x y (l l': list A),
      earlier (l ++ l') x y <->
      earlier l x y \/ In x l /\ In y l' \/ earlier l' x y",1,Lemma
earlier_append_iff_proof,"intros.
    exists (length p).
    rewrite firstn_append.
    rewrite skipn_append.
    auto.",0,Proof
earlier_cons,"forall p x y,
      In y p ->
      earlier (x :: p) x y",1,Lemma
earlier_cons_proof,"split; intros.
    - destruct H as [i].
      destruct H.
      rewrite firstn_app in H.
      rewrite skipn_app in H0.
      pose proof (le_lt_dec i (length l)) as G.
      destruct G as [G|G].
      + rewrite <- Nat.sub_0_le in G; auto.
        rewrite G in *.
        simpl in *.
        rewrite app_nil_r in H.
        apply in_app_iff in H0.
        destruct H0.
        * left; exists i; auto.
        * right; left; split; auto.
          apply firstn_in in H; auto.
      + right.
        rewrite firstn_all_n in H; try lia.
        rewrite skipn_all_n in H0; try lia.
        rewrite app_nil_l in H0.
        apply in_app_iff in H.
        destruct H.
        * apply skipn_in in H0; auto.
        * right.
          exists (i - length l); auto.
    - destruct H.
      apply earlier_left; auto.
      destruct H.
      + destruct H.
        apply earlier_append; auto.
      + apply earlier_right; auto.",0,Proof
earlier_cons_shift,"forall p x y z,
      earlier p x y ->
      earlier (z :: p) x y",1,Lemma
earlier_cons_shift_proof,intros; exists 1; simpl; auto.,0,Proof
disjoint_lists,"(l l': list A): Prop :=
    forall x, In x l -> In x l' -> False",2,Definition
disjoint_lists_proof,"intros.
    destruct H as [i].
    destruct H.
    exists (S i).
    simpl; auto.",0,Proof
earlier,"(l: list A) (x y: A) :=
    exists n,
      In x (firstn n l) /\
      In y (skipn n l)",2,Definition
ret,{A : Type} (a : A) : Opt A := (Some a),2,Definition
bind,"{A B : Type} (m : Opt A) (f : A -> Opt B) : Opt B :=
    match m with
    | Some v => f v
    | _ => None
    end",2,Definition
failm,{A : Type} : Opt A := None,2,Definition
runOpt,"{A} (h : Opt A) (default: A) : A :=
  match h with
    Some v => v
  | _ => default
  end",2,Definition
nop,:= ret tt,2,Definition
when,"{A} (b : bool) (m : Opt A) : Opt unit :=
  if b then m ;; ret tt else nop",2,Definition
fromSome,"{A:Type} (default:A) (opt:Opt A): A :=
  match opt with
  | Some x => x
  | _ => default
  end",2,Definition
sig_params,: ASP_PARAMS,2,Definition
hsh_params,: ASP_PARAMS,2,Definition
enc_params,: Plc -> ASP_PARAMS,2,Definition
St,(S A : Type) : Type := S -> (option A) * S % type,2,Definition
ret,"{S A : Type} (a : A) : St S A := fun s => (Some a, s)",2,Definition
bind,"{S A B : Type} (m : St S A) (f : A -> St S B) : St S B :=
  fun s =>
    let '(a, s') := m s in
    match a with
    | Some v =>
      let '(b, s'') := f v s' in
      (b, s'')
    | _ => (None,s')
    end",2,Definition
failm,"{S A : Type} : St S A := fun s => (None, s)",2,Definition
modify,"{S} (f : S -> S) : St S unit := fun s => (Some tt, f s)",2,Definition
put,"{S} (s : S) : St S unit := fun _ => (Some tt, s)",2,Definition
get,"{S} : St S S := fun s => (Some s, s)",2,Definition
runSt,"{S A} (h : St S A) (s : S)  : (option A) * S % type :=
  h s",2,Definition
evalSt,"{S A} (h : St S A) (s : S) : option A :=
 fst (runSt h s)",2,Definition
execSt,"{S A} (h : St S A) (s : S) : S :=
  snd ((*runSt*) h s)",2,Definition
nop,{S : Type} := @ret S _ tt,2,Definition
gets,"{S} {A} (f:S -> A) : St S A :=
  st <- get ;;
  ret (f st)",2,Definition
when,"{S A} (b : bool) (m : St S A) : St S unit :=
  if b then m ;; ret tt else nop",2,Definition
wfr_lseq_pieces,"forall r t1 t2,
    well_formed_r_annt (alseq r t1 t2) ->
    well_formed_r_annt t1 /\ well_formed_r_annt t2",1,Lemma
wfr_lseq_pieces_proof,"Allowed.
*)

Lemma wfr_lseq_pieces: forall r t1 t2,
    well_formed_r_annt (alseq r t1 t2) ->
    well_formed_r_annt t1 /\ well_formed_r_annt t2.
Proof.
  intros.
  inversion H.
  tauto.",0,Proof
wfr_at_pieces,"forall t r p,
    well_formed_r_annt (aatt r p t) ->
    well_formed_r_annt t",1,Lemma
wfr_at_pieces_proof,"intros.
  inversion H.
  tauto.",0,Proof
wfr_bseq_pieces,"forall r s t1 t2,
    well_formed_r_annt (abseq r s t1 t2) ->
    well_formed_r_annt t1 /\ well_formed_r_annt t2",1,Lemma
wfr_bseq_pieces_proof,"intros.
  inversion H.
  tauto.",0,Proof
wfr_bpar_pieces,"forall r s t1 t2,
    well_formed_r_annt (abpar r s t1 t2) ->
    well_formed_r_annt t1 /\ well_formed_r_annt t2",1,Lemma
wfr_bpar_pieces_proof,"intros.
  inversion H.
  tauto.",0,Proof
well_formed_range_r,"forall t,
    well_formed_r_annt t ->
    snd (range t) = fst (range t) + esize t",1,Lemma
well_formed_range_r_proof,"induction t;
    try (intros H; simpl; inv H; simpl;
         repeat find_apply_hyp_hyp; lia).",0,Proof
esize_nonempty,"forall t, esize t > 0",1,Lemma
esize_nonempty_proof,"intros.
  induction t; intros;
    try (destruct a);
    (cbn; lia).",0,Proof
wf_mono,"forall t,
    well_formed_r_annt t ->
    snd (range t) > fst (range t)",1,Lemma
wf_mono_proof,"intros.
  rewrite well_formed_range_r.
  pose (esize_nonempty t).
  lia.
  eauto.",0,Proof
asp_lrange_irrel,"forall a i a0 a1 n n',
    anno (asp a) i = (n, a0) ->
    anno (asp a) i = (n',a1) ->
    a0 = a1",1,Lemma
asp_lrange_irrel_proof,"intros.
  destruct a; ff.",0,Proof
events_range,"forall t v p e,
    well_formed_r_annt t ->
    events t p e v ->
    fst (range t) <= ev v < snd (range t)",1,Lemma
events_range_proof,"intros t v p e H H0.
  pose proof H as G.
  apply well_formed_range_r in G.
  rewrite G.
  clear G.
  induction H0;
    try (inv_wfr; simpl in *; auto;
         repeat find_apply_hyp_hyp;
         repeat (find_apply_lem_hyp well_formed_range_r); lia).",0,Proof
at_range,"forall x r i,
    S (fst r) = fst x ->
    snd r = S (snd x) ->
    fst r <= i < snd r ->
    i = fst r \/
    fst x <= i < snd x \/
    i = snd x",1,Lemma
at_range_proof,"intros.
  pose proof lt_dec i (S (fst r)) as G.
  destruct G as [G|G]; [left; lia| right].
  pose proof lt_dec i (snd x) as F.
  destruct F as [F|F]; [left; lia| right].
  lia.",0,Proof
lin_range,"forall x y i,
    snd x = fst y ->
    fst x <= i < snd y ->
    fst x <= i < snd x \/
    fst y <= i < snd y",1,Lemma
lin_range_proof,"intros.
  pose proof lt_dec i (snd x) as G.
  destruct G; lia.",0,Proof
bra_range,"forall x y r i,
    S (fst r) = fst x ->
    snd x = fst y ->
    snd r = S (snd y) ->
    fst r <= i < snd r ->
    i = fst r \/
    fst x <= i < snd x \/
    fst y <= i < snd y \/
    i = snd y",1,Lemma
bra_range_proof,"intros.
  pose proof lt_dec i (S (fst r)) as G.
  destruct G as [G|G]; [left; lia| right].
  pose proof lt_dec i (snd x) as F.
  destruct F as [F|F]; [left; lia| right].
  pose proof lt_dec i (snd y) as E.
  destruct E; lia.",0,Proof
events_range_event,"forall t p i e,
    well_formed_r_annt t ->
    fst (range t) <= i < snd (range t) ->
    exists v, events t p e v /\ ev v = i",1,Lemma
events_range_event_proof,"intros t p i e H; revert i; revert p; revert e.
  induction H; intros; simpl in *.
  - destruct x; try destruct a; eapply ex_intro; split; auto;
      (*destruct r as [j k];*) simpl in *; try lia.
    (*
    + admit.
    + *)
      
  - find_eapply_lem_hyp at_range; eauto.
    repeat destruct_disjunct; subst; eauto.
    (* + eapply ex_intro; split; auto. *)

    find_eapply_hyp_hyp.
    (*apply IHwell_formed with (p:=p) in H2. *)
    destruct_conjs.
    eauto.
  -
    do_lin_range;       
      eauto;
      repeat destruct_disjunct;
      try lia;
      try (find_eapply_hyp_hyp; eauto;
           destruct_conjs;
           eauto).  
  -
    do_bra_range;
      eauto;
      repeat destruct_disjunct; subst;
        try lia;
        try (find_eapply_hyp_hyp; eauto;
             destruct_conjs;
             eauto; tauto).
    

    + eapply ex_intro; split; try (auto; eauto;tauto).
    + eapply ex_intro; split; try (eauto; auto; tauto).
      
  -
    do_bra_range;
      eauto;
      repeat destruct_disjunct; subst;
        try lia;
        try (find_eapply_hyp_hyp; eauto;
             destruct_conjs;
             eauto; tauto).

    + eapply ex_intro; split; auto.
    + eapply ex_intro; split; eauto.",0,Proof
events_injective,"forall t p e v1 v2,
    well_formed_r_annt t ->
    events t p e v1 ->
    events t p e v2 ->
    ev v1 = ev v2 ->
    v1 = v2",1,Lemma
events_injective_proof,"intros.
  generalizeEverythingElse H.
  induction H; intros;
    try (
        repeat wfr;
        aba; simpl in *; subst; auto;
        try (events_event_range; tauto);
        try (find_eapply_hyp_hyp; eauto);
        eauto).",0,Proof
asp_term_to_core,"(a:ASP) : Core_Term :=
  match a with
  | NULL => aspc NULLC
  | CPY => aspc CPYC
  | ASPC sp fwd params =>
    match sp with
    | NONE => lseqc (aspc CLEAR) (aspc (ASPCC fwd params))
    | ALL => (aspc (ASPCC fwd params))
    end                
  | SIG => aspc (ASPCC EXTD sig_params)
  | HSH => aspc (ASPCC COMP hsh_params)
  | ENC q => aspc (ASPCC ENCR (enc_params q))
  end",2,Definition
RawEv,:= list BS,2,Definition
mt_evc,: EvC := (evc [] mt),2,Definition
get_et,"(e:EvC) : Evidence :=
  match e with
  | evc ec et => et
  end",2,Definition
get_bits,"(e:EvC): list BS :=
  match e with
  | evc ls _ => ls
  end",2,Definition
ReqAuthTok,:= EvC,2,Definition
splitEv_T_l,"(sp:Split) (e:Evidence) : Evidence :=
  match sp with
  | (ALL,_) => e
  |  _ => mt
  end",2,Definition
splitEv_T_r,"(sp:Split) (e:Evidence) : Evidence :=
  match sp with
  | (_,ALL) => e
  |  _ => mt
  end",2,Definition
sp_ev,"(sp:SP) (e:Evidence) : Evidence :=
  match sp with
  | ALL => e
  | NONE => mt
  end",2,Definition
eval_asp,"t p e :=
  match t with
  | NULL => mt
  | CPY => e 
  | ASPC sp fwd params =>
    match fwd with
    | KEEP => (sp_ev sp e)
    | KILL => mt
    | _ => uu p fwd params (sp_ev sp e)
    end
  | SIG => uu p EXTD sig_params e
  | HSH => uu p COMP hsh_params e
  | ENC q => uu p ENCR (enc_params q) e
  end",2,Definition
ev,"x : nat :=
  match x with
  | null i _ => i
  | copy i _ => i
  | umeas i _ _ _ => i
  | req i _ _ _ _ => i
  | rpy i _ _ _ => i 
  | split i _ => i
  | join i _ => i
  | cvm_thread_start _ _ _ _ => 42
  | cvm_thread_end _ => 43
  end",2,Definition
asp_event,"i x p e :=
  match x with
  | NULL => null i p
  | CPY => copy i p
  | ASPC sp _ ps => umeas i p ps (sp_ev sp e)
  | SIG => umeas i p sig_params e
  | HSH => umeas i p hsh_params e
  | ENC q => umeas i p (enc_params q) e
  end",2,Definition
Plc,: Set := ID_Type,2,Definition
Plc_proof,"Allowed.
 *)


(*
Module Export Term_Defs_Core.
 *)





(** * Terms and Evidence

    A term is either an atomic ASP, a remote call, a sequence of terms
    with data a dependency, a sequence of terms with no data
    dependency, or parallel terms. *)

(** [Plc] represents a place (or attestation domain). *)
Definition Plc: Set := ID_Type.
(** [N_ID] represents a nonce identifier.  *)
Definition N_ID: Set := nat.
(** [Event_ID] represents Event identifiers *)
Definition Event_ID: Set := nat.

(** [ASP_ID], [TARG_ID], and [Arg] are all string-typed parameters to ASPs 
    [ASP_ID] identifies the procedure invoked.
    [TARG_ID] identifies the target (when a target makes sense).
    [Arg] represents a custom argument for a given ASP 
          (defined and interpreted per-scenario/implementaiton).
*)
Definition ASP_ID: Set := ID_Type.
Definition TARG_ID: Set := ID_Type.
Definition Arg: Set := ID_Type.

(** Grouping ASP parameters into one constructor *)
Inductive ASP_PARAMS: Set :=
| asp_paramsC: ASP_ID -> (list Arg) -> Plc -> TARG_ID -> ASP_PARAMS.

(** Evidence extension types for ASPs:
      COMP:  Compact evidence down to a single value (i.e. a hash).
      ENCR:  Like COMP, but the single value is semantically an ENCRYPTED one.
      EXTD:  Extend bundle (non-destructively) by prepending the new ASP result to the front.
      KILL:  Ignore evidence produced by an ASP and put Mt evidence.
      KEEP:  Ignore evidence produced by an ASP and keep the input evidence unchanged.


COMP:  [b1, b2, ..., bn] ==> [hash([b1, b2, ..., bn])]
ENCR:  [b1, b2, ..., bn] ==> [encrypt([b1, b2, ..., bn])]
EXTD:  [b1, b2, ..., bn] ==> [f([b1, b2, ..., bn]), b1, b2, ..., bn]], 
            where f represents the ASP's functional result over an input evidence bundle.
KILL:  [b1, b2, ..., bn] ==> []
KEEP:  [b1, b2, ..., bn] ==> [b1, b2, ..., bn]
*)
Inductive FWD: Set :=
| COMP
| ENCR
| EXTD
| KILL
| KEEP.

(** The structure of evidence. 

    mt:  Empty evidence 
    nn:  Nonce evidence (with an ID)
    uu:  ASP evidence 
    ss:  evidence pairing (composition)
*)
Inductive Evidence: Set :=
| mt: Evidence
| nn: N_ID -> Evidence
| uu: Plc -> FWD -> ASP_PARAMS -> Evidence -> Evidence
| ss: Evidence -> Evidence -> Evidence.

(** Evidene routing types:  
      ALL:   pass through all evidence
      NONE   pass through empty evidence
*)
Inductive SP: Set :=
| ALL
| NONE.


(** Primitive Copland phases 

    NULL:    Empty out evidence (optionally with a strong ""zeroize"" effect)
    CPY:     Copy evidence (leave input evidence unchanged)
    ASPC sp fwd ps:    
        Arbitrary ASPs:
          sp indicates passing ALL or NONE as input evidence.
          fwd indicates how to extend output evidence.
          ps indicates the asp parameters structure
    SIG:     Signature primitive
    HSH:     Hash primitive 
    ENC q:   Encryption primitive using public key associated with place q.
*)
Inductive ASP: Set :=
| NULL: ASP
| CPY: ASP
| ASPC: SP -> FWD -> ASP_PARAMS -> ASP
| SIG: ASP
| HSH: ASP
| ENC: Plc -> ASP.

(** Pair of evidence splitters that indicate routing evidence to subterms 
    of branching phrases *)
Definition Split: Set := (SP * SP).

(** Main Copland phrase datatype definition *)
Inductive Term: Set :=
| asp: ASP -> Term
| att: Plc -> Term -> Term
| lseq: Term -> Term -> Term
| bseq: Split -> Term -> Term -> Term
| bpar: Split -> Term -> Term -> Term.

(* Adapted from Imp language Notation in Software Foundations (Pierce) *)
Declare Custom Entry copland_entry.
Declare Scope cop_ent_scope.
Notation ""<{ e }>"" := e (at level 0, e custom copland_entry at level 99) : cop_ent_scope.
Notation ""( x )"" := x (in custom copland_entry, x at level 99) : cop_ent_scope.
Notation ""x"" := x (in custom copland_entry at level 0, x constr at level 0) : cop_ent_scope.
(* Branches*)
Notation ""x -<- y"" := (bseq (NONE, NONE) x y) (in custom copland_entry at level 70, right associativity).
Notation ""x +<- y"" := (bseq (ALL, NONE) x y) (in custom copland_entry at level 70, right associativity).
Notation ""x -<+ y"" := (bseq (NONE, ALL) x y) (in custom copland_entry at level 70, right associativity).
Notation ""x +<+ y"" := (bseq (ALL, ALL) x y) (in custom copland_entry at level 70, right associativity).
Notation ""x -~- y"" := (bpar (NONE, NONE) x y) (in custom copland_entry at level 70, right associativity).
Notation ""x +~- y"" := (bpar (ALL, NONE) x y) (in custom copland_entry at level 70, right associativity).
Notation ""x -~+ y"" := (bpar (NONE, ALL) x y) (in custom copland_entry at level 70, right associativity).
Notation ""x +~+ y"" := (bpar (ALL, ALL) x y) (in custom copland_entry at level 70, right associativity).
(* ARROW sequences *)
Notation ""x -> y"" := (lseq x y) (in custom copland_entry at level 99, right associativity).
(* ASP's *)
Notation ""!"" := (asp SIG) (in custom copland_entry at level 98).
Notation ""#"" := (asp HSH) (in custom copland_entry at level 98).
Notation ""* p"" := (asp (ENC p)) (in custom copland_entry at level 98).
Notation ""$"" := (asp KILL) (in custom copland_entry at level 98).
Notation ""'__'"" := (asp CPY) (in custom copland_entry at level 98).
Notation ""'{}'"" := (asp NULL) (in custom copland_entry at level 98).
Notation ""'<<' x y z '>>'"" := (asp (ASPC ALL EXTD (asp_paramsC x nil y z))) 
                      (in custom copland_entry at level 98).
(* @ plc phrase *)
Notation ""@ p [ ph ]"" := (att p ph) (in custom copland_entry at level 50).

Open Scope cop_ent_scope.
Definition test1 := <{ __ -> {} }>.
Example test1ex : test1 = (lseq (asp CPY) (asp NULL)). reflexivity.",0,Proof
N_ID,: Set := nat,2,Definition
Event_ID,: Set := nat,2,Definition
ASP_ID,: Set := ID_Type,2,Definition
TARG_ID,: Set := ID_Type,2,Definition
Arg,: Set := ID_Type,2,Definition
Split,: Set := (SP * SP),2,Definition
test1,:= <{ __ -> {} }>,2,Definition
test_enc,:= <{ __ -> * min_id_type}>,2,Definition
Loc,: Set := nat,2,Definition
Locs,: Set := list Loc,2,Definition
test2,:= <<core>{ __ -> {} }>,2,Definition
evsys_range,"forall t p e,
    es_range (ev_sys t p e) = range t",1,Lemma
evsys_range_proof,"Allowed.
*)

(** Construct an event system from an annotated term, place, and
    evidence. *)

Fixpoint ev_sys (t: AnnoTerm) p e: EvSys Ev :=
  match t with
  | aasp (i, j) x => leaf (i, j) (asp_event i x p e)
  | aatt (i, j) q x =>
    before (i, j)
      (leaf (i, S i) (req i p q (unanno x) e))
      (before (S i, j)
              (ev_sys x q e)
              (leaf (pred j, j) (rpy (pred j) p q (aeval x q e))))
  | alseq r x y => before r (ev_sys x p e)
                          (ev_sys y p (aeval x p e))
  | abseq (i, j) s x y =>
    before (i, j)
           (leaf (i, S i)
                 (Term_Defs.split i p))
           (before (S i, j)
                   (before (S i, (pred j))
                           (ev_sys x p (splitEv_T_l s e))
                           (ev_sys y p (splitEv_T_r s e)))
                   (leaf ((pred j), j)
                         (join (pred j) p)))
  | abpar (i, j) s x y =>
    before (i, j)
           (leaf (i, S i)
                 (Term_Defs.split i p))
           (before (S i, j)
                   (merge (S i, (pred j))
                           (ev_sys x p (splitEv_T_l s e))
                           (ev_sys y p (splitEv_T_r s e)))
                   (leaf ((pred j), j)
                         (join (pred j) p)))
  end.

Lemma evsys_range:
  forall t p e,
    es_range (ev_sys t p e) = range t.
Proof.
  induction t; intros; simpl; auto;
    repeat expand_let_pairs; simpl; auto.",0,Proof
well_structured_evsys,"forall t p e,
    well_formed_r_annt t ->
    well_structured ev (ev_sys t p e)",1,Lemma
well_structured_evsys_proof,"induction t; intros; inv_wfr; simpl;
    try (
    repeat expand_let_pairs; dest_range'; (*destruct r as [i k]; *)
      simpl in *; subst; auto;
      try destruct a; (* asp destruct *)
      try destruct a; (* asp params destruct *)
        repeat (econstructor; repeat rewrite evsys_range; auto);
        tauto).",0,Proof
evsys_events,"forall t p e ev,
    well_formed_r_annt t ->
    ev_in ev (ev_sys t p e) <-> events t p e ev",1,Lemma
evsys_events_proof,"split; revert p; revert e; induction t; intros; inv_wfr; simpl in *;
    repeat expand_let_pairs; dest_range'; simpl in *;
      try (destruct a; auto; do_evin; auto);

      try (destruct a; try (destruct a); auto; do_evin; auto; tauto);

      try (
          repeat dest_range;
          repeat (find_rewrite; simpl in * );
          repeat (do_evin; auto);
          inv_events; auto);
          
          repeat (find_rewrite; simpl in * );
          (find_apply_lem_hyp Nat.succ_inj  ) ; subst; auto;
            tauto.",0,Proof
supreme_unique,"forall t p e,
    well_formed_r_annt t ->
    exists ! v, supreme (ev_sys t p e) v",1,Lemma
supreme_unique_proof,"intros t p e H.
  assert (G: well_structured ev (ev_sys t p e)).
  apply well_structured_evsys; auto.
  rewrite <- unique_existence.
  split.
  - exists (max (ev_sys t p e)).
    eapply supreme_max (*with (ev:=ev);*); eauto.
  - unfold uniqueness.
    intros x y H0 H1.
    erewrite <- sup_supreme (*with (ev:=ev)*) in H0; eauto.
    erewrite <- sup_supreme (*with (ev:=ev)*) in H1; eauto.
    revert H1.
    revert H0.
    revert G.
    revert p.
    revert e.
    induction H; intros;
      try(
          repeat dest_range; simpl in *;
          repeat break_let;
          repeat do_before_sup;

          try (inv_ws; eauto; tauto);

          repeat inv_sup; auto;
          tauto).",0,Proof
evsys_max_unique,"forall t p e,
    well_formed_r_annt t ->
    unique (supreme (ev_sys t p e)) (max (ev_sys t p e))",1,Lemma
evsys_max_unique_proof,"intros t p e H.
  assert (G: well_structured ev (ev_sys t p e)).
  apply well_structured_evsys; auto.
  unfold unique.
  split.
  apply supreme_max with (ev:=ev); auto.
  intros.
  rewrite <- sup_supreme with (ev:=ev) in H0; auto.
  revert H0.
  revert G.
  revert x'.
  revert p.
  revert e.
  induction H;
    intros;
    repeat dest_range;
    repeat expand_let_pairs;
    inv_ws.
  -
    repeat inv_sup; auto.
  -
    repeat inv_sup; auto.
  -
    cbn.
    apply IHwell_formed_r_annt2.
    eassumption.
    cbn in *.
    do_before_sup.
    eassumption.
  -
    repeat do_before_sup.
    solve_by_inversion.
  -
    do_before_sup.
    solve_by_inversion.",0,Proof
max_eval,"forall t p e,
    well_formed t ->
    out_ev (max (ev_sys t p e)) = aeval t p e",1,Lemma
max_eval_proof,"intros.
  revert e.
  revert p.
  induction H; intros; simpl; repeat expand_let_pairs; simpl; auto.
  destruct x; simpl; auto.",0,Proof
lseq_assoc,"forall t1 t2 t3 i p e n n' t' t'',
    anno (lseq t1 (lseq t2 t3)) i = (n, t') ->
    anno (lseq (lseq t1 t2) t3) i = (n',t'') ->
  
    same_rel
      (ev_sys t' p e)
      (ev_sys t'' p e)",1,Lemma
lseq_assoc_proof,"intros; simpl.
  repeat expand_let_pairs; simpl.
  ff; repeat find_rewrite; ff.
  apply before_associative_pairs.",0,Proof
out_ev,"v :=
  match v with
  | copy _ _ e => e
  | kmeas _ _ _ _ e => e
  | umeas _ _ _ _ e => e
  | sign _ _ _ e => e
  | hash _ _ _ e => e
  | req _ _ _ e => e
  | rpy _ _ _ e => e
  | split _ _ _ _ e => e
  | join _ _ _ _ e => e
  end",2,Definition
shuffle_length,"forall es0 es1 es2,
    shuffle es0 es1 es2 ->
    length es0 + length es1 = length es2",1,Lemma
shuffle_length_proof,"intros es0 es1 es2 H.
  induction H; simpl; auto; lia.",0,Proof
shuffle_in_left,"forall e es0 es1 es2,
    shuffle es0 es1 es2 ->
    In e es0 ->
    In e es2",1,Lemma
shuffle_in_left_proof,"intros e es0 es1 es2 H H0.
  induction H; auto.
  - inv H0; tauto.
  - destruct H0.
    + subst; simpl; auto.
    + simpl; auto.
  - apply IHshuffle in H0.
    simpl; auto.",0,Proof
shuffle_in_right,"forall e es0 es1 es2,
    shuffle es0 es1 es2 ->
    In e es1 ->
    In e es2",1,Lemma
shuffle_in_right_proof,"intros e es0 es1 es2 H H0.
  induction H; auto.
  - inv H0; tauto.
  - apply IHshuffle in H0.
    simpl; auto.
  - destruct H0.
    subst; simpl; auto.
    apply IHshuffle in H0.
    simpl; auto.",0,Proof
shuffle_in,"forall e es0 es1 es2,
    shuffle es0 es1 es2 ->
    In e es2 <-> In e es0 \/ In e es1",1,Lemma
shuffle_in_proof,"intros e es0 es1 es2 H.
  split; intros H0.
  - induction H; simpl; auto;
    simpl in H0; destruct H0; auto;
      apply IHshuffle in H0; tauto.
  - destruct H0; auto.
    + eapply shuffle_in_left in H; eauto.
    + eapply shuffle_in_right in H; eauto.",0,Proof
shuffle_in_skipn_left,"forall i e es0 es1 es2,
    shuffle es0 es1 es2 ->
    In e (skipn i es0) ->
    In e (skipn i es2)",1,Lemma
shuffle_in_skipn_left_proof,"intros i e es0 es1 es2 H H0.
  revert H0.
  revert e.
  revert i.
  induction H; intros; auto.
  - rewrite skipn_nil in H0.
    inv H0.
  - destruct i.
    + simpl in *; auto; destruct H0; auto.
      specialize IHshuffle with (i:=0).
      simpl in IHshuffle; auto.
    + simpl in *; auto.
  - apply IHshuffle in H0.
    apply in_skipn_cons; auto.",0,Proof
shuffle_in_skipn_right,"forall i e es0 es1 es2,
    shuffle es0 es1 es2 ->
    In e (skipn i es1) ->
    In e (skipn i es2)",1,Lemma
shuffle_in_skipn_right_proof,"intros  i e es0 es1 es2 H H0.
  revert H0.
  revert e.
  revert i.
  induction H; intros; auto.
  - rewrite skipn_nil in H0.
    inv H0.
  - apply IHshuffle in H0.
    apply in_skipn_cons; auto.
  - destruct i; simpl in *; auto.
    destruct H0; auto; right.
    specialize IHshuffle with (i:=0).
    simpl in *; auto.",0,Proof
shuffle_earlier_left,"forall es0 es1 es2 e0 e1,
    earlier es0 e0 e1 ->
    shuffle es0 es1 es2 ->
    earlier es2 e0 e1",1,Lemma
shuffle_earlier_left_proof,"intros es0 es1 es2 e0 e1 H H0.
  destruct H as [i H].
  destruct H as [H H1].
  unfold earlier.
  revert H.
  revert H1.
  revert i.
  induction H0; intros.
  - rewrite firstn_nil in H; inv H.
  - exists i; auto.
  - destruct i.
    + simpl in *; tauto.
    + simpl in H, H1.
      destruct H; subst.
      * exists (S i); simpl; auto.
        split; auto.
        eapply shuffle_in_skipn_left; eauto.
      * eapply IHshuffle in H1; eauto.
        destruct H1 as [n].
        destruct H1.
        exists (S n); simpl; auto.
  - eapply IHshuffle in H1; eauto.
    destruct H1 as [n].
    destruct H1.
    exists (S n); simpl; auto.",0,Proof
shuffle_earlier_right,"forall es0 es1 es2 e0 e1,
    earlier es1 e0 e1 ->
    shuffle es0 es1 es2 ->
    earlier es2 e0 e1",1,Lemma
shuffle_earlier_right_proof,"intros.
  destruct H as [i H].
  destruct H.
  unfold earlier.
  revert H.
  revert H1.
  revert i.
  induction H0; intros.
  - exists i; auto.
  - rewrite firstn_nil in H; inv H.
  - eapply IHshuffle in H1; eauto.
    destruct H1 as [n].
    destruct H1.
    exists (S n); simpl; auto.
  - destruct i.
    + simpl in *; tauto.
    + simpl in H, H1.
      destruct H; subst.
      * exists (S i); simpl; auto.
        split; auto.
        eapply shuffle_in_skipn_right; eauto.
      * eapply IHshuffle in H1; eauto.
        destruct H1 as [n].
        destruct H1.
        exists (S n); simpl; auto.",0,Proof
shuffle_nodup_append,"forall tr0 tr1 tr2,
    NoDup tr0 -> NoDup tr1 ->
    disjoint_lists tr0 tr1 ->
    shuffle tr0 tr1 tr2 ->
    NoDup tr2",1,Lemma
shuffle_nodup_append_proof,"intros.
  induction H2; auto.
  - apply NoDup_cons.
    + intro.
      eapply shuffle_in in H2.
      apply H2 in H3.
      destruct H3.
      * inv H; tauto.
      * apply H1 in H3; simpl; auto.
    + apply IHshuffle; auto.
      * inv H; auto.
      * unfold disjoint_lists; intros.
        apply H1 in H4; auto.
        simpl; auto.
  - apply NoDup_cons.
    + intro.
      eapply shuffle_in in H2.
      apply H2 in H3.
      destruct H3.
      * apply H1 in H3; simpl in H3; auto.
      * inv H0; tauto.
    + apply IHshuffle; auto.
      * inv H0; auto.
      * unfold disjoint_lists; intros.
        apply H1 in H3; auto.
        simpl in H3; auto.",0,Proof
trace_length,"forall t p e tr,
    trace t p e tr -> esize t = length tr",1,Lemma
trace_length_proof,"induction t; intros; inv H;
    simpl; auto; rewrite app_length; simpl; auto;
      try (repeat find_eapply_hyp_hyp;
           try rewrite app_length; simpl in *;
           try find_apply_lem_hyp shuffle_length;
           lia).",0,Proof
trace_events,"forall t p e tr v,
    well_formed_r_annt t ->
    trace t p e tr ->
    In v tr <-> events t p e v",1,Lemma
trace_events_proof,"split; intros.
  - induction H0; inv_wfr.
    +
      destruct x; do_nodup.
    +
      inv_in.
      constructor; auto.
      rewrite in_app_iff in *.
      destruct_disjunct.
      eauto.
      inv_in; try solve_by_inversion.
      apply evtsattrpy.
      lia.
      (*   
      eauto.
      eapply IHtrace.
      eassumption.
      repeat find_rewrite.
      Print evtsattrpy.

      
      econstructor.
      apply evtsattrpy; auto.
      econstructor.
      
      apply evtsatt; auto.
      inv H; try inv H1.
      rewrite H9; simpl.
      apply evtsattrpy; auto. *)
    +
      rewrite in_app_iff in *.
      destruct_disjunct.
      * apply evtslseql; auto.
      * apply evtslseqr; auto.
        
    +
      inv_in; subst; try solve_by_inversion.
      rewrite in_app_iff in *; destruct_disjunct.
      apply evtsbseql; auto.
      rewrite in_app_iff in *; destruct_disjunct.
      apply evtsbseqr; auto.
      inv_in; subst; try solve_by_inversion.
      repeat find_rewrite.
      apply evtsbseqjoin; auto. 
    +
      

      inv_in; subst; try solve_by_inversion.
      rewrite in_app_iff in *; destruct_disjunct.
      apply shuffle_in with (e:=v) in H0.
      destruct H0.
      repeat concludes.
      destruct_disjunct.
      
      apply evtsbparl; auto.
      apply evtsbparr; auto.
      inv_in.
      repeat find_rewrite.
      solve_by_inversion.

  - induction H0; inv H.
    + inv H1; destruct r as [i j]; simpl in *; auto.
    + simpl; rewrite in_app_iff; simpl.
      inv H1; auto.
      right; right.
      repeat find_rewrite; simpl; auto.
    + rewrite in_app_iff.
      inv H1; auto.

      
    + simpl.
      rewrite in_app_iff.
      rewrite in_app_iff.
      simpl.
      inv H1; auto.
      repeat find_rewrite.
      auto.
      
    + simpl.
      rewrite in_app_iff.
      simpl.
      inv_events; auto;
      (*
      inv H1; auto. *)
      
        try
          (find_apply_hyp_hyp; auto;
           try (find_eapply_lem_hyp shuffle_in_left; eauto; tauto);
           try find_eapply_lem_hyp shuffle_in_right; eauto; tauto);
        try
          (repeat find_rewrite; auto; tauto).",0,Proof
trace_range,"forall t p e tr v,
    well_formed_r_annt t ->
    trace t p e tr ->
    In v tr ->
    fst (range t) <= ev v < snd (range t)",1,Lemma
trace_range_proof,"intros.
  rewrite trace_events in H1; eauto.
  eapply events_range; eauto.",0,Proof
trace_range_event,"forall t p e tr i,
    well_formed_r_annt t ->
    trace t p e tr ->
    fst (range t) <= i < snd (range t) ->
    exists v, In v tr /\ ev v = i",1,Lemma
trace_range_event_proof,"intros.
  eapply events_range_event in H1; eauto.
  destruct H1 as [v G]; destruct G as [G]; subst.
  rewrite <- trace_events in G; eauto.",0,Proof
trace_injective_events,"forall t p e tr v0 v1,
    well_formed_r_annt t ->
    trace t p e tr ->
    In v0 tr -> In v1 tr ->
    ev v0 = ev v1 ->
    v0 = v1",1,Lemma
trace_injective_events_proof,"intros.
  rewrite trace_events in H1; eauto.
  rewrite trace_events in H2; eauto.
  eapply events_injective; eauto.",0,Proof
nodup_trace,"forall t p e tr,
    well_formed_r_annt t ->
    trace t p e tr ->
    NoDup tr",1,Lemma
nodup_trace_proof,"induction t; intros; inv_wfr; inv H0.
  - constructor; auto; constructor.
  - destruct r as [i j]; simpl in *; subst; simpl.
    apply NoDup_cons.
    + intro.
      rewrite in_app_iff in *. 
      destruct_disjunct.
      *
        find_eapply_lem_hyp trace_range; eauto.
        simpl in *.
        lia.
      *
        inv_in.
        solve_by_inversion.
    +
      apply nodup_append; unfold disjoint_lists; auto; intros.
      * eapply IHt; eauto.
      * constructor; auto; constructor.
      *
        inv_in.
        find_eapply_lem_hyp trace_range; eauto.
        simpl in *.
        lia.
  -
    apply nodup_append; unfold disjoint_lists; auto; intros; eauto.
    repeat tr_wf.
    lia.
  -
    dest_range'; simpl in *; subst; simpl.
      
    apply NoDup_cons.
    + intro.
      repeat rewrite in_app_iff in *;
      repeat destruct_disjunct;
        try solve_by_inversion.     
      *
        tr_wf.
        simpl in *.
        lia.
      *
        repeat tr_wf.
        simpl in *.
        repeat find_eapply_lem_hyp well_formed_range_r; auto.
        lia.
      * inv_in.
        solve_by_inversion.
    + apply nodup_append; unfold disjoint_lists; auto; intros.
      * eapply IHt1; eauto.
      * apply nodup_append; unfold disjoint_lists; auto; intros;
          try eauto;
          try do_nodup;
          try (inv_in; repeat tr_wf; simpl in *; lia).
      *
        rewrite in_app_iff in *; destruct_disjunct.
        repeat tr_wf.
        lia.

        inv_in.
        repeat tr_wf.
        repeat find_eapply_lem_hyp well_formed_range_r; auto.
        simpl in *.
        lia.   
  -
    dest_range'; simpl in *; subst; simpl.
    apply NoDup_cons.
    + intro HH.
      rewrite in_app_iff in *; destruct_disjunct;
        try (inv_in; solve_by_inversion; tauto).
      *
        find_eapply_lem_hyp shuffle_in; eauto.
        
        destruct_disjunct;
          try (inv_in; solve_by_inversion);
          try solve_by_inversion;
          try (tr_wf;
               simpl in * ;
               lia).
        
        --
          tr_wf.
          simpl in *.
          repeat find_eapply_lem_hyp well_formed_range_r; auto.
          lia.
        
    + apply nodup_append; unfold disjoint_lists; auto; intros.
      *

        find_eapply_lem_hyp shuffle_nodup_append;
          unfold disjoint_lists; auto; intros;
            eauto.
        repeat tr_wf.
        simpl in *.
        lia.
      *
        do_nodup.
      *
        inv_in.
        --
          find_eapply_lem_hyp shuffle_in; eauto;
            destruct_disjunct;
            repeat tr_wf;
              simpl in *;  
              try find_eapply_lem_hyp well_formed_range_r; eauto;
                simpl in * ;
                lia.",0,Proof
evsys_tr_in,"forall t p e tr ev0,
    well_formed_r_annt t ->
    trace t p e tr ->
    ev_in ev0 (ev_sys t p e) ->
    In ev0 tr",1,Lemma
evsys_tr_in_proof,"intros.
  induction H0; inv_wfr; simpl in *;
    try expand_let_pairs; do_evin; simpl; auto;
      try (left; solve_by_inversion).
  -
    rewrite in_app_iff in *.
    right.
    do_evin; eauto.
    do_evin.
    try (try right; left; solve_by_inversion).  
  -
    rewrite in_app_iff; auto.
  -
    rewrite in_app_iff; auto.   
  -
    right.
    rewrite in_app_iff in *.
    do_evin; auto.
    +
      do_evin; auto;
        eauto.
      rewrite in_app_iff; auto.
    +
      do_evin; auto.
      (repeat rewrite in_app_iff; right).
      right.
      left.
      auto.    
  - right.
    do_evin; auto.
    +
      do_evin; auto.
      *
        repeat find_apply_hyp_hyp.
        do_shuf_l.
        rewrite in_app_iff; auto.
      *
        find_eapply_hyp_hyp; auto.

        do_shuf_r.
        rewrite in_app_iff; auto.
    +
      do_evin.
      rewrite in_app_iff; right; simpl; auto.",0,Proof
get_data,"' : Term :=
  asp (
  ASPC ALL EXTD (asp_paramsC get_data_aspid get_data_args source_plc get_data_targid))",2,Definition
get_data_proof,"destruct H; cbv. 
  assert (eqb get_data_aspid get_data_aspid = true). rewrite eqb_leibniz; eauto.
  rewrite H. 
  assert (eqb dest_plc dest_plc = true). rewrite eqb_leibniz; eauto.
  rewrite H0. 
  assert (eqb source_plc source_plc = true). rewrite eqb_leibniz; eauto.
  rewrite H1. eauto.",0,Proof
